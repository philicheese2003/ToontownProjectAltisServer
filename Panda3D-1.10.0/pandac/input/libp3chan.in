1494874399
3 2
9 libp3chan 4 8NZB 12 panda3d.core 
218
217 37 upcast_to_TypedWritableReferenceCount 0 12 435 48 AnimGroup::upcast_to_TypedWritableReferenceCount 0 1 11 52
upcast from AnimGroup to TypedWritableReferenceCount
84
TypedWritableReferenceCount *AnimGroup::upcast_to_TypedWritableReferenceCount(void);

218 21 downcast_to_AnimGroup 0 12 436 50 TypedWritableReferenceCount::downcast_to_AnimGroup 0 1 12 54
downcast from TypedWritableReferenceCount to AnimGroup
68
AnimGroup *TypedWritableReferenceCount::downcast_to_AnimGroup(void);

219 17 upcast_to_Namable 0 12 435 28 AnimGroup::upcast_to_Namable 0 1 13 32
upcast from AnimGroup to Namable
44
Namable *AnimGroup::upcast_to_Namable(void);

220 21 downcast_to_AnimGroup 0 12 437 30 Namable::downcast_to_AnimGroup 0 1 14 34
downcast from Namable to AnimGroup
48
AnimGroup *Namable::downcast_to_AnimGroup(void);

221 9 AnimGroup 0 4 435 20 AnimGroup::AnimGroup 0 2 1 2 607
// This is the normal AnimGroup constructor.

/**
 * The default constructor is protected: don't try to create an AnimGroup
 * without a parent.  To create an AnimChannel hierarchy, you must first
 * create an AnimBundle, and use that to create any subsequent children.
 */

/**
 * Creates a new AnimGroup, just like this one, without copying any children.
 * The new copy is added to the indicated parent.  Intended to be called by
 * make_copy() only.
 */

/**
 * Creates the AnimGroup, and adds it to the indicated parent.  The only way
 * to delete it subsequently is to delete the entire hierarchy.
 */
123
AnimGroup::AnimGroup(AnimGroup *parent, std::string const &name);
inline AnimGroup::AnimGroup(AnimGroup const &) = default;

222 10 ~AnimGroup 0 6 435 21 AnimGroup::~AnimGroup 0 0 10
/**
 *
 */
36
virtual AnimGroup::~AnimGroup(void);

223 16 get_num_children 0 4 435 27 AnimGroup::get_num_children 0 1 3 58
/**
 * Returns the number of child nodes of the group.
 */
44
int AnimGroup::get_num_children(void) const;

224 9 get_child 0 4 435 20 AnimGroup::get_child 0 1 4 46
/**
 * Returns the nth child of the group.
 */
45
AnimGroup *AnimGroup::get_child(int n) const;

225 15 get_child_named 0 4 435 26 AnimGroup::get_child_named 0 1 5 250
/**
 * Returns the first child found with the indicated name, or NULL if no such
 * child exists.  This method searches only the children of this particular
 * AnimGroup; it does not recursively search the entire graph.  See also
 * find_child().
 */
69
AnimGroup *AnimGroup::get_child_named(std::string const &name) const;

226 10 find_child 0 4 435 21 AnimGroup::find_child 0 1 6 210
/**
 * Returns the first descendant found with the indicated name, or NULL if no
 * such descendant exists.  This method searches the entire graph beginning at
 * this AnimGroup; see also get_child_named().
 */
64
AnimGroup *AnimGroup::find_child(std::string const &name) const;

227 16 sort_descendants 0 4 435 27 AnimGroup::sort_descendants 0 1 7 262
/**
 * Sorts the children nodes at each level of the hierarchy into alphabetical
 * order.  This should be done after creating the hierarchy, to guarantee that
 * the correct names will match up together when the AnimBundle is later bound
 * to a PlayerRoot.
 */
39
void AnimGroup::sort_descendants(void);

228 6 output 0 6 435 17 AnimGroup::output 0 1 8 54
/**
 * Writes a one-line description of the group.
 */
51
virtual void AnimGroup::output(ostream &out) const;

229 5 write 0 6 435 16 AnimGroup::write 0 1 9 78
/**
 * Writes a brief description of the group and all of its descendants.
 */
68
virtual void AnimGroup::write(ostream &out, int indent_level) const;

230 14 get_class_type 0 4 435 25 AnimGroup::get_class_type 0 1 10 0
50
static TypeHandle AnimGroup::get_class_type(void);

231 10 AnimBundle 0 4 439 22 AnimBundle::AnimBundle 0 2 15 16 207
/**
 *
 */

/**
 *
 */

/**
 * Creates a new AnimBundle, just like this one, without copying any children.
 * The new copy is added to the indicated parent.  Intended to be called by
 * make_copy() only.
 */
149
inline AnimBundle::AnimBundle(std::string const &name, PN_stdfloat fps, int num_frames);
inline AnimBundle::AnimBundle(AnimBundle const &) = default;

232 11 copy_bundle 0 4 439 23 AnimBundle::copy_bundle 0 1 17 236
/**
 * Returns a full copy of the bundle and its entire tree of nested AnimGroups.
 * However, the actual data stored in the leaves--that is, animation tables,
 * such as those stored in an AnimChannelMatrixXfmTable--will be shared.
 */
60
PointerTo< AnimBundle > AnimBundle::copy_bundle(void) const;

233 19 get_base_frame_rate 0 4 439 31 AnimBundle::get_base_frame_rate 0 1 18 307
/**
 * Returns the ideal number of frames per second of the animation, when it is
 * running at normal speed.  This may not be the same as the actual playing
 * frame rate, as it might have been adjusted through set_play_rate() on the
 * AnimControl object.  See AnimControl::get_effective_frame_rate().
 */
58
inline double AnimBundle::get_base_frame_rate(void) const;

234 14 get_num_frames 0 4 439 26 AnimBundle::get_num_frames 0 1 19 109
/**
 * Returns the number of frames of animation, or 0 if the animation has no
 * fixed number of frames.
 */
50
inline int AnimBundle::get_num_frames(void) const;

235 14 get_class_type 0 4 439 26 AnimBundle::get_class_type 0 1 20 0
51
static TypeHandle AnimBundle::get_class_type(void);

236 11 ~AnimBundle 0 4 439 23 AnimBundle::~AnimBundle 0 0 0
30
AnimBundle::~AnimBundle(void);

237 14 AnimBundleNode 0 4 440 30 AnimBundleNode::AnimBundleNode 0 1 21 330
/**
 * The AnimBundle and its node should be constructed together.  Generally, the
 * derived classes of AnimBundleNode will automatically create a AnimBundle of
 * the appropriate type, and pass it up to this constructor.
 */

/**
 * For internal use only.
 */

/**
 * Use make_copy() or copy_subgraph() to copy one of these.
 */
83
inline AnimBundleNode::AnimBundleNode(std::string const &name, AnimBundle *bundle);

238 10 get_bundle 0 4 440 26 AnimBundleNode::get_bundle 0 1 22 10
/**
 *
 */
58
inline AnimBundle *AnimBundleNode::get_bundle(void) const;

239 16 find_anim_bundle 0 4 440 32 AnimBundleNode::find_anim_bundle 0 1 23 205
/**
 * Recursively walks the scene graph beginning at the indicated node (which
 * need not be an AnimBundleNode), and returns the first AnimBundle found.
 * Returns NULL if no AnimBundle can be found.
 */
69
static AnimBundle *AnimBundleNode::find_anim_bundle(PandaNode *root);

240 14 get_class_type 0 4 440 30 AnimBundleNode::get_class_type 0 1 24 0
55
static TypeHandle AnimBundleNode::get_class_type(void);

241 15 ~AnimBundleNode 0 4 440 31 AnimBundleNode::~AnimBundleNode 0 0 0
38
AnimBundleNode::~AnimBundleNode(void);

242 37 upcast_to_TypedWritableReferenceCount 0 12 442 48 PartGroup::upcast_to_TypedWritableReferenceCount 0 1 43 52
upcast from PartGroup to TypedWritableReferenceCount
84
TypedWritableReferenceCount *PartGroup::upcast_to_TypedWritableReferenceCount(void);

243 21 downcast_to_PartGroup 0 12 436 50 TypedWritableReferenceCount::downcast_to_PartGroup 0 1 44 54
downcast from TypedWritableReferenceCount to PartGroup
68
PartGroup *TypedWritableReferenceCount::downcast_to_PartGroup(void);

244 17 upcast_to_Namable 0 12 442 28 PartGroup::upcast_to_Namable 0 1 45 32
upcast from PartGroup to Namable
44
Namable *PartGroup::upcast_to_Namable(void);

245 21 downcast_to_PartGroup 0 12 437 30 Namable::downcast_to_PartGroup 0 1 46 34
downcast from Namable to PartGroup
48
PartGroup *Namable::downcast_to_PartGroup(void);

246 9 PartGroup 0 4 442 20 PartGroup::PartGroup 0 1 25 501
// This is the normal PartGroup constructor.

/**
 * This constructor is only intended for interal use and for derived classes.
 * You should normally use the non-default constructor, below.
 */

/**
 * This constructor is only intended for interal use and for derived classes.
 * You should normally use the make_copy() interface to make copies..
 */

/**
 * Creates the PartGroup, and adds it to the indicated parent.  The only way
 * to delete it subsequently is to delete the entire hierarchy.
 */
65
PartGroup::PartGroup(PartGroup *parent, std::string const &name);

247 10 ~PartGroup 0 6 442 21 PartGroup::~PartGroup 0 0 10
/**
 *
 */
36
virtual PartGroup::~PartGroup(void);

248 18 is_character_joint 0 6 442 29 PartGroup::is_character_joint 0 1 26 156
/**
 * Returns true if this part is a CharacterJoint, false otherwise.  This is a
 * tiny optimization over is_of_type(CharacterType::get_class_type()).
 */
55
virtual bool PartGroup::is_character_joint(void) const;

249 9 make_copy 0 6 442 20 PartGroup::make_copy 0 1 27 110
/**
 * Allocates and returns a new copy of the node.  Children are not copied, but
 * see copy_subgraph().
 */
52
virtual PartGroup *PartGroup::make_copy(void) const;

250 13 copy_subgraph 0 4 442 24 PartGroup::copy_subgraph 0 1 28 84
/**
 * Allocates and returns a new copy of this node and of all of its children.
 */
48
PartGroup *PartGroup::copy_subgraph(void) const;

251 16 get_num_children 0 4 442 27 PartGroup::get_num_children 0 1 29 58
/**
 * Returns the number of child nodes of the group.
 */
44
int PartGroup::get_num_children(void) const;

252 9 get_child 0 4 442 20 PartGroup::get_child 0 1 30 46
/**
 * Returns the nth child of the group.
 */
45
PartGroup *PartGroup::get_child(int n) const;

253 15 get_child_named 0 4 442 26 PartGroup::get_child_named 0 1 31 250
/**
 * Returns the first child found with the indicated name, or NULL if no such
 * child exists.  This method searches only the children of this particular
 * PartGroup; it does not recursively search the entire graph.  See also
 * find_child().
 */
69
PartGroup *PartGroup::get_child_named(std::string const &name) const;

254 10 find_child 0 4 442 21 PartGroup::find_child 0 1 32 210
/**
 * Returns the first descendant found with the indicated name, or NULL if no
 * such descendant exists.  This method searches the entire graph beginning at
 * this PartGroup; see also get_child_named().
 */
64
PartGroup *PartGroup::find_child(std::string const &name) const;

255 16 sort_descendants 0 4 442 27 PartGroup::sort_descendants 0 1 33 262
/**
 * Sorts the children nodes at each level of the hierarchy into alphabetical
 * order.  This should be done after creating the hierarchy, to guarantee that
 * the correct names will match up together when the AnimBundle is later bound
 * to a PlayerRoot.
 */
39
void PartGroup::sort_descendants(void);

256 12 apply_freeze 0 4 442 23 PartGroup::apply_freeze 0 1 34 287
/**
 * Freezes this particular joint so that it will always hold the specified
 * transform.  Returns true if this is a joint that can be so frozen, false
 * otherwise.
 *
 * This is normally only called internally by PartBundle::freeze_joint(), but
 * you may also call it directly.
 */
62
bool PartGroup::apply_freeze(TransformState const *transform);

257 19 apply_freeze_matrix 0 6 442 30 PartGroup::apply_freeze_matrix 0 1 35 287
/**
 * Freezes this particular joint so that it will always hold the specified
 * transform.  Returns true if this is a joint that can be so frozen, false
 * otherwise.
 *
 * This is normally only called internally by PartBundle::freeze_joint(), but
 * you may also call it directly.
 */
112
virtual bool PartGroup::apply_freeze_matrix(LVecBase3 const &pos, LVecBase3 const &hpr, LVecBase3 const &scale);

258 19 apply_freeze_scalar 0 6 442 30 PartGroup::apply_freeze_scalar 0 1 36 287
/**
 * Freezes this particular joint so that it will always hold the specified
 * transform.  Returns true if this is a joint that can be so frozen, false
 * otherwise.
 *
 * This is normally only called internally by PartBundle::freeze_joint(), but
 * you may also call it directly.
 */
63
virtual bool PartGroup::apply_freeze_scalar(PN_stdfloat value);

259 13 apply_control 0 6 442 24 PartGroup::apply_control 0 1 37 311
/**
 * Specifies a node to influence this particular joint so that it will always
 * hold the node's transform.  Returns true if this is a joint that can be so
 * controlled, false otherwise.
 *
 * This is normally only called internally by PartBundle::control_joint(), but
 * you may also call it directly.
 */
55
virtual bool PartGroup::apply_control(PandaNode *node);

260 20 clear_forced_channel 0 6 442 31 PartGroup::clear_forced_channel 0 1 38 261
/**
 * Undoes the effect of a previous call to apply_freeze() or apply_control().
 * Returns true if the joint was modified, false otherwise.
 *
 * This is normally only called internally by PartBundle::release_joint(), but
 * you may also call it directly.
 */
51
virtual bool PartGroup::clear_forced_channel(void);

261 18 get_forced_channel 0 6 442 29 PartGroup::get_forced_channel 0 1 39 181
/**
 * Returns the AnimChannelBase that has been forced to this joint by a
 * previous call to apply_freeze() or apply_control(), or NULL if no such
 * channel has been applied.
 */
67
virtual AnimChannelBase *PartGroup::get_forced_channel(void) const;

262 5 write 0 6 442 16 PartGroup::write 0 1 40 78
/**
 * Writes a brief description of the group and all of its descendants.
 */
68
virtual void PartGroup::write(ostream &out, int indent_level) const;

263 16 write_with_value 0 6 442 27 PartGroup::write_with_value 0 1 41 117
/**
 * Writes a brief description of the group, showing its current value, and
 * that of all of its descendants.
 */
79
virtual void PartGroup::write_with_value(ostream &out, int indent_level) const;

264 14 get_class_type 0 4 442 25 PartGroup::get_class_type 0 1 42 0
50
static TypeHandle PartGroup::get_class_type(void);

265 29 upcast_to_TypedReferenceCount 0 12 445 42 AnimControl::upcast_to_TypedReferenceCount 0 1 60 46
upcast from AnimControl to TypedReferenceCount
70
TypedReferenceCount *AnimControl::upcast_to_TypedReferenceCount(void);

266 23 downcast_to_AnimControl 0 12 446 44 TypedReferenceCount::downcast_to_AnimControl 0 1 61 48
downcast from TypedReferenceCount to AnimControl
64
AnimControl *TypedReferenceCount::downcast_to_AnimControl(void);

267 23 upcast_to_AnimInterface 0 12 445 36 AnimControl::upcast_to_AnimInterface 0 1 62 40
upcast from AnimControl to AnimInterface
58
AnimInterface *AnimControl::upcast_to_AnimInterface(void);

268 23 downcast_to_AnimControl 0 12 447 38 AnimInterface::downcast_to_AnimControl 0 1 63 42
downcast from AnimInterface to AnimControl
58
AnimControl *AnimInterface::downcast_to_AnimControl(void);

269 17 upcast_to_Namable 0 12 445 30 AnimControl::upcast_to_Namable 0 1 64 34
upcast from AnimControl to Namable
46
Namable *AnimControl::upcast_to_Namable(void);

270 23 downcast_to_AnimControl 0 12 437 32 Namable::downcast_to_AnimControl 0 1 65 36
downcast from Namable to AnimControl
52
AnimControl *Namable::downcast_to_AnimControl(void);

271 12 ~AnimControl 0 6 445 25 AnimControl::~AnimControl 0 0 10
/**
 *
 */
40
virtual AnimControl::~AnimControl(void);

272 10 is_pending 0 4 445 23 AnimControl::is_pending 0 1 47 286
/**
 * Returns true if the AnimControl is being bound asynchronously, and has not
 * yet finished.  If this is true, the AnimControl's interface is still
 * available and will be perfectly useful (though get_anim() might return
 * NULL), but nothing visible will happen immediately.
 */
48
inline bool AnimControl::is_pending(void) const;

273 12 wait_pending 0 4 445 25 AnimControl::wait_pending 0 1 48 102
/**
 * Blocks the current thread until the AnimControl has finished loading and is
 * fully bound.
 */
37
void AnimControl::wait_pending(void);

274 8 has_anim 0 4 445 21 AnimControl::has_anim 0 1 49 154
/**
 * Returns true if the AnimControl was successfully loaded, or false if there
 * was a problem.  This may return false while is_pending() is true.
 */
46
inline bool AnimControl::has_anim(void) const;

275 22 set_pending_done_event 0 4 445 35 AnimControl::set_pending_done_event 0 1 50 205
/**
 * Specifies an event name that will be thrown when the AnimControl is
 * finished binding asynchronously.  If the AnimControl has already finished
 * binding, the event will be thrown immediately.
 */
72
void AnimControl::set_pending_done_event(std::string const &done_event);

276 22 get_pending_done_event 0 4 445 35 AnimControl::get_pending_done_event 0 1 51 113
/**
 * Returns the event name that will be thrown when the AnimControl is finished
 * binding asynchronously.
 */
60
std::string AnimControl::get_pending_done_event(void) const;

277 8 get_part 0 4 445 21 AnimControl::get_part 0 1 52 65
/**
 * Returns the PartBundle bound in with this AnimControl.
 */
46
PartBundle *AnimControl::get_part(void) const;

278 8 get_anim 0 4 445 21 AnimControl::get_anim 0 1 53 65
/**
 * Returns the AnimBundle bound in with this AnimControl.
 */
53
inline AnimBundle *AnimControl::get_anim(void) const;

279 17 get_channel_index 0 4 445 30 AnimControl::get_channel_index 0 1 54 358
/**
 * Returns the particular channel index associated with this AnimControl.
 * This channel index is the slot on which each AnimGroup is bound to its
 * associated PartGroup, for each joint in the animation.
 *
 * It will be true that
 * get_part()->find_child("n")->get_bound(get_channel_index()) ==
 * get_anim()->find_child("n"), for each joint "n".
 */
54
inline int AnimControl::get_channel_index(void) const;

280 16 get_bound_joints 0 4 445 29 AnimControl::get_bound_joints 0 1 55 369
/**
 * Returns the subset of joints controlled by this AnimControl.  Most of the
 * time, this will be BitArray::all_on(), for a normal full-body animation.
 * For a subset animation, however, this will be just a subset of those bits,
 * corresponding to the set of joints and sliders actually bound (as
 * enumerated by bind_hierarchy() in depth-first LIFO order).
 */
65
inline BitArray const &AnimControl::get_bound_joints(void) const;

281 14 set_anim_model 0 4 445 27 AnimControl::set_anim_model 0 1 56 515
/**
 * Associates the indicated PandaNode with the AnimControl.  By convention,
 * this node represents the root node of the model file that corresponds to
 * this AnimControl's animation file, though nothing in this code makes this
 * assumption or indeed does anything with this node.
 *
 * The purpose of this is simply to allow the AnimControl to keep a reference
 * count on the ModelRoot node that generated it, so that the model will not
 * disappear from the model pool until it is no longer referenced.
 */
58
inline void AnimControl::set_anim_model(PandaNode *model);

282 14 get_anim_model 0 4 445 27 AnimControl::get_anim_model 0 1 57 81
/**
 * Retrieves the pointer set via set_anim_model().  See set_anim_model().
 */
58
inline PandaNode *AnimControl::get_anim_model(void) const;

283 6 output 0 6 445 19 AnimControl::output 0 1 58 10
/**
 *
 */
53
virtual void AnimControl::output(ostream &out) const;

284 14 get_class_type 0 4 445 27 AnimControl::get_class_type 0 1 59 0
52
static TypeHandle AnimControl::get_class_type(void);

285 8 get_type 0 6 448 25 AnimChannelBase::get_type 0 1 66 0
57
virtual TypeHandle AnimChannelBase::get_type(void) const;

286 14 get_class_type 0 4 448 31 AnimChannelBase::get_class_type 0 1 67 0
56
static TypeHandle AnimChannelBase::get_class_type(void);

287 16 ~AnimChannelBase 0 4 448 33 AnimChannelBase::~AnimChannelBase 0 0 0
40
AnimChannelBase::~AnimChannelBase(void);

288 9 get_value 0 6 449 44 AnimChannel< ACMatrixSwitchType >::get_value 0 1 68 0
90
virtual void AnimChannel< ACMatrixSwitchType >::get_value(int frame, LMatrix4 &value) = 0;

289 24 get_value_no_scale_shear 0 6 449 59 AnimChannel< ACMatrixSwitchType >::get_value_no_scale_shear 0 1 69 72
// These transform-component methods only have meaning for matrix types.
101
virtual void AnimChannel< ACMatrixSwitchType >::get_value_no_scale_shear(int frame, LMatrix4 &value);

290 9 get_scale 0 6 449 44 AnimChannel< ACMatrixSwitchType >::get_scale 0 1 70 0
87
virtual void AnimChannel< ACMatrixSwitchType >::get_scale(int frame, LVecBase3 &scale);

291 7 get_hpr 0 6 449 42 AnimChannel< ACMatrixSwitchType >::get_hpr 0 1 71 0
83
virtual void AnimChannel< ACMatrixSwitchType >::get_hpr(int frame, LVecBase3 &hpr);

292 8 get_quat 0 6 449 43 AnimChannel< ACMatrixSwitchType >::get_quat 0 1 72 0
87
virtual void AnimChannel< ACMatrixSwitchType >::get_quat(int frame, LQuaternion &quat);

293 7 get_pos 0 6 449 42 AnimChannel< ACMatrixSwitchType >::get_pos 0 1 73 0
83
virtual void AnimChannel< ACMatrixSwitchType >::get_pos(int frame, LVecBase3 &pos);

294 9 get_shear 0 6 449 44 AnimChannel< ACMatrixSwitchType >::get_shear 0 1 74 0
87
virtual void AnimChannel< ACMatrixSwitchType >::get_shear(int frame, LVecBase3 &shear);

295 14 get_value_type 0 6 449 49 AnimChannel< ACMatrixSwitchType >::get_value_type 0 1 75 0
81
virtual TypeHandle AnimChannel< ACMatrixSwitchType >::get_value_type(void) const;

296 14 get_class_type 0 4 449 49 AnimChannel< ACMatrixSwitchType >::get_class_type 0 1 76 0
74
static TypeHandle AnimChannel< ACMatrixSwitchType >::get_class_type(void);

297 9 get_value 0 6 453 44 AnimChannel< ACScalarSwitchType >::get_value 0 0 0
93
virtual void AnimChannel< ACScalarSwitchType >::get_value(int frame, PN_stdfloat &value) = 0;

298 24 get_value_no_scale_shear 0 6 453 59 AnimChannel< ACScalarSwitchType >::get_value_no_scale_shear 0 0 72
// These transform-component methods only have meaning for matrix types.
104
virtual void AnimChannel< ACScalarSwitchType >::get_value_no_scale_shear(int frame, PN_stdfloat &value);

299 9 get_scale 0 6 453 44 AnimChannel< ACScalarSwitchType >::get_scale 0 1 77 0
87
virtual void AnimChannel< ACScalarSwitchType >::get_scale(int frame, LVecBase3 &scale);

300 7 get_hpr 0 6 453 42 AnimChannel< ACScalarSwitchType >::get_hpr 0 1 78 0
83
virtual void AnimChannel< ACScalarSwitchType >::get_hpr(int frame, LVecBase3 &hpr);

301 8 get_quat 0 6 453 43 AnimChannel< ACScalarSwitchType >::get_quat 0 1 79 0
87
virtual void AnimChannel< ACScalarSwitchType >::get_quat(int frame, LQuaternion &quat);

302 7 get_pos 0 6 453 42 AnimChannel< ACScalarSwitchType >::get_pos 0 1 80 0
83
virtual void AnimChannel< ACScalarSwitchType >::get_pos(int frame, LVecBase3 &pos);

303 9 get_shear 0 6 453 44 AnimChannel< ACScalarSwitchType >::get_shear 0 1 81 0
87
virtual void AnimChannel< ACScalarSwitchType >::get_shear(int frame, LVecBase3 &shear);

304 14 get_value_type 0 6 453 49 AnimChannel< ACScalarSwitchType >::get_value_type 0 1 82 0
81
virtual TypeHandle AnimChannel< ACScalarSwitchType >::get_value_type(void) const;

305 14 get_class_type 0 4 453 49 AnimChannel< ACScalarSwitchType >::get_class_type 0 1 83 0
74
static TypeHandle AnimChannel< ACScalarSwitchType >::get_class_type(void);

306 9 set_value 0 4 455 35 AnimChannelMatrixDynamic::set_value 0 2 84 85 153
/**
 * Explicitly sets the matrix value.
 */

/**
 * Explicitly sets the matrix value, using the indicated TransformState object
 * as a convenience.
 */
135
void AnimChannelMatrixDynamic::set_value(LMatrix4 const &value);
void AnimChannelMatrixDynamic::set_value(TransformState const *value);

307 14 set_value_node 0 4 455 40 AnimChannelMatrixDynamic::set_value_node 0 1 86 124
/**
 * Specifies a node whose transform will be queried each frame to implicitly
 * specify the transform of this joint.
 */
63
void AnimChannelMatrixDynamic::set_value_node(PandaNode *node);

308 19 get_value_transform 0 4 455 45 AnimChannelMatrixDynamic::get_value_transform 0 1 87 93
/**
 * Returns the explicit TransformState value that was set via set_value(), if
 * any.
 */
87
inline TransformState const *AnimChannelMatrixDynamic::get_value_transform(void) const;

309 14 get_value_node 0 4 455 40 AnimChannelMatrixDynamic::get_value_node 0 1 88 70
/**
 * Returns the node that was set via set_value_node(), if any.
 */
71
inline PandaNode *AnimChannelMatrixDynamic::get_value_node(void) const;

310 14 get_class_type 0 4 455 40 AnimChannelMatrixDynamic::get_class_type 0 1 89 0
65
static TypeHandle AnimChannelMatrixDynamic::get_class_type(void);

311 25 ~AnimChannelMatrixDynamic 0 4 455 51 AnimChannelMatrixDynamic::~AnimChannelMatrixDynamic 0 0 0
58
AnimChannelMatrixDynamic::~AnimChannelMatrixDynamic(void);

312 25 AnimChannelMatrixXfmTable 0 4 456 52 AnimChannelMatrixXfmTable::AnimChannelMatrixXfmTable 0 1 90 248
/**
 * Used only for bam loader.
 */

/**
 * Creates a new AnimChannelMatrixXfmTable, just like this one, without
 * copying any children.  The new copy is added to the indicated parent.
 * Intended to be called by make_copy() only.
 */

/**
 *
 */
97
AnimChannelMatrixXfmTable::AnimChannelMatrixXfmTable(AnimGroup *parent, std::string const &name);

313 11 is_valid_id 0 4 456 38 AnimChannelMatrixXfmTable::is_valid_id 0 1 91 80
/**
 * Returns true if the given letter is one of the nine valid table id's.
 */
73
static inline bool AnimChannelMatrixXfmTable::is_valid_id(char table_id);

314 9 set_table 0 4 456 36 AnimChannelMatrixXfmTable::set_table 0 1 92 255
/**
 * Assigns the indicated table.  table_id is one of 'i', 'j', 'k', for scale,
 * 'a', 'b', 'c' for shear, 'h', 'p', 'r', for rotation, and 'x', 'y', 'z',
 * for translation.  The new table must have either zero, one, or
 * get_num_frames() frames.
 */
85
void AnimChannelMatrixXfmTable::set_table(char table_id, CPTA_stdfloat const &table);

315 9 get_table 0 4 456 36 AnimChannelMatrixXfmTable::get_table 0 1 93 103
/**
 * Returns a pointer to the indicated subtable's data, if it exists, or NULL
 * if it does not.
 */
79
inline CPTA_stdfloat AnimChannelMatrixXfmTable::get_table(char table_id) const;

316 16 clear_all_tables 0 4 456 43 AnimChannelMatrixXfmTable::clear_all_tables 0 1 94 90
/**
 * Removes all the tables from the channel, and resets it to its initial
 * state.
 */
55
void AnimChannelMatrixXfmTable::clear_all_tables(void);

317 9 has_table 0 4 456 36 AnimChannelMatrixXfmTable::has_table 0 1 95 68
/**
 * Returns true if the indicated subtable has been assigned.
 */
70
inline bool AnimChannelMatrixXfmTable::has_table(char table_id) const;

318 11 clear_table 0 4 456 38 AnimChannelMatrixXfmTable::clear_table 0 1 96 59
/**
 * Removes the indicated table from the definition.
 */
66
inline void AnimChannelMatrixXfmTable::clear_table(char table_id);

319 14 get_class_type 0 4 456 41 AnimChannelMatrixXfmTable::get_class_type 0 1 97 0
66
static TypeHandle AnimChannelMatrixXfmTable::get_class_type(void);

320 9 set_value 0 4 457 35 AnimChannelScalarDynamic::set_value 0 1 98 37
/**
 * Explicitly sets the value.
 */
60
void AnimChannelScalarDynamic::set_value(PN_stdfloat value);

321 14 set_value_node 0 4 457 40 AnimChannelScalarDynamic::set_value_node 0 1 99 124
/**
 * Specifies a node whose transform will be queried each frame to implicitly
 * specify the transform of this joint.
 */
63
void AnimChannelScalarDynamic::set_value_node(PandaNode *node);

322 14 get_class_type 0 4 457 40 AnimChannelScalarDynamic::get_class_type 0 1 100 0
65
static TypeHandle AnimChannelScalarDynamic::get_class_type(void);

323 25 ~AnimChannelScalarDynamic 0 4 457 51 AnimChannelScalarDynamic::~AnimChannelScalarDynamic 0 0 0
58
AnimChannelScalarDynamic::~AnimChannelScalarDynamic(void);

324 9 set_table 0 4 458 33 AnimChannelScalarTable::set_table 0 1 101 34
/**
 * Assigns the data table.
 */
67
void AnimChannelScalarTable::set_table(CPTA_stdfloat const &table);

325 9 get_table 0 4 458 33 AnimChannelScalarTable::get_table 0 1 102 90
/**
 * Returns a pointer to the table's data, if it exists, or NULL if it does
 * not.
 */
67
inline CPTA_stdfloat AnimChannelScalarTable::get_table(void) const;

326 9 has_table 0 4 458 33 AnimChannelScalarTable::has_table 0 1 103 60
/**
 * Returns true if the data table has been assigned.
 */
58
inline bool AnimChannelScalarTable::has_table(void) const;

327 11 clear_table 0 4 458 35 AnimChannelScalarTable::clear_table 0 1 104 34
/**
 * Empties the data table.
 */
54
inline void AnimChannelScalarTable::clear_table(void);

328 14 get_class_type 0 4 458 38 AnimChannelScalarTable::get_class_type 0 1 105 0
63
static TypeHandle AnimChannelScalarTable::get_class_type(void);

329 23 ~AnimChannelScalarTable 0 4 458 47 AnimChannelScalarTable::~AnimChannelScalarTable 0 0 0
54
AnimChannelScalarTable::~AnimChannelScalarTable(void);

330 21 AnimControlCollection 0 4 459 44 AnimControlCollection::AnimControlCollection 0 2 106 107 117
/**
 * Returns the AnimControl associated with the given name, or NULL if no such
 * control has been associated.
 */
145
AnimControlCollection::AnimControlCollection(void);
inline AnimControlCollection::AnimControlCollection(AnimControlCollection const &) = default;

331 22 ~AnimControlCollection 0 4 459 45 AnimControlCollection::~AnimControlCollection 0 0 10
/**
 *
 */
52
AnimControlCollection::~AnimControlCollection(void);

332 10 store_anim 0 4 459 33 AnimControlCollection::store_anim 0 1 108 247
/**
 * Associates the given AnimControl with this collection under the given name.
 * The AnimControl will remain associated until a new AnimControl is
 * associated with the same name later, or until unbind_anim() is called with
 * this name.
 */
86
void AnimControlCollection::store_anim(AnimControl *control, std::string const &name);

333 9 find_anim 0 4 459 32 AnimControlCollection::find_anim 0 1 109 117
/**
 * Returns the AnimControl associated with the given name, or NULL if no such
 * control has been associated.
 */
77
AnimControl *AnimControlCollection::find_anim(std::string const &name) const;

334 11 unbind_anim 0 4 459 34 AnimControlCollection::unbind_anim 0 1 110 184
/**
 * Removes the AnimControl associated with the given name, if any.  Returns
 * true if an AnimControl was removed, false if there was no AnimControl with
 * the indicated name.
 */
65
bool AnimControlCollection::unbind_anim(std::string const &name);

335 13 get_num_anims 0 4 459 36 AnimControlCollection::get_num_anims 0 1 111 78
/**
 * Returns the number of AnimControls associated with this collection.
 */
53
int AnimControlCollection::get_num_anims(void) const;

336 8 get_anim 0 4 459 31 AnimControlCollection::get_anim 0 1 112 71
/**
 * Returns the nth AnimControl associated with this collection.
 */
58
AnimControl *AnimControlCollection::get_anim(int n) const;

337 13 get_anim_name 0 4 459 36 AnimControlCollection::get_anim_name 0 1 113 83
/**
 * Returns the name of the nth AnimControl associated with this collection.
 */
62
std::string AnimControlCollection::get_anim_name(int n) const;

338 11 clear_anims 0 4 459 34 AnimControlCollection::clear_anims 0 1 114 56
/**
 * Disassociates all anims from this collection.
 */
46
void AnimControlCollection::clear_anims(void);

339 4 play 0 4 459 27 AnimControlCollection::play 0 2 115 116 94
/**
 * Starts the named animation playing.
 */

/**
 * Starts the named animation playing.
 */
165
inline bool AnimControlCollection::play(std::string const &anim_name);
inline bool AnimControlCollection::play(std::string const &anim_name, double from, double to);

340 4 loop 0 4 459 27 AnimControlCollection::loop 0 2 117 118 94
/**
 * Starts the named animation looping.
 */

/**
 * Starts the named animation looping.
 */
193
inline bool AnimControlCollection::loop(std::string const &anim_name, bool restart);
inline bool AnimControlCollection::loop(std::string const &anim_name, bool restart, double from, double to);

341 4 stop 0 4 459 27 AnimControlCollection::stop 0 1 119 37
/**
 * Stops the named animation.
 */
70
inline bool AnimControlCollection::stop(std::string const &anim_name);

342 4 pose 0 4 459 27 AnimControlCollection::pose 0 1 120 61
/**
 * Sets to a particular frame in the named animation.
 */
84
inline bool AnimControlCollection::pose(std::string const &anim_name, double frame);

343 8 play_all 0 4 459 31 AnimControlCollection::play_all 0 2 121 122 134
// These functions operate on all anims at once.

/**
 * Starts all animations playing.
 */

/**
 * Starts all animations playing.
 */
105
void AnimControlCollection::play_all(void);
void AnimControlCollection::play_all(double from, double to);

344 8 loop_all 0 4 459 31 AnimControlCollection::loop_all 0 2 123 124 84
/**
 * Starts all animations looping.
 */

/**
 * Starts all animations looping.
 */
127
void AnimControlCollection::loop_all(bool restart);
void AnimControlCollection::loop_all(bool restart, double from, double to);

345 8 stop_all 0 4 459 31 AnimControlCollection::stop_all 0 1 125 127
/**
 * Stops all currently playing animations.  Returns true if any animations
 * were stopped, false if none were playing.
 */
43
bool AnimControlCollection::stop_all(void);

346 8 pose_all 0 4 459 31 AnimControlCollection::pose_all 0 1 126 54
/**
 * Sets all animations to the indicated frame.
 */
51
void AnimControlCollection::pose_all(double frame);

347 9 get_frame 0 4 459 32 AnimControlCollection::get_frame 0 2 127 128 168
/**
 * Returns the current frame in the named animation, or 0 if the animation is
 * not found.
 */

/**
 * Returns the current frame in the last-started animation.
 */
137
inline int AnimControlCollection::get_frame(std::string const &anim_name) const;
inline int AnimControlCollection::get_frame(void) const;

348 14 get_num_frames 0 4 459 37 AnimControlCollection::get_num_frames 0 2 129 130 186
/**
 * Returns the total number of frames in the named animation, or 0 if the
 * animation is not found.
 */

/**
 * Returns the total number of frames in the last-started animation.
 */
147
inline int AnimControlCollection::get_num_frames(std::string const &anim_name) const;
inline int AnimControlCollection::get_num_frames(void) const;

349 10 is_playing 0 4 459 33 AnimControlCollection::is_playing 0 2 131 132 182
/**
 * Returns true if the named animation is currently playing, false otherwise.
 */

/**
 * Returns true if the last-started animation is currently playing, false
 * otherwise.
 */
141
inline bool AnimControlCollection::is_playing(std::string const &anim_name) const;
inline bool AnimControlCollection::is_playing(void) const;

350 18 which_anim_playing 0 4 459 41 AnimControlCollection::which_anim_playing 0 1 133 183
/**
 * Returns the name of the bound AnimControl currently playing, if any.  If
 * more than one AnimControl is currently playing, returns all of the names
 * separated by spaces.
 */
66
std::string AnimControlCollection::which_anim_playing(void) const;

351 6 output 0 4 459 29 AnimControlCollection::output 0 1 134 10
/**
 *
 */
55
void AnimControlCollection::output(ostream &out) const;

352 5 write 0 4 459 28 AnimControlCollection::write 0 1 135 10
/**
 *
 */
54
void AnimControlCollection::write(ostream &out) const;

353 16 AnimPreloadTable 0 4 460 34 AnimPreloadTable::AnimPreloadTable 0 1 136 10
/**
 *
 */
41
AnimPreloadTable::AnimPreloadTable(void);

354 13 get_num_anims 0 4 460 31 AnimPreloadTable::get_num_anims 0 1 137 64
/**
 * Returns the number of animation records in the table.
 */
48
int AnimPreloadTable::get_num_anims(void) const;

355 9 find_anim 0 4 460 27 AnimPreloadTable::find_anim 0 1 138 321
/**
 * Returns the index number in the table of the animation record with the
 * indicated name, or -1 if the name is not present.  By convention, the
 * basename is the filename of the egg or bam file, without the directory part
 * and without the extension.  That is, it is
 * Filename::get_basename_wo_extension().
 */
67
int AnimPreloadTable::find_anim(std::string const &basename) const;

356 12 get_basename 0 4 460 30 AnimPreloadTable::get_basename 0 1 139 86
/**
 * Returns the basename stored for the nth animation record.  See find_anim().
 */
63
inline std::string AnimPreloadTable::get_basename(int n) const;

357 19 get_base_frame_rate 0 4 460 37 AnimPreloadTable::get_base_frame_rate 0 1 140 70
/**
 * Returns the frame rate stored for the nth animation record.
 */
70
inline PN_stdfloat AnimPreloadTable::get_base_frame_rate(int n) const;

358 14 get_num_frames 0 4 460 32 AnimPreloadTable::get_num_frames 0 1 141 76
/**
 * Returns the number of frames stored for the nth animation record.
 */
57
inline int AnimPreloadTable::get_num_frames(int n) const;

359 11 clear_anims 0 4 460 29 AnimPreloadTable::clear_anims 0 1 142 56
/**
 * Removes all animation records from the table.
 */
41
void AnimPreloadTable::clear_anims(void);

360 11 remove_anim 0 4 460 29 AnimPreloadTable::remove_anim 0 1 143 113
/**
 * Removes the nth animation records from the table.  This renumbers indexes
 * for following animations.
 */
42
void AnimPreloadTable::remove_anim(int n);

361 8 add_anim 0 4 460 26 AnimPreloadTable::add_anim 0 1 144 227
/**
 * Adds a new animation record to the table.  If there is already a record of
 * this name, no operation is performed (the original record is unchanged).
 * See find_anim().  This will invalidate existing index numbers.
 */
106
void AnimPreloadTable::add_anim(std::string const &basename, PN_stdfloat base_frame_rate, int num_frames);

362 14 add_anims_from 0 4 460 32 AnimPreloadTable::add_anims_from 0 1 145 160
/**
 * Copies the animation records from the other table into this one.  If a
 * given record name exists in both tables, the record in this one supercedes.
 */
69
void AnimPreloadTable::add_anims_from(AnimPreloadTable const *other);

363 6 output 0 6 460 24 AnimPreloadTable::output 0 1 146 10
/**
 *
 */
58
virtual void AnimPreloadTable::output(ostream &out) const;

364 5 write 0 6 460 23 AnimPreloadTable::write 0 1 147 10
/**
 *
 */
75
virtual void AnimPreloadTable::write(ostream &out, int indent_level) const;

365 14 get_class_type 0 4 460 32 AnimPreloadTable::get_class_type 0 1 148 0
57
static TypeHandle AnimPreloadTable::get_class_type(void);

366 9 auto_bind 0 1 0 9 auto_bind 0 1 216 0
101
void auto_bind(PandaNode *root_node, AnimControlCollection &controls, int hierarchy_match_flags = 0);

367 10 PartSubset 0 4 462 22 PartSubset::PartSubset 0 2 149 150 22
/**
 *
 */

/**
 *
 */
77
PartSubset::PartSubset(void);
PartSubset::PartSubset(PartSubset const &copy);

368 10 operator = 0 4 462 22 PartSubset::operator = 0 1 151 0
52
void PartSubset::operator =(PartSubset const &copy);

369 17 add_include_joint 0 4 462 29 PartSubset::add_include_joint 0 1 152 342
/**
 * Adds the named joint to the list of joints that will be explicitly included
 * in the subset.  Any joint at or below a named node will be included in the
 * subset (unless a lower node is also listed in the exclude list).
 *
 * Since the name is a GlobPattern, it may of course include filename globbing
 * characters like * and ?.
 */
60
void PartSubset::add_include_joint(GlobPattern const &name);

370 17 add_exclude_joint 0 4 462 29 PartSubset::add_exclude_joint 0 1 153 352
/**
 * Adds the named joint to the list of joints that will be explicitly
 * exlcluded from the subset.  Any joint at or below a named node will not be
 * included in the subset (unless a lower node is also listed in the include
 * list).
 *
 * Since the name is a GlobPattern, it may of course include filename globbing
 * characters like * and ?.
 */
60
void PartSubset::add_exclude_joint(GlobPattern const &name);

371 6 append 0 4 462 18 PartSubset::append 0 1 154 98
/**
 * Appends the include and exclude list from the other object onto this
 * object's lists.
 */
49
void PartSubset::append(PartSubset const &other);

372 6 output 0 4 462 18 PartSubset::output 0 1 155 10
/**
 *
 */
44
void PartSubset::output(ostream &out) const;

373 16 is_include_empty 0 4 462 28 PartSubset::is_include_empty 0 1 156 147
/**
 * Returns true if the include list is completely empty, false otherwise.  If
 * it is empty, it is the same thing as including all joints.
 */
46
bool PartSubset::is_include_empty(void) const;

374 15 matches_include 0 4 462 27 PartSubset::matches_include 0 1 157 101
/**
 * Returns true if the indicated name matches a name on the include list,
 * false otherwise.
 */
70
bool PartSubset::matches_include(std::string const &joint_name) const;

375 15 matches_exclude 0 4 462 27 PartSubset::matches_exclude 0 1 158 101
/**
 * Returns true if the indicated name matches a name on the exclude list,
 * false otherwise.
 */
70
bool PartSubset::matches_exclude(std::string const &joint_name) const;

376 11 ~PartSubset 0 4 462 23 PartSubset::~PartSubset 0 0 0
30
PartSubset::~PartSubset(void);

377 15 BindAnimRequest 0 4 463 32 BindAnimRequest::BindAnimRequest 0 2 159 160 10
/**
 *
 */
281
BindAnimRequest::BindAnimRequest(std::string const &name, Filename const &filename, LoaderOptions const &options, Loader *loader, AnimControl *control, int hierarchy_match_flags, PartSubset const &subset);
inline BindAnimRequest::BindAnimRequest(BindAnimRequest const &) = default;

378 14 get_class_type 0 4 463 31 BindAnimRequest::get_class_type 0 1 161 0
56
static TypeHandle BindAnimRequest::get_class_type(void);

379 16 ~BindAnimRequest 0 4 463 33 BindAnimRequest::~BindAnimRequest 0 0 0
40
BindAnimRequest::~BindAnimRequest(void);

380 10 PartBundle 0 4 465 22 PartBundle::PartBundle 0 1 162 220
/**
 * Normally, you'd use make_copy() or copy_subgraph() to make a copy of this.
 */

/**
 * Normally, a PartBundle constructor should not be called directly--it will
 * get created when a PartBundleNode is created.
 */
53
PartBundle::PartBundle(std::string const &name = "");

381 16 get_anim_preload 0 4 465 28 PartBundle::get_anim_preload 0 1 163 181
/**
 * Returns the AnimPreloadTable associated with the PartBundle.  This table,
 * if present, can be used for the benefit of load_bind_anim() to allow
 * asynchronous binding.
 */
83
inline ConstPointerTo< AnimPreloadTable > PartBundle::get_anim_preload(void) const;

382 19 modify_anim_preload 0 4 465 31 PartBundle::modify_anim_preload 0 1 164 106
/**
 * Returns a modifiable pointer to the AnimPreloadTable associated with the
 * PartBundle, if any.
 */
75
inline PointerTo< AnimPreloadTable > PartBundle::modify_anim_preload(void);

383 16 set_anim_preload 0 4 465 28 PartBundle::set_anim_preload 0 1 165 72
/**
 * Replaces the AnimPreloadTable associated with the PartBundle.
 */
66
inline void PartBundle::set_anim_preload(AnimPreloadTable *table);

384 18 clear_anim_preload 0 4 465 30 PartBundle::clear_anim_preload 0 1 166 71
/**
 * Removes any AnimPreloadTable associated with the PartBundle.
 */
49
inline void PartBundle::clear_anim_preload(void);

385 19 merge_anim_preloads 0 4 465 31 PartBundle::merge_anim_preloads 0 1 167 85
/**
 * Copies the contents of the other PartBundle's preload table into this one.
 */
62
void PartBundle::merge_anim_preloads(PartBundle const *other);

386 14 set_blend_type 0 4 465 26 PartBundle::set_blend_type 0 1 168 270
/**
 * Defines the algorithm that is used when blending multiple frames or
 * multiple animations together, when either anim_blend_flag or
 * frame_blend_flag is set to true.
 *
 * See partBundle.h for a description of the meaning of each of the BlendType
 * values.
 */
65
inline void PartBundle::set_blend_type(PartBundle::BlendType bt);

387 14 get_blend_type 0 4 465 26 PartBundle::get_blend_type 0 1 169 178
/**
 * Returns the algorithm that is used when blending multiple frames or
 * multiple animations together, when either anim_blend_flag or
 * frame_blend_flag is set to true.
 */
68
inline PartBundle::BlendType PartBundle::get_blend_type(void) const;

388 19 set_anim_blend_flag 0 4 465 31 PartBundle::set_anim_blend_flag 0 1 170 581
/**
 * Defines the way the character responds to multiple calls to
 * set_control_effect()).  By default, this flag is set false, which disallows
 * multiple animations.  When this flag is false, it is not necessary to
 * explicitly set the control_effect when starting an animation; starting the
 * animation will implicitly remove the control_effect from the previous
 * animation and set it on the current one.
 *
 * However, if this flag is set true, the control_effect must be explicitly
 * set via set_control_effect() whenever an animation is to affect the
 * character.
 */
59
void PartBundle::set_anim_blend_flag(bool anim_blend_flag);

389 19 get_anim_blend_flag 0 4 465 31 PartBundle::get_anim_blend_flag 0 1 171 136
/**
 * Returns whether the character allows multiple different animations to be
 * bound simultaneously.  See set_anim_blend_flag().
 */
56
inline bool PartBundle::get_anim_blend_flag(void) const;

390 20 set_frame_blend_flag 0 4 465 32 PartBundle::set_frame_blend_flag 0 1 172 775
/**
 * Specifies whether the character interpolates (blends) between two
 * sequential frames of an active animation, showing a smooth intra-frame
 * motion, or whether it holds each frame until the next frame is ready,
 * showing precisely the specified animation.
 *
 * When this value is false, the character holds each frame until the next is
 * ready.  When this is true, the character will interpolate between two
 * consecutive frames of animation for each frame the animation is onscreen,
 * according to the amount of time elapsed between the frames.
 *
 * The default value of this flag is determined by the interpolate-frames
 * Config.prc variable.
 *
 * Use set_blend_type() to change the algorithm that the character uses to
 * interpolate matrix positions.
 */
68
inline void PartBundle::set_frame_blend_flag(bool frame_blend_flag);

391 20 get_frame_blend_flag 0 4 465 32 PartBundle::get_frame_blend_flag 0 1 173 205
/**
 * Returns whether the character interpolates (blends) between two sequential
 * animation frames, or whether it holds the current frame until the next one
 * is ready.  See set_frame_blend_flag().
 */
57
inline bool PartBundle::get_frame_blend_flag(void) const;

392 14 set_root_xform 0 4 465 26 PartBundle::set_root_xform 0 1 174 111
/**
 * Specifies the transform matrix which is implicitly applied at the root of
 * the animated hierarchy.
 */
67
inline void PartBundle::set_root_xform(LMatrix4 const &root_xform);

393 5 xform 0 4 465 17 PartBundle::xform 0 1 175 81
/**
 * Applies the indicated transform to the root of the animated hierarchy.
 */
51
inline void PartBundle::xform(LMatrix4 const &mat);

394 14 get_root_xform 0 4 465 26 PartBundle::get_root_xform 0 1 176 109
/**
 * Returns the transform matrix which is implicitly applied at the root of the
 * animated hierarchy.
 */
62
inline LMatrix4 const &PartBundle::get_root_xform(void) const;

395 15 apply_transform 0 4 465 27 PartBundle::apply_transform 0 1 177 226
/**
 * Returns a PartBundle that is a duplicate of this one, but with the
 * indicated transform applied.  If this is called multiple times with the
 * same TransformState pointer, it returns the same PartBundle each time.
 */
85
PointerTo< PartBundle > PartBundle::apply_transform(TransformState const *transform);

396 13 get_num_nodes 0 4 465 25 PartBundle::get_num_nodes 0 1 178 94
/**
 * Returns the number of PartBundleNodes that contain a pointer to this
 * PartBundle.
 */
49
inline int PartBundle::get_num_nodes(void) const;

397 8 get_node 0 4 465 20 PartBundle::get_node 0 1 179 74
/**
 * Returns the nth PartBundleNode associated with this PartBundle.
 */
57
inline PartBundleNode *PartBundle::get_node(int n) const;

398 14 PartBundleNode 0 4 470 30 PartBundleNode::PartBundleNode 0 1 195 388
/**
 * The PartBundle and its node should be constructed together.  Generally, the
 * derived classes of PartBundleNode will automatically create a PartBundle of
 * the appropriate type, and pass it up to this constructor.
 */

/**
 * For internal use only.
 */

/**
 * Use make_copy() or copy_subgraph() to copy one of these.
 *
 * This constructor does not copy the bundle pointers.
 */
83
inline PartBundleNode::PartBundleNode(std::string const &name, PartBundle *bundle);

399 15 get_num_bundles 0 4 470 31 PartBundleNode::get_num_bundles 0 1 196 10
/**
 *
 */
55
inline int PartBundleNode::get_num_bundles(void) const;

400 10 get_bundle 0 4 470 26 PartBundleNode::get_bundle 0 1 197 10
/**
 *
 */
59
inline PartBundle *PartBundleNode::get_bundle(int n) const;

401 17 get_bundle_handle 0 4 470 33 PartBundleNode::get_bundle_handle 0 1 198 204
/**
 * Returns the PartBundleHandle that wraps around the actual nth PartBundle.
 * While the PartBundle pointer might later change due to a future flatten
 * operation, the PartBundleHandle will not.
 */
72
inline PartBundleHandle *PartBundleNode::get_bundle_handle(int n) const;

402 16 PartBundleHandle 0 4 473 34 PartBundleHandle::PartBundleHandle 0 2 200 201 10
/**
 *
 */
141
inline PartBundleHandle::PartBundleHandle(PartBundle *bundle);
inline PartBundleHandle::PartBundleHandle(PartBundleHandle const &) = default;

403 10 get_bundle 0 4 473 28 PartBundleHandle::get_bundle 0 1 202 68
/**
 * Returns the actual PartBundle embedded within the handle.
 */
54
inline PartBundle *PartBundleHandle::get_bundle(void);

404 10 set_bundle 0 4 473 28 PartBundleHandle::set_bundle 0 1 203 68
/**
 * Changes the actual PartBundle embedded within the handle.
 */
61
inline void PartBundleHandle::set_bundle(PartBundle *bundle);

405 14 get_class_type 0 4 470 30 PartBundleNode::get_class_type 0 1 199 0
55
static TypeHandle PartBundleNode::get_class_type(void);

406 21 clear_control_effects 0 4 465 33 PartBundle::clear_control_effects 0 1 180 518
/**
 * Sets the control effect of all AnimControls to zero (but does not "stop"
 * the AnimControls).  The character will no longer be affected by any
 * animation, and will return to its default pose (unless restore-initial-pose
 * is false).
 *
 * The AnimControls which are no longer associated will not be using any CPU
 * cycles, but they may still be in the "playing" state; if they are later
 * reassociated with the PartBundle they will resume at their current frame as
 * if they'd been running all along.
 */
45
void PartBundle::clear_control_effects(void);

407 18 set_control_effect 0 4 465 30 PartBundle::set_control_effect 0 1 181 530
/**
 * Sets the amount by which the character is affected by the indicated
 * AnimControl (and its associated animation).  Normally, this will only be
 * zero or one.  Zero indicates the animation does not affect the character,
 * and one means it does.
 *
 * If the _anim_blend_flag is not false (see set_anim_blend_flag()), it is
 * possible to have multiple AnimControls in effect simultaneously.  In this
 * case, the effect is a weight that indicates the relative importance of each
 * AnimControl to the final animation.
 */
85
inline void PartBundle::set_control_effect(AnimControl *control, PN_stdfloat effect);

408 18 get_control_effect 0 4 465 30 PartBundle::get_control_effect 0 1 182 153
/**
 * Returns the amount by which the character is affected by the indicated
 * AnimControl and its associated animation.  See set_control_effect().
 */
78
inline PN_stdfloat PartBundle::get_control_effect(AnimControl *control) const;

409 6 output 0 6 465 18 PartBundle::output 0 1 183 55
/**
 * Writes a one-line description of the bundle.
 */
52
virtual void PartBundle::output(ostream &out) const;

410 9 bind_anim 0 4 465 21 PartBundle::bind_anim 0 1 184 790
/**
 * Binds the animation to the bundle, if possible, and returns a new
 * AnimControl that can be used to start and stop the animation.  If the anim
 * hierarchy does not match the part hierarchy, returns NULL.
 *
 * If hierarchy_match_flags is 0, only an exact match is accepted; otherwise,
 * it may contain a union of PartGroup::HierarchyMatchFlags values indicating
 * conditions that will be tolerated (but warnings will still be issued).
 *
 * If subset is specified, it restricts the binding only to the named subtree
 * of joints.
 *
 * The AnimControl is not stored within the PartBundle; it is the user's
 * responsibility to maintain the pointer.  The animation will automatically
 * unbind itself when the AnimControl destructs (i.e.  its reference count
 * goes to zero).
 */
137
PointerTo< AnimControl > PartBundle::bind_anim(AnimBundle *anim, int hierarchy_match_flags = 0, PartSubset const &subset = PartSubset());

411 14 load_bind_anim 0 4 465 26 PartBundle::load_bind_anim 0 1 185 1088
/**
 * Binds an animation to the bundle.  The animation is loaded from the disk
 * via the indicated Loader object.  In other respects, this behaves similarly
 * to bind_anim(), with the addition of asynchronous support.
 *
 * If allow_aysnc is true, the load will be asynchronous if possible.  This
 * requires that the animation basename can be found in the PartBundle's
 * preload table (see get_anim_preload()).
 *
 * In an asynchronous load, the animation file will be loaded and bound in a
 * sub-thread.  This means that the animation will not necessarily be
 * available at the time this method returns.  You may still use the returned
 * AnimControl immediately, though, but no visible effect will occur until the
 * animation eventually becomes available.
 *
 * You can test AnimControl::is_pending() to see if the animation has been
 * loaded yet, or wait for it to finish with AnimControl::wait_pending() or
 * even PartBundle::wait_pending().  You can also set an event to be triggered
 * when the animation finishes loading with
 * AnimControl::set_pending_done_event().
 */
165
PointerTo< AnimControl > PartBundle::load_bind_anim(Loader *loader, Filename const &filename, int hierarchy_match_flags, PartSubset const &subset, bool allow_async);

412 12 wait_pending 0 4 465 24 PartBundle::wait_pending 0 1 186 153
/**
 * Blocks the current thread until all currently-pending AnimControls, with a
 * nonzero control effect, have been loaded and are properly bound.
 */
36
void PartBundle::wait_pending(void);

413 12 freeze_joint 0 4 465 24 PartBundle::freeze_joint 0 3 187 188 189 1123
/**
 * Specifies that the joint with the indicated name should be frozen with the
 * specified transform.  It will henceforth always hold this fixed transform,
 * regardless of any animations that may subsequently be bound to the joint.
 *
 * Returns true if the joint is successfully frozen, or false if the named
 * child is not a joint (or slider) or does not exist.
 */

/**
 * Specifies that the joint with the indicated name should be frozen with the
 * specified transform.  It will henceforth always hold this fixed transform,
 * regardless of any animations that may subsequently be bound to the joint.
 *
 * Returns true if the joint is successfully frozen, or false if the named
 * child is not a joint (or slider) or does not exist.
 */

/**
 * Specifies that the joint with the indicated name should be frozen with the
 * specified transform.  It will henceforth always hold this fixed transform,
 * regardless of any animations that may subsequently be bound to the joint.
 *
 * Returns true if the joint is successfully frozen, or false if the named
 * child is not a joint (or slider) or does not exist.
 */
305
bool PartBundle::freeze_joint(std::string const &joint_name, TransformState const *transform);
bool PartBundle::freeze_joint(std::string const &joint_name, LVecBase3 const &pos, LVecBase3 const &hpr, LVecBase3 const &scale);
bool PartBundle::freeze_joint(std::string const &joint_name, PN_stdfloat value);

414 13 control_joint 0 4 465 25 PartBundle::control_joint 0 1 190 396
/**
 * Specifies that the joint with the indicated name should be animated with
 * the transform on the indicated node.  It will henceforth always follow the
 * node's transform, regardless of any animations that may subsequently be
 * bound to the joint.
 *
 * Returns true if the joint is successfully controlled, or false if the named
 * child is not a joint (or slider) or does not exist.
 */
79
bool PartBundle::control_joint(std::string const &joint_name, PandaNode *node);

415 13 release_joint 0 4 465 25 PartBundle::release_joint 0 1 191 342
/**
 * Releases the named joint from the effects of a previous call to
 * freeze_joint() or control_joint(). It will henceforth once again follow
 * whatever transforms are dictated by the animation.
 *
 * Returns true if the joint is released, or false if the named child was not
 * previously controlled or frozen, or it does not exist.
 */
62
bool PartBundle::release_joint(std::string const &joint_name);

416 6 update 0 4 465 18 PartBundle::update 0 1 192 216
/**
 * Updates all the parts in the bundle to reflect the data for the current
 * frame (as set in each of the AnimControls).
 *
 * Returns true if any part has changed as a result of this, or false
 * otherwise.
 */
30
bool PartBundle::update(void);

417 12 force_update 0 4 465 24 PartBundle::force_update 0 1 193 131
/**
 * Updates all the parts in the bundle to reflect the data for the current
 * frame, whether we believe it needs it or not.
 */
36
bool PartBundle::force_update(void);

418 14 get_class_type 0 4 465 26 PartBundle::get_class_type 0 1 194 0
51
static TypeHandle PartBundle::get_class_type(void);

419 11 ~PartBundle 0 4 465 23 PartBundle::~PartBundle 0 0 0
30
PartBundle::~PartBundle(void);

420 13 get_max_bound 0 4 475 29 MovingPartBase::get_max_bound 0 1 204 310
/**
 * Returns the number of channels that might be bound to this PartGroup.  This
 * might not be the actual number of channels, since there might be holes in
 * the list; it is one more than the index number of the highest bound
 * channel.  Thus, it is called get_max_bound() instead of get_num_bound().
 */
53
inline int MovingPartBase::get_max_bound(void) const;

421 9 get_bound 0 4 475 25 MovingPartBase::get_bound 0 1 205 371
/**
 * Returns the nth bound channel on this PartGroup.  n can be determined by
 * iterating from 0 to one less than get_max_bound(); or n might be
 * AnimControl::get_channel_index().
 *
 * This will return NULL if there is no channel bound on the indicated index.
 * It is an error to call this if n is less than zero or greater than or equal
 * to get_max_bound().
 */
63
inline AnimChannelBase *MovingPartBase::get_bound(int n) const;

422 12 output_value 0 6 475 28 MovingPartBase::output_value 0 1 206 0
66
virtual void MovingPartBase::output_value(ostream &out) const = 0;

423 14 get_class_type 0 4 475 30 MovingPartBase::get_class_type 0 1 207 0
55
static TypeHandle MovingPartBase::get_class_type(void);

424 15 ~MovingPartBase 0 4 475 31 MovingPartBase::~MovingPartBase 0 0 0
38
MovingPartBase::~MovingPartBase(void);

425 14 get_class_type 0 4 477 48 MovingPart< ACMatrixSwitchType >::get_class_type 0 1 209 0
73
static TypeHandle MovingPart< ACMatrixSwitchType >::get_class_type(void);

426 9 get_value 0 4 477 43 MovingPart< ACMatrixSwitchType >::get_value 0 1 210 0
72
inline LMatrix4 MovingPart< ACMatrixSwitchType >::get_value(void) const;

427 17 get_default_value 0 4 477 51 MovingPart< ACMatrixSwitchType >::get_default_value 0 1 211 0
80
inline LMatrix4 MovingPart< ACMatrixSwitchType >::get_default_value(void) const;

428 11 ~MovingPart 0 4 477 45 MovingPart< ACMatrixSwitchType >::~MovingPart 0 0 0
52
MovingPart< ACMatrixSwitchType >::~MovingPart(void);

429 14 get_class_type 0 4 476 32 MovingPartMatrix::get_class_type 0 1 208 0
57
static TypeHandle MovingPartMatrix::get_class_type(void);

430 14 get_class_type 0 4 479 48 MovingPart< ACScalarSwitchType >::get_class_type 0 1 213 0
73
static TypeHandle MovingPart< ACScalarSwitchType >::get_class_type(void);

431 9 get_value 0 4 479 43 MovingPart< ACScalarSwitchType >::get_value 0 1 214 0
75
inline PN_stdfloat MovingPart< ACScalarSwitchType >::get_value(void) const;

432 17 get_default_value 0 4 479 51 MovingPart< ACScalarSwitchType >::get_default_value 0 1 215 0
83
inline PN_stdfloat MovingPart< ACScalarSwitchType >::get_default_value(void) const;

433 11 ~MovingPart 0 4 479 45 MovingPart< ACScalarSwitchType >::~MovingPart 0 0 0
52
MovingPart< ACScalarSwitchType >::~MovingPart(void);

434 14 get_class_type 0 4 478 32 MovingPartScalar::get_class_type 0 1 212 0
57
static TypeHandle MovingPartScalar::get_class_type(void);

216
1 0 0 7 8 438 222 0 148 /**
 * Creates the AnimGroup, and adds it to the indicated parent.  The only way
 * to delete it subsequently is to delete the entire hierarchy.
 */ 2 6 parent 1 438  4 name 1 480  
2 0 0 7 8 438 222 0 0 1 6 param0 0 481  
3 0 0 6 10 483 0 0 58 /**
 * Returns the number of child nodes of the group.
 */ 1 4 this 3 481  
4 0 0 7 11 438 222 0 46 /**
 * Returns the nth child of the group.
 */ 2 4 this 3 481  1 n 1 483  
5 0 0 7 15 438 222 0 250 /**
 * Returns the first child found with the indicated name, or NULL if no such
 * child exists.  This method searches only the children of this particular
 * AnimGroup; it does not recursively search the entire graph.  See also
 * find_child().
 */ 2 4 this 3 481  4 name 1 480  
6 0 0 7 16 438 222 0 210 /**
 * Returns the first descendant found with the indicated name, or NULL if no
 * such descendant exists.  This method searches the entire graph beginning at
 * this AnimGroup; see also get_child_named().
 */ 2 4 this 3 481  4 name 1 480  
7 0 0 4 17 484 0 0 262 /**
 * Sorts the children nodes at each level of the hierarchy into alphabetical
 * order.  This should be done after creating the hierarchy, to guarantee that
 * the correct names will match up together when the AnimBundle is later bound
 * to a PlayerRoot.
 */ 1 4 this 3 438  
8 0 0 4 18 484 0 0 54 /**
 * Writes a one-line description of the group.
 */ 2 4 this 3 481  3 out 1 485  
9 0 0 4 19 484 0 0 78 /**
 * Writes a brief description of the group and all of its descendants.
 */ 3 4 this 3 481  3 out 1 485  12 indent_level 1 483  
10 0 0 7 20 488 0 0 0 0 
11 0 0 7 3 489 0 0 0 1 4 this 3 438  
12 0 0 7 4 438 222 0 0 1 4 this 3 489  
13 0 0 6 6 490 0 0 0 1 4 this 3 438  
14 0 0 7 7 438 222 0 0 1 4 this 3 490  
15 0 0 7 22 493 236 0 0 1 6 param0 0 491  
16 0 0 7 22 493 236 0 10 /**
 *
 */ 3 4 name 1 480  3 fps 1 494  10 num_frames 1 483  
17 0 0 7 23 493 236 0 236 /**
 * Returns a full copy of the bundle and its entire tree of nested AnimGroups.
 * However, the actual data stored in the leaves--that is, animation tables,
 * such as those stored in an AnimChannelMatrixXfmTable--will be shared.
 */ 1 4 this 3 491  
18 0 0 6 24 496 0 0 307 /**
 * Returns the ideal number of frames per second of the animation, when it is
 * running at normal speed.  This may not be the same as the actual playing
 * frame rate, as it might have been adjusted through set_play_rate() on the
 * AnimControl object.  See AnimControl::get_effective_frame_rate().
 */ 1 4 this 3 491  
19 0 0 6 25 483 0 0 109 /**
 * Returns the number of frames of animation, or 0 if the animation has no
 * fixed number of frames.
 */ 1 4 this 3 491  
20 0 0 7 26 488 0 0 0 0 
21 0 0 7 30 497 241 0 226 /**
 * The AnimBundle and its node should be constructed together.  Generally, the
 * derived classes of AnimBundleNode will automatically create a AnimBundle of
 * the appropriate type, and pass it up to this constructor.
 */ 2 4 name 1 480  6 bundle 1 493  
22 0 0 7 31 493 236 0 10 /**
 *
 */ 1 4 this 3 498  
23 0 0 7 32 493 236 0 205 /**
 * Recursively walks the scene graph beginning at the indicated node (which
 * need not be an AnimBundleNode), and returns the first AnimBundle found.
 * Returns NULL if no AnimBundle can be found.
 */ 1 4 root 1 500  
24 0 0 7 33 488 0 0 0 0 
25 0 0 7 41 444 247 0 148 /**
 * Creates the PartGroup, and adds it to the indicated parent.  The only way
 * to delete it subsequently is to delete the entire hierarchy.
 */ 2 6 parent 1 444  4 name 1 480  
26 0 0 6 43 467 0 0 156 /**
 * Returns true if this part is a CharacterJoint, false otherwise.  This is a
 * tiny optimization over is_of_type(CharacterType::get_class_type()).
 */ 1 4 this 3 501  
27 0 0 7 44 444 247 0 110 /**
 * Allocates and returns a new copy of the node.  Children are not copied, but
 * see copy_subgraph().
 */ 1 4 this 3 501  
28 0 0 7 45 444 247 0 84 /**
 * Allocates and returns a new copy of this node and of all of its children.
 */ 1 4 this 3 501  
29 0 0 6 46 483 0 0 58 /**
 * Returns the number of child nodes of the group.
 */ 1 4 this 3 501  
30 0 0 7 47 444 247 0 46 /**
 * Returns the nth child of the group.
 */ 2 4 this 3 501  1 n 1 483  
31 0 0 7 51 444 247 0 250 /**
 * Returns the first child found with the indicated name, or NULL if no such
 * child exists.  This method searches only the children of this particular
 * PartGroup; it does not recursively search the entire graph.  See also
 * find_child().
 */ 2 4 this 3 501  4 name 1 480  
32 0 0 7 52 444 247 0 210 /**
 * Returns the first descendant found with the indicated name, or NULL if no
 * such descendant exists.  This method searches the entire graph beginning at
 * this PartGroup; see also get_child_named().
 */ 2 4 this 3 501  4 name 1 480  
33 0 0 4 53 484 0 0 262 /**
 * Sorts the children nodes at each level of the hierarchy into alphabetical
 * order.  This should be done after creating the hierarchy, to guarantee that
 * the correct names will match up together when the AnimBundle is later bound
 * to a PlayerRoot.
 */ 1 4 this 3 444  
34 0 0 6 54 467 0 0 287 /**
 * Freezes this particular joint so that it will always hold the specified
 * transform.  Returns true if this is a joint that can be so frozen, false
 * otherwise.
 *
 * This is normally only called internally by PartBundle::freeze_joint(), but
 * you may also call it directly.
 */ 2 4 this 3 444  9 transform 1 503  
35 0 0 6 55 467 0 0 287 /**
 * Freezes this particular joint so that it will always hold the specified
 * transform.  Returns true if this is a joint that can be so frozen, false
 * otherwise.
 *
 * This is normally only called internally by PartBundle::freeze_joint(), but
 * you may also call it directly.
 */ 4 4 this 3 444  3 pos 1 506  3 hpr 1 506  5 scale 1 506  
36 0 0 6 56 467 0 0 287 /**
 * Freezes this particular joint so that it will always hold the specified
 * transform.  Returns true if this is a joint that can be so frozen, false
 * otherwise.
 *
 * This is normally only called internally by PartBundle::freeze_joint(), but
 * you may also call it directly.
 */ 2 4 this 3 444  5 value 1 494  
37 0 0 6 57 467 0 0 311 /**
 * Specifies a node to influence this particular joint so that it will always
 * hold the node's transform.  Returns true if this is a joint that can be so
 * controlled, false otherwise.
 *
 * This is normally only called internally by PartBundle::control_joint(), but
 * you may also call it directly.
 */ 2 4 this 3 444  4 node 1 500  
38 0 0 6 58 467 0 0 261 /**
 * Undoes the effect of a previous call to apply_freeze() or apply_control().
 * Returns true if the joint was modified, false otherwise.
 *
 * This is normally only called internally by PartBundle::release_joint(), but
 * you may also call it directly.
 */ 1 4 this 3 444  
39 0 0 7 59 510 287 0 181 /**
 * Returns the AnimChannelBase that has been forced to this joint by a
 * previous call to apply_freeze() or apply_control(), or NULL if no such
 * channel has been applied.
 */ 1 4 this 3 501  
40 0 0 4 60 484 0 0 78 /**
 * Writes a brief description of the group and all of its descendants.
 */ 3 4 this 3 501  3 out 1 485  12 indent_level 1 483  
41 0 0 4 61 484 0 0 117 /**
 * Writes a brief description of the group, showing its current value, and
 * that of all of its descendants.
 */ 3 4 this 3 501  3 out 1 485  12 indent_level 1 483  
42 0 0 7 62 488 0 0 0 0 
43 0 0 7 36 489 0 0 0 1 4 this 3 444  
44 0 0 7 37 444 247 0 0 1 4 this 3 489  
45 0 0 6 38 490 0 0 0 1 4 this 3 444  
46 0 0 7 39 444 247 0 0 1 4 this 3 490  
47 0 0 6 73 467 0 0 286 /**
 * Returns true if the AnimControl is being bound asynchronously, and has not
 * yet finished.  If this is true, the AnimControl's interface is still
 * available and will be perfectly useful (though get_anim() might return
 * NULL), but nothing visible will happen immediately.
 */ 1 4 this 3 511  
48 0 0 4 74 484 0 0 102 /**
 * Blocks the current thread until the AnimControl has finished loading and is
 * fully bound.
 */ 1 4 this 3 513  
49 0 0 6 75 467 0 0 154 /**
 * Returns true if the AnimControl was successfully loaded, or false if there
 * was a problem.  This may return false while is_pending() is true.
 */ 1 4 this 3 511  
50 0 0 4 76 484 0 0 205 /**
 * Specifies an event name that will be thrown when the AnimControl is
 * finished binding asynchronously.  If the AnimControl has already finished
 * binding, the event will be thrown immediately.
 */ 2 4 this 3 513  10 done_event 1 480  
51 0 0 6 77 480 0 0 113 /**
 * Returns the event name that will be thrown when the AnimControl is finished
 * binding asynchronously.
 */ 1 4 this 3 511  
52 0 0 7 78 471 419 0 65 /**
 * Returns the PartBundle bound in with this AnimControl.
 */ 1 4 this 3 511  
53 0 0 7 79 493 236 0 65 /**
 * Returns the AnimBundle bound in with this AnimControl.
 */ 1 4 this 3 511  
54 0 0 6 80 483 0 0 358 /**
 * Returns the particular channel index associated with this AnimControl.
 * This channel index is the slot on which each AnimGroup is bound to its
 * associated PartGroup, for each joint in the animation.
 *
 * It will be true that
 * get_part()->find_child("n")->get_bound(get_channel_index()) ==
 * get_anim()->find_child("n"), for each joint "n".
 */ 1 4 this 3 511  
55 0 0 6 81 514 0 0 369 /**
 * Returns the subset of joints controlled by this AnimControl.  Most of the
 * time, this will be BitArray::all_on(), for a normal full-body animation.
 * For a subset animation, however, this will be just a subset of those bits,
 * corresponding to the set of joints and sliders actually bound (as
 * enumerated by bind_hierarchy() in depth-first LIFO order).
 */ 1 4 this 3 511  
56 0 0 4 82 484 0 0 515 /**
 * Associates the indicated PandaNode with the AnimControl.  By convention,
 * this node represents the root node of the model file that corresponds to
 * this AnimControl's animation file, though nothing in this code makes this
 * assumption or indeed does anything with this node.
 *
 * The purpose of this is simply to allow the AnimControl to keep a reference
 * count on the ModelRoot node that generated it, so that the model will not
 * disappear from the model pool until it is no longer referenced.
 */ 2 4 this 3 513  5 model 1 500  
57 0 0 7 83 500 0 0 81 /**
 * Retrieves the pointer set via set_anim_model().  See set_anim_model().
 */ 1 4 this 3 511  
58 0 0 4 84 484 0 0 10 /**
 *
 */ 2 4 this 3 511  3 out 1 485  
59 0 0 7 85 488 0 0 0 0 
60 0 0 7 65 517 0 0 0 1 4 this 3 513  
61 0 0 7 66 513 271 0 0 1 4 this 3 517  
62 0 0 6 68 518 0 0 0 1 4 this 3 513  
63 0 0 7 69 513 271 0 0 1 4 this 3 518  
64 0 0 6 70 490 0 0 0 1 4 this 3 513  
65 0 0 7 71 513 271 0 0 1 4 this 3 490  
66 0 0 7 87 488 0 0 0 1 4 this 3 519  
67 0 0 7 88 488 0 0 0 0 
68 0 0 4 93 484 0 0 0 3 4 this 3 521  5 frame 1 483  5 value 1 522  
69 0 0 4 94 484 0 0 72 // These transform-component methods only have meaning for matrix types. 3 4 this 3 521  5 frame 1 483  5 value 1 522  
70 0 0 4 95 484 0 0 0 3 4 this 3 521  5 frame 1 483  5 scale 1 523  
71 0 0 4 96 484 0 0 0 3 4 this 3 521  5 frame 1 483  3 hpr 1 523  
72 0 0 4 97 484 0 0 0 3 4 this 3 521  5 frame 1 483  4 quat 1 524  
73 0 0 4 98 484 0 0 0 3 4 this 3 521  5 frame 1 483  3 pos 1 523  
74 0 0 4 99 484 0 0 0 3 4 this 3 521  5 frame 1 483  5 shear 1 523  
75 0 0 7 100 488 0 0 0 1 4 this 3 527  
76 0 0 7 101 488 0 0 0 0 
77 0 0 4 106 484 0 0 0 3 4 this 3 529  5 frame 1 483  5 scale 1 523  
78 0 0 4 107 484 0 0 0 3 4 this 3 529  5 frame 1 483  3 hpr 1 523  
79 0 0 4 108 484 0 0 0 3 4 this 3 529  5 frame 1 483  4 quat 1 524  
80 0 0 4 109 484 0 0 0 3 4 this 3 529  5 frame 1 483  3 pos 1 523  
81 0 0 4 110 484 0 0 0 3 4 this 3 529  5 frame 1 483  5 shear 1 523  
82 0 0 7 111 488 0 0 0 1 4 this 3 530  
83 0 0 7 112 488 0 0 0 0 
84 0 0 4 115 484 0 0 44 /**
 * Explicitly sets the matrix value.
 */ 2 4 this 3 532  5 value 1 533  
85 0 0 4 115 484 0 0 107 /**
 * Explicitly sets the matrix value, using the indicated TransformState object
 * as a convenience.
 */ 2 4 this 3 532  5 value 1 503  
86 0 0 4 116 484 0 0 124 /**
 * Specifies a node whose transform will be queried each frame to implicitly
 * specify the transform of this joint.
 */ 2 4 this 3 532  4 node 1 500  
87 0 0 7 117 503 0 0 93 /**
 * Returns the explicit TransformState value that was set via set_value(), if
 * any.
 */ 1 4 this 3 534  
88 0 0 7 118 500 0 0 70 /**
 * Returns the node that was set via set_value_node(), if any.
 */ 1 4 this 3 534  
89 0 0 7 119 488 0 0 0 0 
90 0 0 7 122 536 287 0 10 /**
 *
 */ 2 6 parent 1 438  4 name 1 480  
91 0 0 6 123 467 0 0 80 /**
 * Returns true if the given letter is one of the nine valid table id's.
 */ 1 8 table_id 1 537  
92 0 0 4 124 484 0 0 255 /**
 * Assigns the indicated table.  table_id is one of 'i', 'j', 'k', for scale,
 * 'a', 'b', 'c' for shear, 'h', 'p', 'r', for rotation, and 'x', 'y', 'z',
 * for translation.  The new table must have either zero, one, or
 * get_num_frames() frames.
 */ 3 4 this 3 536  8 table_id 1 537  5 table 1 538  
93 0 0 7 125 545 0 0 103 /**
 * Returns a pointer to the indicated subtable's data, if it exists, or NULL
 * if it does not.
 */ 2 4 this 3 543  8 table_id 1 537  
94 0 0 4 126 484 0 0 90 /**
 * Removes all the tables from the channel, and resets it to its initial
 * state.
 */ 1 4 this 3 536  
95 0 0 6 127 467 0 0 68 /**
 * Returns true if the indicated subtable has been assigned.
 */ 2 4 this 3 543  8 table_id 1 537  
96 0 0 4 128 484 0 0 59 /**
 * Removes the indicated table from the definition.
 */ 2 4 this 3 536  8 table_id 1 537  
97 0 0 7 129 488 0 0 0 0 
98 0 0 4 131 484 0 0 37 /**
 * Explicitly sets the value.
 */ 2 4 this 3 546  5 value 1 494  
99 0 0 4 132 484 0 0 124 /**
 * Specifies a node whose transform will be queried each frame to implicitly
 * specify the transform of this joint.
 */ 2 4 this 3 546  4 node 1 500  
100 0 0 7 133 488 0 0 0 0 
101 0 0 4 136 484 0 0 34 /**
 * Assigns the data table.
 */ 2 4 this 3 547  5 table 1 538  
102 0 0 7 137 545 0 0 90 /**
 * Returns a pointer to the table's data, if it exists, or NULL if it does
 * not.
 */ 1 4 this 3 548  
103 0 0 6 138 467 0 0 60 /**
 * Returns true if the data table has been assigned.
 */ 1 4 this 3 548  
104 0 0 4 139 484 0 0 34 /**
 * Empties the data table.
 */ 1 4 this 3 547  
105 0 0 7 140 488 0 0 0 0 
106 0 0 7 143 550 331 0 117 /**
 * Returns the AnimControl associated with the given name, or NULL if no such
 * control has been associated.
 */ 0 
107 0 0 7 143 550 331 0 0 1 6 param0 0 551  
108 0 0 4 145 484 0 0 247 /**
 * Associates the given AnimControl with this collection under the given name.
 * The AnimControl will remain associated until a new AnimControl is
 * associated with the same name later, or until unbind_anim() is called with
 * this name.
 */ 3 4 this 3 550  7 control 1 513  4 name 1 480  
109 0 0 7 146 513 271 0 117 /**
 * Returns the AnimControl associated with the given name, or NULL if no such
 * control has been associated.
 */ 2 4 this 3 551  4 name 1 480  
110 0 0 6 147 467 0 0 184 /**
 * Removes the AnimControl associated with the given name, if any.  Returns
 * true if an AnimControl was removed, false if there was no AnimControl with
 * the indicated name.
 */ 2 4 this 3 550  4 name 1 480  
111 0 0 6 148 483 0 0 78 /**
 * Returns the number of AnimControls associated with this collection.
 */ 1 4 this 3 551  
112 0 0 7 149 513 271 0 71 /**
 * Returns the nth AnimControl associated with this collection.
 */ 2 4 this 3 551  1 n 1 483  
113 0 0 6 150 480 0 0 83 /**
 * Returns the name of the nth AnimControl associated with this collection.
 */ 2 4 this 3 551  1 n 1 483  
114 0 0 4 153 484 0 0 56 /**
 * Disassociates all anims from this collection.
 */ 1 4 this 3 550  
115 0 0 6 154 467 0 0 46 /**
 * Starts the named animation playing.
 */ 2 4 this 3 550  9 anim_name 1 480  
116 0 0 6 154 467 0 0 46 /**
 * Starts the named animation playing.
 */ 4 4 this 3 550  9 anim_name 1 480  4 from 1 496  2 to 1 496  
117 0 0 6 155 467 0 0 46 /**
 * Starts the named animation looping.
 */ 3 4 this 3 550  9 anim_name 1 480  7 restart 1 467  
118 0 0 6 155 467 0 0 46 /**
 * Starts the named animation looping.
 */ 5 4 this 3 550  9 anim_name 1 480  7 restart 1 467  4 from 1 496  2 to 1 496  
119 0 0 6 156 467 0 0 37 /**
 * Stops the named animation.
 */ 2 4 this 3 550  9 anim_name 1 480  
120 0 0 6 157 467 0 0 61 /**
 * Sets to a particular frame in the named animation.
 */ 3 4 this 3 550  9 anim_name 1 480  5 frame 1 496  
121 0 0 4 158 484 0 0 48 // These functions operate on all anims at once. 1 4 this 3 550  
122 0 0 4 158 484 0 0 41 /**
 * Starts all animations playing.
 */ 3 4 this 3 550  4 from 1 496  2 to 1 496  
123 0 0 4 159 484 0 0 41 /**
 * Starts all animations looping.
 */ 2 4 this 3 550  7 restart 1 467  
124 0 0 4 159 484 0 0 41 /**
 * Starts all animations looping.
 */ 4 4 this 3 550  7 restart 1 467  4 from 1 496  2 to 1 496  
125 0 0 6 160 467 0 0 127 /**
 * Stops all currently playing animations.  Returns true if any animations
 * were stopped, false if none were playing.
 */ 1 4 this 3 550  
126 0 0 4 161 484 0 0 54 /**
 * Sets all animations to the indicated frame.
 */ 2 4 this 3 550  5 frame 1 496  
127 0 0 6 162 483 0 0 67 /**
 * Returns the current frame in the last-started animation.
 */ 1 4 this 3 551  
128 0 0 6 162 483 0 0 99 /**
 * Returns the current frame in the named animation, or 0 if the animation is
 * not found.
 */ 2 4 this 3 551  9 anim_name 1 480  
129 0 0 6 163 483 0 0 76 /**
 * Returns the total number of frames in the last-started animation.
 */ 1 4 this 3 551  
130 0 0 6 163 483 0 0 108 /**
 * Returns the total number of frames in the named animation, or 0 if the
 * animation is not found.
 */ 2 4 this 3 551  9 anim_name 1 480  
131 0 0 6 164 467 0 0 95 /**
 * Returns true if the last-started animation is currently playing, false
 * otherwise.
 */ 1 4 this 3 551  
132 0 0 6 164 467 0 0 85 /**
 * Returns true if the named animation is currently playing, false otherwise.
 */ 2 4 this 3 551  9 anim_name 1 480  
133 0 0 6 165 480 0 0 183 /**
 * Returns the name of the bound AnimControl currently playing, if any.  If
 * more than one AnimControl is currently playing, returns all of the names
 * separated by spaces.
 */ 1 4 this 3 551  
134 0 0 4 166 484 0 0 10 /**
 *
 */ 2 4 this 3 551  3 out 1 485  
135 0 0 4 167 484 0 0 10 /**
 *
 */ 2 4 this 3 551  3 out 1 485  
136 0 0 7 170 553 0 0 10 /**
 *
 */ 0 
137 0 0 6 171 483 0 0 64 /**
 * Returns the number of animation records in the table.
 */ 1 4 this 3 554  
138 0 0 6 172 483 0 0 321 /**
 * Returns the index number in the table of the animation record with the
 * indicated name, or -1 if the name is not present.  By convention, the
 * basename is the filename of the egg or bam file, without the directory part
 * and without the extension.  That is, it is
 * Filename::get_basename_wo_extension().
 */ 2 4 this 3 554  8 basename 1 480  
139 0 0 6 173 480 0 0 86 /**
 * Returns the basename stored for the nth animation record.  See find_anim().
 */ 2 4 this 3 554  1 n 1 483  
140 0 0 6 174 494 0 0 70 /**
 * Returns the frame rate stored for the nth animation record.
 */ 2 4 this 3 554  1 n 1 483  
141 0 0 6 175 483 0 0 76 /**
 * Returns the number of frames stored for the nth animation record.
 */ 2 4 this 3 554  1 n 1 483  
142 0 0 4 176 484 0 0 56 /**
 * Removes all animation records from the table.
 */ 1 4 this 3 553  
143 0 0 4 177 484 0 0 113 /**
 * Removes the nth animation records from the table.  This renumbers indexes
 * for following animations.
 */ 2 4 this 3 553  1 n 1 483  
144 0 0 4 178 484 0 0 227 /**
 * Adds a new animation record to the table.  If there is already a record of
 * this name, no operation is performed (the original record is unchanged).
 * See find_anim().  This will invalidate existing index numbers.
 */ 4 4 this 3 553  8 basename 1 480  15 base_frame_rate 1 494  10 num_frames 1 483  
145 0 0 4 179 484 0 0 160 /**
 * Copies the animation records from the other table into this one.  If a
 * given record name exists in both tables, the record in this one supercedes.
 */ 2 4 this 3 553  5 other 1 554  
146 0 0 4 180 484 0 0 10 /**
 *
 */ 2 4 this 3 554  3 out 1 485  
147 0 0 4 181 484 0 0 10 /**
 *
 */ 3 4 this 3 554  3 out 1 485  12 indent_level 1 483  
148 0 0 7 182 488 0 0 0 0 
149 0 0 7 185 556 376 0 10 /**
 *
 */ 0 
150 0 0 7 185 556 376 0 10 /**
 *
 */ 1 4 copy 1 557  
151 0 0 6 186 556 0 0 0 2 4 this 3 556  4 copy 1 557  
152 0 0 4 187 484 0 0 342 /**
 * Adds the named joint to the list of joints that will be explicitly included
 * in the subset.  Any joint at or below a named node will be included in the
 * subset (unless a lower node is also listed in the exclude list).
 *
 * Since the name is a GlobPattern, it may of course include filename globbing
 * characters like * and ?.
 */ 2 4 this 3 556  4 name 1 559  
153 0 0 4 188 484 0 0 352 /**
 * Adds the named joint to the list of joints that will be explicitly
 * exlcluded from the subset.  Any joint at or below a named node will not be
 * included in the subset (unless a lower node is also listed in the include
 * list).
 *
 * Since the name is a GlobPattern, it may of course include filename globbing
 * characters like * and ?.
 */ 2 4 this 3 556  4 name 1 559  
154 0 0 4 189 484 0 0 98 /**
 * Appends the include and exclude list from the other object onto this
 * object's lists.
 */ 2 4 this 3 556  5 other 1 557  
155 0 0 4 190 484 0 0 10 /**
 *
 */ 2 4 this 3 557  3 out 1 485  
156 0 0 6 191 467 0 0 147 /**
 * Returns true if the include list is completely empty, false otherwise.  If
 * it is empty, it is the same thing as including all joints.
 */ 1 4 this 3 557  
157 0 0 6 192 467 0 0 101 /**
 * Returns true if the indicated name matches a name on the include list,
 * false otherwise.
 */ 2 4 this 3 557  10 joint_name 1 480  
158 0 0 6 193 467 0 0 101 /**
 * Returns true if the indicated name matches a name on the exclude list,
 * false otherwise.
 */ 2 4 this 3 557  10 joint_name 1 480  
159 0 0 7 197 564 379 0 0 1 6 param0 0 562  
160 0 0 7 197 564 379 0 10 /**
 *
 */ 7 4 name 1 480  8 filename 1 565  7 options 1 568  6 loader 1 571  7 control 1 513  21 hierarchy_match_flags 1 483  6 subset 1 557  
161 0 0 7 198 488 0 0 0 0 
162 0 0 7 201 471 419 0 133 /**
 * Normally, a PartBundle constructor should not be called directly--it will
 * get created when a PartBundleNode is created.
 */ 1 4 name 1 480  
163 0 0 7 202 554 0 0 181 /**
 * Returns the AnimPreloadTable associated with the PartBundle.  This table,
 * if present, can be used for the benefit of load_bind_anim() to allow
 * asynchronous binding.
 */ 1 4 this 3 573  
164 0 0 7 203 553 0 0 106 /**
 * Returns a modifiable pointer to the AnimPreloadTable associated with the
 * PartBundle, if any.
 */ 1 4 this 3 471  
165 0 0 4 204 484 0 0 72 /**
 * Replaces the AnimPreloadTable associated with the PartBundle.
 */ 2 4 this 3 471  5 table 1 553  
166 0 0 4 205 484 0 0 71 /**
 * Removes any AnimPreloadTable associated with the PartBundle.
 */ 1 4 this 3 471  
167 0 0 4 206 484 0 0 85 /**
 * Copies the contents of the other PartBundle's preload table into this one.
 */ 2 4 this 3 471  5 other 1 573  
168 0 0 4 208 484 0 0 270 /**
 * Defines the algorithm that is used when blending multiple frames or
 * multiple animations together, when either anim_blend_flag or
 * frame_blend_flag is set to true.
 *
 * See partBundle.h for a description of the meaning of each of the BlendType
 * values.
 */ 2 4 this 3 471  2 bt 1 466  
169 0 0 6 209 466 0 0 178 /**
 * Returns the algorithm that is used when blending multiple frames or
 * multiple animations together, when either anim_blend_flag or
 * frame_blend_flag is set to true.
 */ 1 4 this 3 573  
170 0 0 4 210 484 0 0 581 /**
 * Defines the way the character responds to multiple calls to
 * set_control_effect()).  By default, this flag is set false, which disallows
 * multiple animations.  When this flag is false, it is not necessary to
 * explicitly set the control_effect when starting an animation; starting the
 * animation will implicitly remove the control_effect from the previous
 * animation and set it on the current one.
 *
 * However, if this flag is set true, the control_effect must be explicitly
 * set via set_control_effect() whenever an animation is to affect the
 * character.
 */ 2 4 this 3 471  15 anim_blend_flag 1 467  
171 0 0 6 211 467 0 0 136 /**
 * Returns whether the character allows multiple different animations to be
 * bound simultaneously.  See set_anim_blend_flag().
 */ 1 4 this 3 573  
172 0 0 4 212 484 0 0 775 /**
 * Specifies whether the character interpolates (blends) between two
 * sequential frames of an active animation, showing a smooth intra-frame
 * motion, or whether it holds each frame until the next frame is ready,
 * showing precisely the specified animation.
 *
 * When this value is false, the character holds each frame until the next is
 * ready.  When this is true, the character will interpolate between two
 * consecutive frames of animation for each frame the animation is onscreen,
 * according to the amount of time elapsed between the frames.
 *
 * The default value of this flag is determined by the interpolate-frames
 * Config.prc variable.
 *
 * Use set_blend_type() to change the algorithm that the character uses to
 * interpolate matrix positions.
 */ 2 4 this 3 471  16 frame_blend_flag 1 467  
173 0 0 6 213 467 0 0 205 /**
 * Returns whether the character interpolates (blends) between two sequential
 * animation frames, or whether it holds the current frame until the next one
 * is ready.  See set_frame_blend_flag().
 */ 1 4 this 3 573  
174 0 0 4 214 484 0 0 111 /**
 * Specifies the transform matrix which is implicitly applied at the root of
 * the animated hierarchy.
 */ 2 4 this 3 471  10 root_xform 1 533  
175 0 0 4 215 484 0 0 81 /**
 * Applies the indicated transform to the root of the animated hierarchy.
 */ 2 4 this 3 471  3 mat 1 533  
176 0 0 6 216 533 0 0 109 /**
 * Returns the transform matrix which is implicitly applied at the root of the
 * animated hierarchy.
 */ 1 4 this 3 573  
177 0 0 7 217 471 419 0 226 /**
 * Returns a PartBundle that is a duplicate of this one, but with the
 * indicated transform applied.  If this is called multiple times with the
 * same TransformState pointer, it returns the same PartBundle each time.
 */ 2 4 this 3 471  9 transform 1 503  
178 0 0 6 218 483 0 0 94 /**
 * Returns the number of PartBundleNodes that contain a pointer to this
 * PartBundle.
 */ 1 4 this 3 573  
179 0 0 7 219 469 0 0 74 /**
 * Returns the nth PartBundleNode associated with this PartBundle.
 */ 2 4 this 3 573  1 n 1 483  
180 0 0 4 247 484 0 0 518 /**
 * Sets the control effect of all AnimControls to zero (but does not "stop"
 * the AnimControls).  The character will no longer be affected by any
 * animation, and will return to its default pose (unless restore-initial-pose
 * is false).
 *
 * The AnimControls which are no longer associated will not be using any CPU
 * cycles, but they may still be in the "playing" state; if they are later
 * reassociated with the PartBundle they will resume at their current frame as
 * if they'd been running all along.
 */ 1 4 this 3 471  
181 0 0 4 248 484 0 0 530 /**
 * Sets the amount by which the character is affected by the indicated
 * AnimControl (and its associated animation).  Normally, this will only be
 * zero or one.  Zero indicates the animation does not affect the character,
 * and one means it does.
 *
 * If the _anim_blend_flag is not false (see set_anim_blend_flag()), it is
 * possible to have multiple AnimControls in effect simultaneously.  In this
 * case, the effect is a weight that indicates the relative importance of each
 * AnimControl to the final animation.
 */ 3 4 this 3 471  7 control 1 513  6 effect 1 494  
182 0 0 6 249 494 0 0 153 /**
 * Returns the amount by which the character is affected by the indicated
 * AnimControl and its associated animation.  See set_control_effect().
 */ 2 4 this 3 573  7 control 1 513  
183 0 0 4 250 484 0 0 55 /**
 * Writes a one-line description of the bundle.
 */ 2 4 this 3 573  3 out 1 485  
184 0 0 7 251 513 271 0 790 /**
 * Binds the animation to the bundle, if possible, and returns a new
 * AnimControl that can be used to start and stop the animation.  If the anim
 * hierarchy does not match the part hierarchy, returns NULL.
 *
 * If hierarchy_match_flags is 0, only an exact match is accepted; otherwise,
 * it may contain a union of PartGroup::HierarchyMatchFlags values indicating
 * conditions that will be tolerated (but warnings will still be issued).
 *
 * If subset is specified, it restricts the binding only to the named subtree
 * of joints.
 *
 * The AnimControl is not stored within the PartBundle; it is the user's
 * responsibility to maintain the pointer.  The animation will automatically
 * unbind itself when the AnimControl destructs (i.e.  its reference count
 * goes to zero).
 */ 4 4 this 3 471  4 anim 1 493  21 hierarchy_match_flags 1 483  6 subset 1 557  
185 0 0 7 252 513 271 0 1088 /**
 * Binds an animation to the bundle.  The animation is loaded from the disk
 * via the indicated Loader object.  In other respects, this behaves similarly
 * to bind_anim(), with the addition of asynchronous support.
 *
 * If allow_aysnc is true, the load will be asynchronous if possible.  This
 * requires that the animation basename can be found in the PartBundle's
 * preload table (see get_anim_preload()).
 *
 * In an asynchronous load, the animation file will be loaded and bound in a
 * sub-thread.  This means that the animation will not necessarily be
 * available at the time this method returns.  You may still use the returned
 * AnimControl immediately, though, but no visible effect will occur until the
 * animation eventually becomes available.
 *
 * You can test AnimControl::is_pending() to see if the animation has been
 * loaded yet, or wait for it to finish with AnimControl::wait_pending() or
 * even PartBundle::wait_pending().  You can also set an event to be triggered
 * when the animation finishes loading with
 * AnimControl::set_pending_done_event().
 */ 6 4 this 3 471  6 loader 1 571  8 filename 1 565  21 hierarchy_match_flags 1 483  6 subset 1 557  11 allow_async 1 467  
186 0 0 4 253 484 0 0 153 /**
 * Blocks the current thread until all currently-pending AnimControls, with a
 * nonzero control effect, have been loaded and are properly bound.
 */ 1 4 this 3 471  
187 0 0 6 254 467 0 0 373 /**
 * Specifies that the joint with the indicated name should be frozen with the
 * specified transform.  It will henceforth always hold this fixed transform,
 * regardless of any animations that may subsequently be bound to the joint.
 *
 * Returns true if the joint is successfully frozen, or false if the named
 * child is not a joint (or slider) or does not exist.
 */ 5 4 this 3 471  10 joint_name 1 480  3 pos 1 506  3 hpr 1 506  5 scale 1 506  
188 0 0 6 254 467 0 0 373 /**
 * Specifies that the joint with the indicated name should be frozen with the
 * specified transform.  It will henceforth always hold this fixed transform,
 * regardless of any animations that may subsequently be bound to the joint.
 *
 * Returns true if the joint is successfully frozen, or false if the named
 * child is not a joint (or slider) or does not exist.
 */ 3 4 this 3 471  10 joint_name 1 480  5 value 1 494  
189 0 0 6 254 467 0 0 373 /**
 * Specifies that the joint with the indicated name should be frozen with the
 * specified transform.  It will henceforth always hold this fixed transform,
 * regardless of any animations that may subsequently be bound to the joint.
 *
 * Returns true if the joint is successfully frozen, or false if the named
 * child is not a joint (or slider) or does not exist.
 */ 3 4 this 3 471  10 joint_name 1 480  9 transform 1 503  
190 0 0 6 255 467 0 0 396 /**
 * Specifies that the joint with the indicated name should be animated with
 * the transform on the indicated node.  It will henceforth always follow the
 * node's transform, regardless of any animations that may subsequently be
 * bound to the joint.
 *
 * Returns true if the joint is successfully controlled, or false if the named
 * child is not a joint (or slider) or does not exist.
 */ 3 4 this 3 471  10 joint_name 1 480  4 node 1 500  
191 0 0 6 256 467 0 0 342 /**
 * Releases the named joint from the effects of a previous call to
 * freeze_joint() or control_joint(). It will henceforth once again follow
 * whatever transforms are dictated by the animation.
 *
 * Returns true if the joint is released, or false if the named child was not
 * previously controlled or frozen, or it does not exist.
 */ 2 4 this 3 471  10 joint_name 1 480  
192 0 0 6 257 467 0 0 216 /**
 * Updates all the parts in the bundle to reflect the data for the current
 * frame (as set in each of the AnimControls).
 *
 * Returns true if any part has changed as a result of this, or false
 * otherwise.
 */ 1 4 this 3 471  
193 0 0 6 258 467 0 0 131 /**
 * Updates all the parts in the bundle to reflect the data for the current
 * frame, whether we believe it needs it or not.
 */ 1 4 this 3 471  
194 0 0 7 259 488 0 0 0 0 
195 0 0 7 230 469 0 0 226 /**
 * The PartBundle and its node should be constructed together.  Generally, the
 * derived classes of PartBundleNode will automatically create a PartBundle of
 * the appropriate type, and pass it up to this constructor.
 */ 2 4 name 1 480  6 bundle 1 471  
196 0 0 6 231 483 0 0 10 /**
 *
 */ 1 4 this 3 575  
197 0 0 7 232 471 419 0 10 /**
 *
 */ 2 4 this 3 575  1 n 1 483  
198 0 0 7 234 472 0 0 204 /**
 * Returns the PartBundleHandle that wraps around the actual nth PartBundle.
 * While the PartBundle pointer might later change due to a future flatten
 * operation, the PartBundleHandle will not.
 */ 2 4 this 3 575  1 n 1 483  
199 0 0 7 246 488 0 0 0 0 
200 0 0 7 242 472 0 0 10 /**
 *
 */ 1 6 bundle 1 471  
201 0 0 7 242 472 0 0 0 1 6 param0 0 577  
202 0 0 7 243 471 419 0 68 /**
 * Returns the actual PartBundle embedded within the handle.
 */ 1 4 this 3 472  
203 0 0 4 244 484 0 0 68 /**
 * Changes the actual PartBundle embedded within the handle.
 */ 2 4 this 3 472  6 bundle 1 471  
204 0 0 6 262 483 0 0 310 /**
 * Returns the number of channels that might be bound to this PartGroup.  This
 * might not be the actual number of channels, since there might be holes in
 * the list; it is one more than the index number of the highest bound
 * channel.  Thus, it is called get_max_bound() instead of get_num_bound().
 */ 1 4 this 3 579  
205 0 0 7 263 510 287 0 371 /**
 * Returns the nth bound channel on this PartGroup.  n can be determined by
 * iterating from 0 to one less than get_max_bound(); or n might be
 * AnimControl::get_channel_index().
 *
 * This will return NULL if there is no channel bound on the indicated index.
 * It is an error to call this if n is less than zero or greater than or equal
 * to get_max_bound().
 */ 2 4 this 3 579  1 n 1 483  
206 0 0 4 264 484 0 0 0 2 4 this 3 579  3 out 1 485  
207 0 0 7 265 488 0 0 0 0 
208 0 0 7 273 488 0 0 0 0 
209 0 0 7 269 488 0 0 0 0 
210 0 0 7 270 522 0 0 0 1 4 this 3 581  
211 0 0 7 271 522 0 0 0 1 4 this 3 581  
212 0 0 7 280 488 0 0 0 0 
213 0 0 7 276 488 0 0 0 0 
214 0 0 6 277 494 0 0 0 1 4 this 3 583  
215 0 0 6 278 494 0 0 0 1 4 this 3 583  
216 0 0 4 183 484 0 0 0 3 9 root_node 1 500  8 controls 1 550  21 hierarchy_match_flags 1 483  
150
435 9 AnimGroup 0 26625 9 AnimGroup 9 AnimGroup 0 0 0 1 221 222 1 585 8 223 224 225 226 227 228 229 230 1 595 0 2 3 436 217 218 3 437 219 220 0 0 165
/**
 * This is the base class for AnimChannel and AnimBundle.  It implements a
 * hierarchy of AnimChannels.  The root of the hierarchy must be an
 * AnimBundle.
 */

436 27 TypedWritableReferenceCount 0 2049 27 TypedWritableReferenceCount 27 TypedWritableReferenceCount 0 0 0 0 0 0 0 0 0 0 0 0 414
/**
 * A base class for things which need to inherit from both TypedWritable and
 * from ReferenceCount.  It's convenient to define this intermediate base
 * class instead of multiply inheriting from the two classes each time they
 * are needed, so that we can sensibly pass around pointers to things which
 * are both TypedWritables and ReferenceCounters.
 *
 * See also TypedObject for detailed instructions.
 */

437 7 Namable 0 2049 7 Namable 7 Namable 0 0 0 0 0 0 0 0 0 0 0 0 125
/**
 * A base class for all things which can have a name.  The name is either
 * empty or nonempty, but it is never NULL.
 */

438 11 AnimGroup * 0 8576 11 AnimGroup * 11 AnimGroup * 0 0 435 0 0 0 0 0 0 0 0 0 0

439 10 AnimBundle 0 141313 10 AnimBundle 10 AnimBundle 0 0 0 1 231 236 0 4 232 233 234 235 0 0 1 0 435 0 0 0 0 169
/**
 * This is the root of an AnimChannel hierarchy.  It knows the frame rate and
 * number of frames of all the channels in the hierarchy (which must all
 * match).
 */

440 14 AnimBundleNode 0 141313 14 AnimBundleNode 14 AnimBundleNode 0 0 0 1 237 241 0 3 238 239 240 0 0 1 0 441 0 0 0 0 169
/**
 * This is a node that contains a pointer to an AnimBundle.  Like
 * PartBundleNode, it exists solely to make it easy to store AnimBundles in
 * the scene graph.
 */

441 9 PandaNode 0 2049 9 PandaNode 9 PandaNode 0 0 0 0 0 0 0 0 0 0 0 0 175
/**
 * A basic node of the scene graph or data graph.  This is the base class of
 * all specialized nodes, and also serves as a generic node with no special
 * properties.
 */

442 9 PartGroup 0 26625 9 PartGroup 9 PartGroup 0 0 0 1 246 247 1 586 17 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 1 596 0 2 3 436 242 243 3 437 244 245 0 1 443 105
/**
 * This is the base class for PartRoot and MovingPart.  It defines a hierarchy
 * of MovingParts.
 */

443 19 HierarchyMatchFlags 0 794624 30 PartGroup::HierarchyMatchFlags 30 PartGroup::HierarchyMatchFlags 442 0 0 0 0 0 0 0 0 0 3 17 HMF_ok_part_extra 28 PartGroup::HMF_ok_part_extra 0
1 17 HMF_ok_anim_extra 28 PartGroup::HMF_ok_anim_extra 0
2 22 HMF_ok_wrong_root_name 33 PartGroup::HMF_ok_wrong_root_name 0
4 0 214
// This enum defines bits which may be passed into check_hierarchy() and
// PartBundle::bind_anim() to allow an inexact match of channel hierarchies.
// This specifies conditions that we don't care about enforcing.

444 11 PartGroup * 0 8576 11 PartGroup * 11 PartGroup * 0 0 442 0 0 0 0 0 0 0 0 0 0

445 11 AnimControl 0 26625 11 AnimControl 11 AnimControl 0 0 0 0 271 0 13 272 273 274 275 276 277 278 279 280 281 282 283 284 0 0 3 3 446 265 266 3 447 267 268 3 437 269 270 0 0 255
/**
 * Controls the timing of a character animation.  An AnimControl object is
 * created for each character/bundle binding and manages the state of the
 * animation: whether started, stopped, or looping, and the current frame
 * number and play rate.
 */

446 19 TypedReferenceCount 0 2049 19 TypedReferenceCount 19 TypedReferenceCount 0 0 0 0 0 0 0 0 0 0 0 0 410
/**
 * A base class for things which need to inherit from both TypedObject and
 * from ReferenceCount.  It's convenient to define this intermediate base
 * class instead of multiply inheriting from the two classes each time they
 * are needed, so that we can sensibly pass around pointers to things which
 * are both TypedObjects and ReferenceCounters.
 *
 * See also TypedObject for detailed instructions.
 */

447 13 AnimInterface 0 2049 13 AnimInterface 13 AnimInterface 0 0 0 0 0 0 0 0 0 0 0 0 226
/**
 * This is the fundamental interface for things that have a play/loop/stop
 * type interface for frame-based animation, such as animated characters.
 * This is the base class for AnimControl and other, similar classes.
 */

448 15 AnimChannelBase 0 141313 15 AnimChannelBase 15 AnimChannelBase 0 0 0 0 287 0 2 285 286 0 0 1 0 435 0 0 0 0 253
/**
 * Parent class for all animation channels.  An AnimChannel is an arbitrary
 * function that changes over time (actually, over frames), usually defined by
 * a table read from an egg file (but possibly computed or generated in any
 * other way).
 */

449 33 AnimChannel< ACMatrixSwitchType > 0 75777 33 AnimChannel< ACMatrixSwitchType > 33 AnimChannel< ACMatrixSwitchType > 0 0 0 0 287 0 9 288 289 290 291 292 293 294 295 296 0 0 1 0 448 0 0 0 1 450 0

450 8 LMatrix4 0 2105344 8 LMatrix4 8 LMatrix4 0 0 451 0 0 0 0 0 0 0 0 0 0

451 9 LMatrix4f 0 2048 9 LMatrix4f 9 LMatrix4f 0 0 0 0 0 0 0 0 0 0 0 0 45
/**
 * This is a 4-by-4 transform matrix.
 */

452 17 AnimChannelMatrix 0 2105345 17 AnimChannelMatrix 17 AnimChannelMatrix 0 0 449 0 0 0 0 0 0 0 0 0 0

453 33 AnimChannel< ACScalarSwitchType > 0 75777 33 AnimChannel< ACScalarSwitchType > 33 AnimChannel< ACScalarSwitchType > 0 0 0 0 287 0 9 297 298 299 300 301 302 303 304 305 0 0 1 0 448 0 0 0 0 0

454 17 AnimChannelScalar 0 2105345 17 AnimChannelScalar 17 AnimChannelScalar 0 0 453 0 0 0 0 0 0 0 0 0 0

455 24 AnimChannelMatrixDynamic 0 141313 24 AnimChannelMatrixDynamic 24 AnimChannelMatrixDynamic 0 0 0 0 311 0 5 306 307 308 309 310 0 0 1 0 449 0 0 0 0 393
/**
 * An animation channel that accepts a matrix each frame from some dynamic
 * input provided by code.
 *
 * This object operates in two modes: in explicit mode, the programmer should
 * call set_value() each frame to indicate the new value; in implicit mode,
 * the programmer should call set_value_node() to indicate the node whose
 * transform will be copied to the joint each frame.
 */

456 25 AnimChannelMatrixXfmTable 0 75777 25 AnimChannelMatrixXfmTable 25 AnimChannelMatrixXfmTable 0 0 0 1 312 287 0 7 313 314 315 316 317 318 319 0 0 1 0 449 0 0 0 0 263
/**
 * An animation channel that issues a matrix each frame, read from a table
 * such as might have been read from an egg file.  The table actually consists
 * of nine sub-tables, each representing one component of the transform:
 * scale, rotate, translate.
 */

457 24 AnimChannelScalarDynamic 0 141313 24 AnimChannelScalarDynamic 24 AnimChannelScalarDynamic 0 0 0 0 323 0 3 320 321 322 0 0 1 0 453 0 0 0 0 396
/**
 * An animation channel that accepts a scalar each frame from some dynamic
 * input provided by code.
 *
 * This object operates in two modes: in explicit mode, the programmer should
 * call set_value() each frame to indicate the new value; in implicit mode,
 * the programmer should call set_value_node() to indicate the node whose X
 * component will be copied to the scalar each frame.
 */

458 22 AnimChannelScalarTable 0 141313 22 AnimChannelScalarTable 22 AnimChannelScalarTable 0 0 0 0 329 0 5 324 325 326 327 328 0 0 1 0 453 0 0 0 0 132
/**
 * An animation channel that issues a scalar each frame, read from a table
 * such as might have been read from an egg file.
 */

459 21 AnimControlCollection 0 26625 21 AnimControlCollection 21 AnimControlCollection 0 0 0 1 330 331 0 21 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 2 597 598 0 0 0 0 356
/**
 * This is a named collection of AnimControl pointers.  An AnimControl may be
 * added to the collection by name.  While an AnimControl is associated, its
 * reference count is maintained; associating a new AnimControl with the same
 * name will decrement the previous control's reference count (and possibly
 * delete it, unbinding its animation).
 */

460 16 AnimPreloadTable 0 75777 16 AnimPreloadTable 16 AnimPreloadTable 0 0 0 1 353 0 0 12 354 355 356 357 358 359 360 361 362 363 364 365 0 0 1 0 461 0 0 0 0 260
/**
 * This table records data about a list of animations for a particular model,
 * such as number of frames and frame rate.  It's used for implementating
 * asynchronous binding.
 *
 * This table is normally built by an offline tool, such as egg-optchar.
 */

461 17 CopyOnWriteObject 0 2049 17 CopyOnWriteObject 17 CopyOnWriteObject 0 0 0 0 0 0 0 0 0 0 0 0 169
/**
 * This base class provides basic reference counting, but also can be used
 * with a CopyOnWritePointer to provide get_read_pointer() and
 * get_write_pointer().
 */

462 10 PartSubset 0 141313 10 PartSubset 10 PartSubset 0 0 0 1 367 376 0 8 368 369 370 371 372 373 374 375 0 0 0 0 0 190
/**
 * This class is used to define a subset of part names to apply to the
 * PartBundle::bind_anim() operation.  Only those part names within the subset
 * will be included in the bind.
 */

463 15 BindAnimRequest 0 141313 15 BindAnimRequest 15 BindAnimRequest 0 0 0 1 377 379 0 1 378 0 0 1 0 464 0 0 0 0 136
/**
 * This class object manages an asynchronous load-and-bind animation request,
 * as issued through PartBundle::load_bind_anim().
 */

464 16 ModelLoadRequest 0 2049 16 ModelLoadRequest 16 ModelLoadRequest 0 0 0 0 0 0 0 0 0 0 0 0 191
/**
 * A class object that manages a single asynchronous model load request.
 * Create a new ModelLoadRequest, and add it to the loader via load_async(),
 * to begin an asynchronous load.
 */

465 10 PartBundle 0 141313 10 PartBundle 10 PartBundle 0 0 0 1 380 419 5 587 588 589 590 591 30 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 406 407 408 409 410 411 412 413 414 415 416 417 418 1 599 0 1 0 442 0 0 0 1 466 134
/**
 * This is the root of a MovingPart hierarchy.  It defines the hierarchy of
 * moving parts that make up an animatable object.
 */

466 9 BlendType 0 794624 21 PartBundle::BlendType 21 PartBundle::BlendType 465 0 0 0 0 0 0 0 0 0 4 9 BT_linear 21 PartBundle::BT_linear 387
// BT_linear does a componentwise average of all blended matrices, which
// is a linear blend.  The result of this is that if a particular vertex
// would have been at point P in one animation and point Q in another one,
// it will end up on the line in between them in the resulting blend
// animation.  However, this tends to stretch and squash limbs in strange
// and disturbing ways.
0 20 BT_normalized_linear 32 PartBundle::BT_normalized_linear 452
// BT_normalized_linear is a compromise on BT_linear.  The matrix is
// blended linearly without the scale and shear components, and the
// blended scale and shear components are applied separately.  This keeps
// all of the character's body parts in the correct size and shape.
// However, if the hierarchy is disconnected, body parts can fly off.
// It's essential the skeleton hierarchy be completely connected to use
// this blend mode successully.
1 16 BT_componentwise 28 PartBundle::BT_componentwise 115
// BT_componentwise linearly blends all components separately, including
// H, P, and R, and recomposes the matrix.
2 21 BT_componentwise_quat 33 PartBundle::BT_componentwise_quat 124
// BT_componentwise_quat linearly blends all components separately, except
// for rotation which is blended as a quaternion.
3 0 240
// This is the parameter to set_blend_type() and specifies the kind of
// blending operation to be performed when multiple controls are in effect
// simultaneously (see set_control_effect()) or between sequential frames of
// the animation.

467 4 bool 0 8194 4 bool 4 bool 0 4 0 0 0 0 0 0 0 0 0 0 0

468 14 LMatrix4 const 0 8832 14 LMatrix4 const 14 LMatrix4 const 0 0 450 0 0 0 0 0 0 0 0 0 0

469 16 PartBundleNode * 0 8576 16 PartBundleNode * 16 PartBundleNode * 0 0 470 0 0 0 0 0 0 0 0 0 0

470 14 PartBundleNode 0 75777 14 PartBundleNode 14 PartBundleNode 0 0 0 1 398 0 2 592 593 4 399 400 401 405 2 600 601 0 1 0 441 0 0 0 0 342
/**
 * This is a node that contains a pointer to an PartBundle.  Like
 * AnimBundleNode, it exists to make it easy to store PartBundles in the scene
 * graph.
 *
 * (Unlike AnimBundleNode, however, PartBundleNode has an additional function:
 * it is also the base class of the Character node type, which adds additional
 * functionality.)
 */

471 12 PartBundle * 0 8576 12 PartBundle * 12 PartBundle * 0 0 465 0 0 0 0 0 0 0 0 0 0

472 18 PartBundleHandle * 0 8576 18 PartBundleHandle * 18 PartBundleHandle * 0 0 473 0 0 0 0 0 0 0 0 0 0

473 16 PartBundleHandle 0 75777 16 PartBundleHandle 16 PartBundleHandle 0 0 0 1 402 0 1 594 2 403 404 0 0 1 0 474 0 0 0 0 546
/**
 * This is a trivial class returned by PartBundleNode::get_bundle().  Its
 * purpose is to hold the actual PartBundle pointer contained within the
 * PartBundleNode, so that scene graph flatten operations can safely combine
 * or duplicate PartBundles as necessary without affecting high-level bundle
 * operations.
 *
 * The high-level Actor class defined in direct/src/actor, for instance, will
 * store a list of PartBundleHandles instead of on actual PartBundles, so that
 * it will be immune to changes from these flatten operations.
 */

474 14 ReferenceCount 0 2049 14 ReferenceCount 14 ReferenceCount 0 0 0 0 0 0 0 0 0 0 0 0 203
/**
 * A base class for all things that want to be reference-counted.
 * ReferenceCount works in conjunction with PointerTo to automatically delete
 * objects when the last pointer to them goes away.
 */

475 14 MovingPartBase 0 141313 14 MovingPartBase 14 MovingPartBase 0 0 0 0 424 0 4 420 421 422 423 0 0 1 0 442 0 0 0 0 332
/**
 * This is the base class for a single animatable piece that may be bound to
 * one channel (or more, if blending is in effect).  It corresponds to, for
 * instance, a single joint or slider of a character.
 *
 * MovingPartBase does not have a particular value type.  See the derived
 * template class, MovingPart, for this.
 */

476 16 MovingPartMatrix 0 75777 16 MovingPartMatrix 16 MovingPartMatrix 0 0 0 0 428 0 1 429 0 0 1 0 477 0 0 0 0 84
/**
 * This is a particular kind of MovingPart that accepts a matrix each frame.
 */

477 32 MovingPart< ACMatrixSwitchType > 0 141313 32 MovingPart< ACMatrixSwitchType > 32 MovingPart< ACMatrixSwitchType > 0 0 0 0 428 0 3 425 426 427 0 0 1 0 475 0 0 0 1 450 0

478 16 MovingPartScalar 0 75777 16 MovingPartScalar 16 MovingPartScalar 0 0 0 0 433 0 1 434 0 0 1 0 479 0 0 0 0 84
/**
 * This is a particular kind of MovingPart that accepts a scalar each frame.
 */

479 32 MovingPart< ACScalarSwitchType > 0 141313 32 MovingPart< ACScalarSwitchType > 32 MovingPart< ACScalarSwitchType > 0 0 0 0 433 0 3 430 431 432 0 0 1 0 475 0 0 0 0 0

480 13 atomic string 0 2 13 atomic string 13 atomic string 0 7 0 0 0 0 0 0 0 0 0 0 0

481 17 AnimGroup const * 0 8576 17 AnimGroup const * 17 AnimGroup const * 0 0 482 0 0 0 0 0 0 0 0 0 0

482 15 AnimGroup const 0 8832 15 AnimGroup const 15 AnimGroup const 0 0 435 0 0 0 0 0 0 0 0 0 0

483 3 int 0 8194 3 int 3 int 0 1 0 0 0 0 0 0 0 0 0 0 0

484 4 void 0 8194 4 void 4 void 0 6 0 0 0 0 0 0 0 0 0 0 0

485 9 ostream * 0 8576 9 ostream * 9 ostream * 0 0 486 0 0 0 0 0 0 0 0 0 0

486 7 ostream 0 2048 7 ostream 7 ostream 0 0 0 0 0 0 0 0 0 0 0 0 0

487 10 TypeHandle 0 2048 10 TypeHandle 10 TypeHandle 0 0 0 0 0 0 0 0 0 0 0 0 732
/**
 * TypeHandle is the identifier used to differentiate C++ class types.  Any
 * C++ classes that inherit from some base class, and must be differentiated
 * at run time, should store a static TypeHandle object that can be queried
 * through a static member function named get_class_type().  Most of the time,
 * it is also desirable to inherit from TypedObject, which provides some
 * virtual functions to return the TypeHandle for a particular instance.
 *
 * At its essence, a TypeHandle is simply a unique identifier that is assigned
 * by the TypeRegistry.  The TypeRegistry stores a tree of TypeHandles, so
 * that ancestry of a particular type may be queried, and the type name may be
 * retrieved for run-time display.
 */

488 12 TypeHandle * 0 8576 12 TypeHandle * 12 TypeHandle * 0 0 487 0 0 0 0 0 0 0 0 0 0

489 29 TypedWritableReferenceCount * 0 8576 29 TypedWritableReferenceCount * 29 TypedWritableReferenceCount * 0 0 436 0 0 0 0 0 0 0 0 0 0

490 9 Namable * 0 8576 9 Namable * 9 Namable * 0 0 437 0 0 0 0 0 0 0 0 0 0

491 18 AnimBundle const * 0 8576 18 AnimBundle const * 18 AnimBundle const * 0 0 492 0 0 0 0 0 0 0 0 0 0

492 16 AnimBundle const 0 8832 16 AnimBundle const 16 AnimBundle const 0 0 439 0 0 0 0 0 0 0 0 0 0

493 12 AnimBundle * 0 8576 12 AnimBundle * 12 AnimBundle * 0 0 439 0 0 0 0 0 0 0 0 0 0

494 11 PN_stdfloat 0 2105344 11 PN_stdfloat 11 PN_stdfloat 0 0 495 0 0 0 0 0 0 0 0 0 0

495 5 float 0 8194 5 float 5 float 0 2 0 0 0 0 0 0 0 0 0 0 0

496 6 double 0 8194 6 double 6 double 0 3 0 0 0 0 0 0 0 0 0 0 0

497 16 AnimBundleNode * 0 8576 16 AnimBundleNode * 16 AnimBundleNode * 0 0 440 0 0 0 0 0 0 0 0 0 0

498 22 AnimBundleNode const * 0 8576 22 AnimBundleNode const * 22 AnimBundleNode const * 0 0 499 0 0 0 0 0 0 0 0 0 0

499 20 AnimBundleNode const 0 8832 20 AnimBundleNode const 20 AnimBundleNode const 0 0 440 0 0 0 0 0 0 0 0 0 0

500 11 PandaNode * 0 8576 11 PandaNode * 11 PandaNode * 0 0 441 0 0 0 0 0 0 0 0 0 0

501 17 PartGroup const * 0 8576 17 PartGroup const * 17 PartGroup const * 0 0 502 0 0 0 0 0 0 0 0 0 0

502 15 PartGroup const 0 8832 15 PartGroup const 15 PartGroup const 0 0 442 0 0 0 0 0 0 0 0 0 0

503 22 TransformState const * 0 8576 22 TransformState const * 22 TransformState const * 0 0 504 0 0 0 0 0 0 0 0 0 0

504 20 TransformState const 0 8832 20 TransformState const 20 TransformState const 0 0 505 0 0 0 0 0 0 0 0 0 0

505 14 TransformState 0 2048 14 TransformState 14 TransformState 0 0 0 0 0 0 0 0 0 0 0 0 734
/**
 * Indicates a coordinate-system transform on vertices.  TransformStates are
 * the primary means for storing transformations on the scene graph.
 *
 * Transforms may be specified in one of two ways: componentwise, with a pos-
 * hpr-scale, or with an arbitrary transform matrix.  If you specify a
 * transform componentwise, it will remember its original components.
 *
 * TransformState objects are managed very much like RenderState objects.
 * They are immutable and reference-counted automatically.
 *
 * You should not attempt to create or modify a TransformState object
 * directly.  Instead, call one of the make() functions to create one for you.
 * And instead of modifying a TransformState object, create a new one.
 */

506 17 LVecBase3 const * 0 8576 17 LVecBase3 const * 17 LVecBase3 const * 0 0 507 0 0 0 0 0 0 0 0 0 0

507 15 LVecBase3 const 0 8832 15 LVecBase3 const 15 LVecBase3 const 0 0 508 0 0 0 0 0 0 0 0 0 0

508 9 LVecBase3 0 2105344 9 LVecBase3 9 LVecBase3 0 0 509 0 0 0 0 0 0 0 0 0 0

509 10 LVecBase3f 0 2048 10 LVecBase3f 10 LVecBase3f 0 0 0 0 0 0 0 0 0 0 0 0 77
/**
 * This is the base class for all three-component vectors and points.
 */

510 17 AnimChannelBase * 0 8576 17 AnimChannelBase * 17 AnimChannelBase * 0 0 448 0 0 0 0 0 0 0 0 0 0

511 19 AnimControl const * 0 8576 19 AnimControl const * 19 AnimControl const * 0 0 512 0 0 0 0 0 0 0 0 0 0

512 17 AnimControl const 0 8832 17 AnimControl const 17 AnimControl const 0 0 445 0 0 0 0 0 0 0 0 0 0

513 13 AnimControl * 0 8576 13 AnimControl * 13 AnimControl * 0 0 445 0 0 0 0 0 0 0 0 0 0

514 16 BitArray const * 0 8576 16 BitArray const * 16 BitArray const * 0 0 515 0 0 0 0 0 0 0 0 0 0

515 14 BitArray const 0 8832 14 BitArray const 14 BitArray const 0 0 516 0 0 0 0 0 0 0 0 0 0

516 8 BitArray 0 2048 8 BitArray 8 BitArray 0 0 0 0 0 0 0 0 0 0 0 0 210
/**
 * A dynamic array with an unlimited number of bits.
 *
 * This is similar to a BitMask, except it appears to contain an infinite
 * number of bits.  You can use it very much as you would use a BitMask.
 */

517 21 TypedReferenceCount * 0 8576 21 TypedReferenceCount * 21 TypedReferenceCount * 0 0 446 0 0 0 0 0 0 0 0 0 0

518 15 AnimInterface * 0 8576 15 AnimInterface * 15 AnimInterface * 0 0 447 0 0 0 0 0 0 0 0 0 0

519 23 AnimChannelBase const * 0 8576 23 AnimChannelBase const * 23 AnimChannelBase const * 0 0 520 0 0 0 0 0 0 0 0 0 0

520 21 AnimChannelBase const 0 8832 21 AnimChannelBase const 21 AnimChannelBase const 0 0 448 0 0 0 0 0 0 0 0 0 0

521 35 AnimChannel< ACMatrixSwitchType > * 0 8576 35 AnimChannel< ACMatrixSwitchType > * 35 AnimChannel< ACMatrixSwitchType > * 0 0 449 0 0 0 0 0 0 0 0 0 0

522 10 LMatrix4 * 0 8576 10 LMatrix4 * 10 LMatrix4 * 0 0 450 0 0 0 0 0 0 0 0 0 0

523 11 LVecBase3 * 0 8576 11 LVecBase3 * 11 LVecBase3 * 0 0 508 0 0 0 0 0 0 0 0 0 0

524 13 LQuaternion * 0 8576 13 LQuaternion * 13 LQuaternion * 0 0 525 0 0 0 0 0 0 0 0 0 0

525 11 LQuaternion 0 2105344 11 LQuaternion 11 LQuaternion 0 0 526 0 0 0 0 0 0 0 0 0 0

526 12 LQuaternionf 0 2048 12 LQuaternionf 12 LQuaternionf 0 0 0 0 0 0 0 0 0 0 0 0 44
/**
 * This is the base quaternion class
 */

527 41 AnimChannel< ACMatrixSwitchType > const * 0 8576 41 AnimChannel< ACMatrixSwitchType > const * 41 AnimChannel< ACMatrixSwitchType > const * 0 0 528 0 0 0 0 0 0 0 0 0 0

528 39 AnimChannel< ACMatrixSwitchType > const 0 8832 39 AnimChannel< ACMatrixSwitchType > const 39 AnimChannel< ACMatrixSwitchType > const 0 0 449 0 0 0 0 0 0 0 0 0 0

529 35 AnimChannel< ACScalarSwitchType > * 0 8576 35 AnimChannel< ACScalarSwitchType > * 35 AnimChannel< ACScalarSwitchType > * 0 0 453 0 0 0 0 0 0 0 0 0 0

530 41 AnimChannel< ACScalarSwitchType > const * 0 8576 41 AnimChannel< ACScalarSwitchType > const * 41 AnimChannel< ACScalarSwitchType > const * 0 0 531 0 0 0 0 0 0 0 0 0 0

531 39 AnimChannel< ACScalarSwitchType > const 0 8832 39 AnimChannel< ACScalarSwitchType > const 39 AnimChannel< ACScalarSwitchType > const 0 0 453 0 0 0 0 0 0 0 0 0 0

532 26 AnimChannelMatrixDynamic * 0 8576 26 AnimChannelMatrixDynamic * 26 AnimChannelMatrixDynamic * 0 0 455 0 0 0 0 0 0 0 0 0 0

533 16 LMatrix4 const * 0 8576 16 LMatrix4 const * 16 LMatrix4 const * 0 0 468 0 0 0 0 0 0 0 0 0 0

534 32 AnimChannelMatrixDynamic const * 0 8576 32 AnimChannelMatrixDynamic const * 32 AnimChannelMatrixDynamic const * 0 0 535 0 0 0 0 0 0 0 0 0 0

535 30 AnimChannelMatrixDynamic const 0 8832 30 AnimChannelMatrixDynamic const 30 AnimChannelMatrixDynamic const 0 0 455 0 0 0 0 0 0 0 0 0 0

536 27 AnimChannelMatrixXfmTable * 0 8576 27 AnimChannelMatrixXfmTable * 27 AnimChannelMatrixXfmTable * 0 0 456 0 0 0 0 0 0 0 0 0 0

537 4 char 0 8194 4 char 4 char 0 5 0 0 0 0 0 0 0 0 0 0 0

538 21 CPTA_stdfloat const * 0 8576 21 CPTA_stdfloat const * 21 CPTA_stdfloat const * 0 0 539 0 0 0 0 0 0 0 0 0 0

539 19 CPTA_stdfloat const 0 8832 19 CPTA_stdfloat const 19 CPTA_stdfloat const 0 0 540 0 0 0 0 0 0 0 0 0 0

540 13 CPTA_stdfloat 0 2105344 13 CPTA_stdfloat 13 CPTA_stdfloat 0 0 541 0 0 0 0 0 0 0 0 0 0

541 10 CPTA_float 0 2105344 10 CPTA_float 10 CPTA_float 0 0 542 0 0 0 0 0 0 0 0 0 0

542 28 ConstPointerToArray< float > 0 2048 28 ConstPointerToArray< float > 28 ConstPointerToArray< float > 0 0 0 0 0 0 0 0 0 0 0 0 0

543 33 AnimChannelMatrixXfmTable const * 0 8576 33 AnimChannelMatrixXfmTable const * 33 AnimChannelMatrixXfmTable const * 0 0 544 0 0 0 0 0 0 0 0 0 0

544 31 AnimChannelMatrixXfmTable const 0 8832 31 AnimChannelMatrixXfmTable const 31 AnimChannelMatrixXfmTable const 0 0 456 0 0 0 0 0 0 0 0 0 0

545 15 CPTA_stdfloat * 0 8576 15 CPTA_stdfloat * 15 CPTA_stdfloat * 0 0 540 0 0 0 0 0 0 0 0 0 0

546 26 AnimChannelScalarDynamic * 0 8576 26 AnimChannelScalarDynamic * 26 AnimChannelScalarDynamic * 0 0 457 0 0 0 0 0 0 0 0 0 0

547 24 AnimChannelScalarTable * 0 8576 24 AnimChannelScalarTable * 24 AnimChannelScalarTable * 0 0 458 0 0 0 0 0 0 0 0 0 0

548 30 AnimChannelScalarTable const * 0 8576 30 AnimChannelScalarTable const * 30 AnimChannelScalarTable const * 0 0 549 0 0 0 0 0 0 0 0 0 0

549 28 AnimChannelScalarTable const 0 8832 28 AnimChannelScalarTable const 28 AnimChannelScalarTable const 0 0 458 0 0 0 0 0 0 0 0 0 0

550 23 AnimControlCollection * 0 8576 23 AnimControlCollection * 23 AnimControlCollection * 0 0 459 0 0 0 0 0 0 0 0 0 0

551 29 AnimControlCollection const * 0 8576 29 AnimControlCollection const * 29 AnimControlCollection const * 0 0 552 0 0 0 0 0 0 0 0 0 0

552 27 AnimControlCollection const 0 8832 27 AnimControlCollection const 27 AnimControlCollection const 0 0 459 0 0 0 0 0 0 0 0 0 0

553 18 AnimPreloadTable * 0 8576 18 AnimPreloadTable * 18 AnimPreloadTable * 0 0 460 0 0 0 0 0 0 0 0 0 0

554 24 AnimPreloadTable const * 0 8576 24 AnimPreloadTable const * 24 AnimPreloadTable const * 0 0 555 0 0 0 0 0 0 0 0 0 0

555 22 AnimPreloadTable const 0 8832 22 AnimPreloadTable const 22 AnimPreloadTable const 0 0 460 0 0 0 0 0 0 0 0 0 0

556 12 PartSubset * 0 8576 12 PartSubset * 12 PartSubset * 0 0 462 0 0 0 0 0 0 0 0 0 0

557 18 PartSubset const * 0 8576 18 PartSubset const * 18 PartSubset const * 0 0 558 0 0 0 0 0 0 0 0 0 0

558 16 PartSubset const 0 8832 16 PartSubset const 16 PartSubset const 0 0 462 0 0 0 0 0 0 0 0 0 0

559 19 GlobPattern const * 0 8576 19 GlobPattern const * 19 GlobPattern const * 0 0 560 0 0 0 0 0 0 0 0 0 0

560 17 GlobPattern const 0 8832 17 GlobPattern const 17 GlobPattern const 0 0 561 0 0 0 0 0 0 0 0 0 0

561 11 GlobPattern 0 2048 11 GlobPattern 11 GlobPattern 0 0 0 0 0 0 0 0 0 0 0 0 538
/**
 * This class can be used to test for string matches against standard Unix-
 * shell filename globbing conventions.  It serves as a portable standin for
 * the Posix fnmatch() call.
 *
 * A GlobPattern is given a pattern string, which can contain operators like
 * *, ?, and [].  Then it can be tested against any number of candidate
 * strings; for each candidate, it will indicate whether the string matches
 * the pattern or not.  It can be used, for example, to scan a directory for
 * all files matching a particular pattern.
 */

562 23 BindAnimRequest const * 0 8576 23 BindAnimRequest const * 23 BindAnimRequest const * 0 0 563 0 0 0 0 0 0 0 0 0 0

563 21 BindAnimRequest const 0 8832 21 BindAnimRequest const 21 BindAnimRequest const 0 0 463 0 0 0 0 0 0 0 0 0 0

564 17 BindAnimRequest * 0 8576 17 BindAnimRequest * 17 BindAnimRequest * 0 0 463 0 0 0 0 0 0 0 0 0 0

565 16 Filename const * 0 8576 16 Filename const * 16 Filename const * 0 0 566 0 0 0 0 0 0 0 0 0 0

566 14 Filename const 0 8832 14 Filename const 14 Filename const 0 0 567 0 0 0 0 0 0 0 0 0 0

567 8 Filename 0 2048 8 Filename 8 Filename 0 0 0 0 0 0 0 0 0 0 0 0 550
/**
 * The name of a file, such as a texture file or an Egg file.  Stores the full
 * pathname, and includes functions for extracting out the directory prefix
 * part and the file extension and stuff.
 *
 * A Filename is also aware of the mapping between the Unix-like filename
 * convention we use internally, and the local OS's specific filename
 * convention, and it knows how to perform basic OS-specific I/O, like testing
 * for file existence and searching a searchpath, as well as the best way to
 * open an fstream for reading or writing.
 */

568 21 LoaderOptions const * 0 8576 21 LoaderOptions const * 21 LoaderOptions const * 0 0 569 0 0 0 0 0 0 0 0 0 0

569 19 LoaderOptions const 0 8832 19 LoaderOptions const 19 LoaderOptions const 0 0 570 0 0 0 0 0 0 0 0 0 0

570 13 LoaderOptions 0 2048 13 LoaderOptions 13 LoaderOptions 0 0 0 0 0 0 0 0 0 0 0 0 65
/**
 * Specifies parameters that may be passed to the loader.
 */

571 8 Loader * 0 8576 8 Loader * 8 Loader * 0 0 572 0 0 0 0 0 0 0 0 0 0

572 6 Loader 0 2048 6 Loader 6 Loader 0 0 0 0 0 0 0 0 0 0 0 0 503
/**
 * A convenient class for loading models from disk, in bam or egg format (or
 * any of a number of other formats implemented by a LoaderFileType, such as
 * ptloader).
 *
 * This class supports synchronous as well as asynchronous loading.  In
 * asynchronous loading, the model is loaded in the background by a thread,
 * and an event will be generated when the model is available.  If threading
 * is not available, the asynchronous loading interface may be used, but it
 * loads synchronously.
 */

573 18 PartBundle const * 0 8576 18 PartBundle const * 18 PartBundle const * 0 0 574 0 0 0 0 0 0 0 0 0 0

574 16 PartBundle const 0 8832 16 PartBundle const 16 PartBundle const 0 0 465 0 0 0 0 0 0 0 0 0 0

575 22 PartBundleNode const * 0 8576 22 PartBundleNode const * 22 PartBundleNode const * 0 0 576 0 0 0 0 0 0 0 0 0 0

576 20 PartBundleNode const 0 8832 20 PartBundleNode const 20 PartBundleNode const 0 0 470 0 0 0 0 0 0 0 0 0 0

577 24 PartBundleHandle const * 0 8576 24 PartBundleHandle const * 24 PartBundleHandle const * 0 0 578 0 0 0 0 0 0 0 0 0 0

578 22 PartBundleHandle const 0 8832 22 PartBundleHandle const 22 PartBundleHandle const 0 0 473 0 0 0 0 0 0 0 0 0 0

579 22 MovingPartBase const * 0 8576 22 MovingPartBase const * 22 MovingPartBase const * 0 0 580 0 0 0 0 0 0 0 0 0 0

580 20 MovingPartBase const 0 8832 20 MovingPartBase const 20 MovingPartBase const 0 0 475 0 0 0 0 0 0 0 0 0 0

581 40 MovingPart< ACMatrixSwitchType > const * 0 8576 40 MovingPart< ACMatrixSwitchType > const * 40 MovingPart< ACMatrixSwitchType > const * 0 0 582 0 0 0 0 0 0 0 0 0 0

582 38 MovingPart< ACMatrixSwitchType > const 0 8832 38 MovingPart< ACMatrixSwitchType > const 38 MovingPart< ACMatrixSwitchType > const 0 0 477 0 0 0 0 0 0 0 0 0 0

583 40 MovingPart< ACScalarSwitchType > const * 0 8576 40 MovingPart< ACScalarSwitchType > const * 40 MovingPart< ACScalarSwitchType > const * 0 0 584 0 0 0 0 0 0 0 0 0 0

584 38 MovingPart< ACScalarSwitchType > const 0 8832 38 MovingPart< ACScalarSwitchType > const 38 MovingPart< ACScalarSwitchType > const 0 0 479 0 0 0 0 0 0 0 0 0 0

0
10
585 8 children 0 66 438 224 0 0 0 0 223 19 AnimGroup::children 0

586 8 children 0 66 444 252 0 0 0 0 251 19 PartGroup::children 0

587 10 blend_type 0 6 466 387 386 0 0 0 0 22 PartBundle::blend_type 0

588 15 anim_blend_flag 0 6 467 389 388 0 0 0 0 27 PartBundle::anim_blend_flag 0

589 16 frame_blend_flag 0 6 467 391 390 0 0 0 0 28 PartBundle::frame_blend_flag 0

590 10 root_xform 0 6 468 394 392 0 0 0 0 22 PartBundle::root_xform 0

591 5 nodes 0 66 469 397 0 0 0 0 396 17 PartBundle::nodes 0

592 7 bundles 0 66 471 400 0 0 0 0 399 23 PartBundleNode::bundles 0

593 14 bundle_handles 0 66 472 401 0 0 0 0 399 30 PartBundleNode::bundle_handles 0

594 6 bundle 0 6 471 403 404 0 0 0 0 24 PartBundleHandle::bundle 0

7
595 12 get_children 0 223 224 23 AnimGroup::get_children 0

596 12 get_children 0 251 252 23 PartGroup::get_children 0

597 9 get_anims 0 335 336 32 AnimControlCollection::get_anims 0

598 14 get_anim_names 0 335 337 37 AnimControlCollection::get_anim_names 0

599 9 get_nodes 0 396 397 21 PartBundle::get_nodes 0

600 11 get_bundles 0 399 400 27 PartBundleNode::get_bundles 0

601 18 get_bundle_handles 0 399 401 34 PartBundleNode::get_bundle_handles 0

