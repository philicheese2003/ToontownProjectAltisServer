1494874472
3 2
11 libp3device 4 k0F5 12 panda3d.core 
66
70 24 fork_asynchronous_thread 0 4 136 36 ClientBase::fork_asynchronous_thread 0 1 1 314
/**
 * Forks a separate thread to do all the polling of connected devices.  The
 * forked thread will poll after every poll_time seconds has elapsed.  Returns
 * true if the fork was successful, or false otherwise (for instance, because
 * we were already forked, or because asynchronous threads are disabled).
 */
60
bool ClientBase::fork_asynchronous_thread(double poll_time);

71 9 is_forked 0 4 136 21 ClientBase::is_forked 0 1 2 130
/**
 * Returns true if the ClientBase has been forked (and, therefore, poll() does
 * not need to be called), false otherwise.
 */
46
inline bool ClientBase::is_forked(void) const;

72 4 poll 0 4 136 16 ClientBase::poll 0 1 3 183
/**
 * Initiates a poll of the client devices, if we are not forked and if we have
 * not already polled this frame.  Returns true if the poll occurred, or false
 * if it did not.
 */
35
inline bool ClientBase::poll(void);

73 18 get_last_poll_time 0 4 136 30 ClientBase::get_last_poll_time 0 1 4 118
/**
 * Returns the time (according to the global ClockObject's get_real_time()
 * method) of the last device poll.
 */
57
inline double ClientBase::get_last_poll_time(void) const;

74 21 set_coordinate_system 0 4 136 33 ClientBase::set_coordinate_system 0 1 5 138
/**
 * Specifies the coordinate system that all devices associated with this
 * client will operate in.  Normally, this is CS_default.
 */
67
inline void ClientBase::set_coordinate_system(CoordinateSystem cs);

75 21 get_coordinate_system 0 4 136 33 ClientBase::get_coordinate_system 0 1 6 136
/**
 * Returns the coordinate system that all devices associated with this client
 * will operate in.  Normally, this is CS_default.
 */
70
inline CoordinateSystem ClientBase::get_coordinate_system(void) const;

76 14 get_class_type 0 4 136 26 ClientBase::get_class_type 0 1 7 0
51
static TypeHandle ClientBase::get_class_type(void);

77 10 AnalogNode 0 4 138 22 AnalogNode::AnalogNode 0 1 8 10
/**
 *
 */
75
AnalogNode::AnalogNode(ClientBase *client, std::string const &device_name);

78 8 is_valid 0 4 138 20 AnalogNode::is_valid 0 1 9 97
/**
 * Returns true if the AnalogNode is valid and connected to a server, false
 * otherwise.
 */
45
inline bool AnalogNode::is_valid(void) const;

79 16 get_num_controls 0 4 138 28 AnalogNode::get_num_controls 0 1 10 133
/**
 * Returns the number of analog controls known to the AnalogNode.  This number
 * may change as more controls are discovered.
 */
52
inline int AnalogNode::get_num_controls(void) const;

80 17 get_control_state 0 4 138 29 AnalogNode::get_control_state 0 1 11 193
/**
 * Returns the current position of indicated analog control identified by its
 * index number, or 0.0 if the control is unknown.  The normal range of a
 * single control is -1.0 to 1.0.
 */
61
inline double AnalogNode::get_control_state(int index) const;

81 16 is_control_known 0 4 138 28 AnalogNode::is_control_known 0 1 12 153
/**
 * Returns true if the state of the indicated analog control is known, or
 * false if we have never heard anything about this particular control.
 */
58
inline bool AnalogNode::is_control_known(int index) const;

82 10 set_output 0 4 138 22 AnalogNode::set_output 0 1 13 314
/**
 * Causes a particular analog control to be placed in the data graph for the
 * indicated channel.  Normally, a mouse uses channels 0 and 1 for the X and Y
 * information, respectively; channels 0, 1, and 2 are available.  If flip is
 * true, the analog control value will be reversed before outputting it.
 */
70
inline void AnalogNode::set_output(int channel, int index, bool flip);

83 12 clear_output 0 4 138 24 AnalogNode::clear_output 0 1 14 107
/**
 * Removes the output to the data graph associated with the indicated channel.
 * See set_output().
 */
50
inline void AnalogNode::clear_output(int channel);

84 10 get_output 0 4 138 22 AnalogNode::get_output 0 1 15 174
/**
 * Returns the analog control index that is output to the data graph on the
 * indicated channel, or -1 if no control is output on that channel.  See
 * set_output().
 */
53
inline int AnalogNode::get_output(int channel) const;

85 17 is_output_flipped 0 4 138 29 AnalogNode::is_output_flipped 0 1 16 143
/**
 * Returns true if the analog control index that is output to the data graph
 * on the indicated channel is flipped.  See set_output().
 */
61
inline bool AnalogNode::is_output_flipped(int channel) const;

86 14 get_class_type 0 4 138 26 AnalogNode::get_class_type 0 1 17 0
51
static TypeHandle AnalogNode::get_class_type(void);

87 10 ButtonNode 0 4 140 22 ButtonNode::ButtonNode 0 2 18 19 10
/**
 *
 */
136
ButtonNode::ButtonNode(ClientBase *client, std::string const &device_name);
inline ButtonNode::ButtonNode(ButtonNode const &) = default;

88 8 is_valid 0 4 140 20 ButtonNode::is_valid 0 1 20 97
/**
 * Returns true if the ButtonNode is valid and connected to a server, false
 * otherwise.
 */
45
inline bool ButtonNode::is_valid(void) const;

89 15 get_num_buttons 0 4 140 27 ButtonNode::get_num_buttons 0 1 21 283
/**
 * Returns the number of buttons known to the ButtonNode.  This includes those
 * buttons whose state has been seen, as well as buttons that have been
 * associated with a ButtonHandle even if their state is unknown.  This number
 * may change as more buttons are discovered.
 */
51
inline int ButtonNode::get_num_buttons(void) const;

90 14 set_button_map 0 4 140 26 ButtonNode::set_button_map 0 1 22 490
/**
 * Associates the indicated ButtonHandle with the button of the indicated
 * index number.  When the given button index changes state, a corresponding
 * ButtonEvent will be generated with the given ButtonHandle.  Pass
 * ButtonHandle::none() to turn off any association.
 *
 * It is not necessary to call this if you simply want to query the state of
 * the various buttons by index number; this is only necessary in order to
 * generate ButtonEvents when the buttons change state.
 */
71
inline void ButtonNode::set_button_map(int index, ButtonHandle button);

91 14 get_button_map 0 4 140 26 ButtonNode::get_button_map 0 1 23 184
/**
 * Returns the ButtonHandle that was previously associated with the given
 * index number by a call to set_button_map(), or ButtonHandle::none() if no
 * button was associated.
 */
64
inline ButtonHandle ButtonNode::get_button_map(int index) const;

92 16 get_button_state 0 4 140 28 ButtonNode::get_button_state 0 1 24 147
/**
 * Returns true if the indicated button (identified by its index number) is
 * currently known to be down, or false if it is up or unknown.
 */
58
inline bool ButtonNode::get_button_state(int index) const;

93 15 is_button_known 0 4 140 27 ButtonNode::is_button_known 0 1 25 144
/**
 * Returns true if the state of the indicated button is known, or false if we
 * have never heard anything about this particular button.
 */
57
inline bool ButtonNode::is_button_known(int index) const;

94 14 get_class_type 0 4 140 26 ButtonNode::get_class_type 0 1 26 0
51
static TypeHandle ButtonNode::get_class_type(void);

95 8 get_time 0 4 141 21 TrackerData::get_time 0 1 28 180
/**
 * Returns the time at which the position information (pos and orient) are
 * effective.  It is an error to call this if has_time() does not return true.
 * See set_time().
 */
48
inline double TrackerData::get_time(void) const;

96 8 set_time 0 4 141 21 TrackerData::set_time 0 1 27 251
/**
 * Indicates the time at which the position information (pos and orient) are
 * effective.  This is a time elapsed in seconds since some undefined epoch;
 * it may or may not correspond to the clock time indicated in the global
 * ClockObject.
 */
47
inline void TrackerData::set_time(double time);

97 7 get_pos 0 4 141 20 TrackerData::get_pos 0 1 30 168
/**
 * Returns the current position of the tracker.  It is legal to call this if
 * has_pos() returns false; in this case, the position will always be (0, 0,
 * 0).
 */
55
inline LPoint3 const &TrackerData::get_pos(void) const;

98 7 set_pos 0 4 141 20 TrackerData::set_pos 0 1 29 143
/**
 * Indicates the current position of the tracker sensor in space.  The
 * coordinate system of this position is defined by the tracker.
 */
53
inline void TrackerData::set_pos(LPoint3 const &pos);

99 10 get_orient 0 4 141 23 TrackerData::get_orient 0 1 32 182
/**
 * Returns the current orientation of the tracker.  It is legal to call this
 * if has_orient() returns false; in this case, the result is always the
 * identity orientation.
 */
63
inline LOrientation const &TrackerData::get_orient(void) const;

100 10 set_orient 0 4 141 23 TrackerData::set_orient 0 1 31 225
/**
 * Indicates the current orientation of the tracker sensor in space.  The
 * coordinate system of this orientation is defined by the tracker, but should
 * be the same coordinate system as that reflected by set_pos().
 */
64
inline void TrackerData::set_orient(LOrientation const &orient);

101 6 get_dt 0 4 141 19 TrackerData::get_dt 0 1 34 188
/**
 * Returns the amount of elapsed time over which the information (pos and
 * orient) were computed.  It is an error to call this if has_dt() does not
 * return true.  See set_dt().
 */
46
inline double TrackerData::get_dt(void) const;

102 6 set_dt 0 4 141 19 TrackerData::set_dt 0 1 33 259
/**
 * Indicates the amount of elapsed time over which which the information (pos
 * and orient) were computed.  This only makes sense if the information
 * represents velocity or acceleration, rather than position.  This is an
 * elapsed time in seconds.
 */
43
inline void TrackerData::set_dt(double dt);

103 12 ~TrackerData 0 4 141 25 TrackerData::~TrackerData 0 0 0
32
TrackerData::~TrackerData(void);

104 8 DialNode 0 4 149 18 DialNode::DialNode 0 2 35 36 10
/**
 *
 */
126
DialNode::DialNode(ClientBase *client, std::string const &device_name);
inline DialNode::DialNode(DialNode const &) = default;

105 8 is_valid 0 4 149 18 DialNode::is_valid 0 1 37 95
/**
 * Returns true if the DialNode is valid and connected to a server, false
 * otherwise.
 */
43
inline bool DialNode::is_valid(void) const;

106 13 get_num_dials 0 4 149 23 DialNode::get_num_dials 0 1 38 123
/**
 * Returns the number of dial dials known to the DialNode.  This number may
 * change as more dials are discovered.
 */
47
inline int DialNode::get_num_dials(void) const;

107 9 read_dial 0 4 149 19 DialNode::read_dial 0 1 39 216
/**
 * Returns the number of complete revolutions of the dial since the last time
 * read_dial() was called.  This is a destructive operation; it is not
 * possible to read the dial without resetting the counter.
 */
45
inline double DialNode::read_dial(int index);

108 13 is_dial_known 0 4 149 23 DialNode::is_dial_known 0 1 40 145
/**
 * Returns true if the state of the indicated dial dial is known, or false if
 * we have never heard anything about this particular dial.
 */
53
inline bool DialNode::is_dial_known(int index) const;

109 14 get_class_type 0 4 149 24 DialNode::get_class_type 0 1 41 0
49
static TypeHandle DialNode::get_class_type(void);

110 16 MouseAndKeyboard 0 4 150 34 MouseAndKeyboard::MouseAndKeyboard 0 2 42 43 10
/**
 *
 */
175
MouseAndKeyboard::MouseAndKeyboard(GraphicsWindow *window, int device, std::string const &name);
inline MouseAndKeyboard::MouseAndKeyboard(MouseAndKeyboard const &) = default;

111 10 set_source 0 4 150 28 MouseAndKeyboard::set_source 0 1 44 134
/**
 * Redirects the class to get the data from the mouse and keyboard associated
 * with a different window and/or device number.
 */
70
void MouseAndKeyboard::set_source(GraphicsWindow *window, int device);

112 17 get_source_window 0 4 150 35 MouseAndKeyboard::get_source_window 0 1 45 48
/**
 * Returns the associated source window.
 */
76
PointerTo< GraphicsWindow > MouseAndKeyboard::get_source_window(void) const;

113 17 get_source_device 0 4 150 35 MouseAndKeyboard::get_source_device 0 1 46 48
/**
 * Returns the associated source device.
 */
52
int MouseAndKeyboard::get_source_device(void) const;

114 14 get_class_type 0 4 150 32 MouseAndKeyboard::get_class_type 0 1 47 0
57
static TypeHandle MouseAndKeyboard::get_class_type(void);

115 17 ~MouseAndKeyboard 0 4 150 35 MouseAndKeyboard::~MouseAndKeyboard 0 0 0
42
MouseAndKeyboard::~MouseAndKeyboard(void);

116 11 TrackerNode 0 4 151 24 TrackerNode::TrackerNode 0 3 48 49 50 22
/**
 *
 */

/**
 *
 */
196
TrackerNode::TrackerNode(ClientBase *client, std::string const &device_name);
TrackerNode::TrackerNode(ClientTrackerDevice *device);
inline TrackerNode::TrackerNode(TrackerNode const &) = default;

117 8 is_valid 0 4 151 21 TrackerNode::is_valid 0 1 51 98
/**
 * Returns true if the TrackerNode is valid and connected to a server, false
 * otherwise.
 */
46
inline bool TrackerNode::is_valid(void) const;

118 7 get_pos 0 4 151 20 TrackerNode::get_pos 0 1 52 75
/**
 * Returns the current position of the tracker, if it is available.
 */
55
inline LPoint3 const &TrackerNode::get_pos(void) const;

119 10 get_orient 0 4 151 23 TrackerNode::get_orient 0 1 53 78
/**
 * Returns the current orientation of the tracker, if it is available.
 */
63
inline LOrientation const &TrackerNode::get_orient(void) const;

120 13 get_transform 0 4 151 26 TrackerNode::get_transform 0 1 54 96
/**
 * Returns the current position and orientation of the tracker, as a combined
 * matrix.
 */
62
inline LMatrix4 const &TrackerNode::get_transform(void) const;

121 8 get_time 0 4 151 21 TrackerNode::get_time 0 1 55 57
/**
 * Returns the time of the tracker's last update.
 */
48
inline double TrackerNode::get_time(void) const;

122 8 has_time 0 4 151 21 TrackerNode::has_time 0 1 56 51
/**
 * True if this data comes with timestamps.
 */
46
inline bool TrackerNode::has_time(void) const;

123 29 set_tracker_coordinate_system 0 4 151 42 TrackerNode::set_tracker_coordinate_system 0 1 57 257
/**
 * Specifies the coordinate system that the tracker associated with this node
 * will operate in.  Normally, this is set from the ClientBase that's used to
 * create the TrackerNode, so it should not need to be set on an individual
 * tracker basis.
 */
76
inline void TrackerNode::set_tracker_coordinate_system(CoordinateSystem cs);

124 29 get_tracker_coordinate_system 0 4 151 42 TrackerNode::get_tracker_coordinate_system 0 1 58 103
/**
 * Returns the coordinate system that the tracker associated with this node
 * will operate in.
 */
79
inline CoordinateSystem TrackerNode::get_tracker_coordinate_system(void) const;

125 27 set_graph_coordinate_system 0 4 151 40 TrackerNode::set_graph_coordinate_system 0 1 59 165
/**
 * Specifies the coordinate system that the TrackerNode will convert its
 * transform into for passing down the data graph.  Normally, this is
 * CS_default.
 */
74
inline void TrackerNode::set_graph_coordinate_system(CoordinateSystem cs);

126 27 get_graph_coordinate_system 0 4 151 40 TrackerNode::get_graph_coordinate_system 0 1 60 163
/**
 * Returns the coordinate system that the TrackerNode will convert its
 * transform into for passing down the data graph.  Normally, this is
 * CS_default.
 */
77
inline CoordinateSystem TrackerNode::get_graph_coordinate_system(void) const;

127 14 get_class_type 0 4 151 27 TrackerNode::get_class_type 0 1 61 0
52
static TypeHandle TrackerNode::get_class_type(void);

128 12 VirtualMouse 0 4 152 26 VirtualMouse::VirtualMouse 0 2 62 63 10
/**
 *
 */
119
VirtualMouse::VirtualMouse(std::string const &name);
inline VirtualMouse::VirtualMouse(VirtualMouse const &) = default;

129 13 set_mouse_pos 0 4 152 27 VirtualMouse::set_mouse_pos 0 1 64 155
/**
 * Sets the current mouse pixel location, where (0,0) is the upper left, and
 * (width-1, height-1) is the lower right pixel of the virtual window.
 */
47
void VirtualMouse::set_mouse_pos(int x, int y);

130 15 set_window_size 0 4 152 29 VirtualMouse::set_window_size 0 1 65 136
/**
 * Sets the size of the "window" in which the mouse rolls.  This changes the
 * meaning of the values passed to set_mouse_pos().
 */
58
void VirtualMouse::set_window_size(int width, int height);

131 12 set_mouse_on 0 4 152 26 VirtualMouse::set_mouse_on 0 1 66 217
/**
 * Sets whether the mouse should appear to be within the window or not.  If
 * this is true, the mouse is within the window; if false, the mouse is not
 * within the window (and set_mouse_pos() means nothing).
 */
43
void VirtualMouse::set_mouse_on(bool flag);

132 12 press_button 0 4 152 26 VirtualMouse::press_button 0 1 67 167
/**
 * Simulates a mouse or keyboard button being depressed.  This should be
 * followed up by a call to release_button() sometime later (possibly
 * immediately).
 */
53
void VirtualMouse::press_button(ButtonHandle button);

133 14 release_button 0 4 152 28 VirtualMouse::release_button 0 1 68 105
/**
 * Simulates the button being released.  This should follow a previous call to
 * press_button().
 */
55
void VirtualMouse::release_button(ButtonHandle button);

134 14 get_class_type 0 4 152 28 VirtualMouse::get_class_type 0 1 69 0
53
static TypeHandle VirtualMouse::get_class_type(void);

135 13 ~VirtualMouse 0 4 152 27 VirtualMouse::~VirtualMouse 0 0 0
34
VirtualMouse::~VirtualMouse(void);

69
1 0 0 6 3 154 0 0 314 /**
 * Forks a separate thread to do all the polling of connected devices.  The
 * forked thread will poll after every poll_time seconds has elapsed.  Returns
 * true if the fork was successful, or false otherwise (for instance, because
 * we were already forked, or because asynchronous threads are disabled).
 */ 2 4 this 3 153  9 poll_time 1 142  
2 0 0 6 4 154 0 0 130 /**
 * Returns true if the ClientBase has been forked (and, therefore, poll() does
 * not need to be called), false otherwise.
 */ 1 4 this 3 155  
3 0 0 6 5 154 0 0 183 /**
 * Initiates a poll of the client devices, if we are not forked and if we have
 * not already polled this frame.  Returns true if the poll occurred, or false
 * if it did not.
 */ 1 4 this 3 153  
4 0 0 6 6 142 0 0 118 /**
 * Returns the time (according to the global ClockObject's get_real_time()
 * method) of the last device poll.
 */ 1 4 this 3 155  
5 0 0 4 7 158 0 0 138 /**
 * Specifies the coordinate system that all devices associated with this
 * client will operate in.  Normally, this is CS_default.
 */ 2 4 this 3 153  2 cs 1 157  
6 0 0 6 8 157 0 0 136 /**
 * Returns the coordinate system that all devices associated with this client
 * will operate in.  Normally, this is CS_default.
 */ 1 4 this 3 155  
7 0 0 7 9 160 0 0 0 0 
8 0 0 7 12 162 0 0 10 /**
 *
 */ 2 6 client 1 153  11 device_name 1 161  
9 0 0 6 13 154 0 0 97 /**
 * Returns true if the AnalogNode is valid and connected to a server, false
 * otherwise.
 */ 1 4 this 3 163  
10 0 0 6 14 165 0 0 133 /**
 * Returns the number of analog controls known to the AnalogNode.  This number
 * may change as more controls are discovered.
 */ 1 4 this 3 163  
11 0 0 6 15 142 0 0 193 /**
 * Returns the current position of indicated analog control identified by its
 * index number, or 0.0 if the control is unknown.  The normal range of a
 * single control is -1.0 to 1.0.
 */ 2 4 this 3 163  5 index 1 165  
12 0 0 6 16 154 0 0 153 /**
 * Returns true if the state of the indicated analog control is known, or
 * false if we have never heard anything about this particular control.
 */ 2 4 this 3 163  5 index 1 165  
13 0 0 4 17 158 0 0 314 /**
 * Causes a particular analog control to be placed in the data graph for the
 * indicated channel.  Normally, a mouse uses channels 0 and 1 for the X and Y
 * information, respectively; channels 0, 1, and 2 are available.  If flip is
 * true, the analog control value will be reversed before outputting it.
 */ 4 4 this 3 162  7 channel 1 165  5 index 1 165  4 flip 1 154  
14 0 0 4 18 158 0 0 107 /**
 * Removes the output to the data graph associated with the indicated channel.
 * See set_output().
 */ 2 4 this 3 162  7 channel 1 165  
15 0 0 6 19 165 0 0 174 /**
 * Returns the analog control index that is output to the data graph on the
 * indicated channel, or -1 if no control is output on that channel.  See
 * set_output().
 */ 2 4 this 3 163  7 channel 1 165  
16 0 0 6 20 154 0 0 143 /**
 * Returns true if the analog control index that is output to the data graph
 * on the indicated channel is flipped.  See set_output().
 */ 2 4 this 3 163  7 channel 1 165  
17 0 0 7 21 160 0 0 0 0 
18 0 0 7 23 168 0 0 0 1 6 param0 0 166  
19 0 0 7 23 168 0 0 10 /**
 *
 */ 2 6 client 1 153  11 device_name 1 161  
20 0 0 6 24 154 0 0 97 /**
 * Returns true if the ButtonNode is valid and connected to a server, false
 * otherwise.
 */ 1 4 this 3 166  
21 0 0 6 25 165 0 0 283 /**
 * Returns the number of buttons known to the ButtonNode.  This includes those
 * buttons whose state has been seen, as well as buttons that have been
 * associated with a ButtonHandle even if their state is unknown.  This number
 * may change as more buttons are discovered.
 */ 1 4 this 3 166  
22 0 0 4 26 158 0 0 490 /**
 * Associates the indicated ButtonHandle with the button of the indicated
 * index number.  When the given button index changes state, a corresponding
 * ButtonEvent will be generated with the given ButtonHandle.  Pass
 * ButtonHandle::none() to turn off any association.
 *
 * It is not necessary to call this if you simply want to query the state of
 * the various buttons by index number; this is only necessary in order to
 * generate ButtonEvents when the buttons change state.
 */ 3 4 this 3 168  5 index 1 165  6 button 1 169  
23 0 0 7 27 169 0 0 184 /**
 * Returns the ButtonHandle that was previously associated with the given
 * index number by a call to set_button_map(), or ButtonHandle::none() if no
 * button was associated.
 */ 2 4 this 3 166  5 index 1 165  
24 0 0 6 28 154 0 0 147 /**
 * Returns true if the indicated button (identified by its index number) is
 * currently known to be down, or false if it is up or unknown.
 */ 2 4 this 3 166  5 index 1 165  
25 0 0 6 29 154 0 0 144 /**
 * Returns true if the state of the indicated button is known, or false if we
 * have never heard anything about this particular button.
 */ 2 4 this 3 166  5 index 1 165  
26 0 0 7 30 160 0 0 0 0 
27 0 0 4 35 158 0 0 251 /**
 * Indicates the time at which the position information (pos and orient) are
 * effective.  This is a time elapsed in seconds since some undefined epoch;
 * it may or may not correspond to the clock time indicated in the global
 * ClockObject.
 */ 2 4 this 3 171  4 time 1 142  
28 0 0 6 34 142 0 0 180 /**
 * Returns the time at which the position information (pos and orient) are
 * effective.  It is an error to call this if has_time() does not return true.
 * See set_time().
 */ 1 4 this 3 172  
29 0 0 4 41 158 0 0 143 /**
 * Indicates the current position of the tracker sensor in space.  The
 * coordinate system of this position is defined by the tracker.
 */ 2 4 this 3 171  3 pos 1 174  
30 0 0 6 40 174 0 0 168 /**
 * Returns the current position of the tracker.  It is legal to call this if
 * has_pos() returns false; in this case, the position will always be (0, 0,
 * 0).
 */ 1 4 this 3 172  
31 0 0 4 47 158 0 0 225 /**
 * Indicates the current orientation of the tracker sensor in space.  The
 * coordinate system of this orientation is defined by the tracker, but should
 * be the same coordinate system as that reflected by set_pos().
 */ 2 4 this 3 171  6 orient 1 175  
32 0 0 6 46 175 0 0 182 /**
 * Returns the current orientation of the tracker.  It is legal to call this
 * if has_orient() returns false; in this case, the result is always the
 * identity orientation.
 */ 1 4 this 3 172  
33 0 0 4 50 158 0 0 259 /**
 * Indicates the amount of elapsed time over which which the information (pos
 * and orient) were computed.  This only makes sense if the information
 * represents velocity or acceleration, rather than position.  This is an
 * elapsed time in seconds.
 */ 2 4 this 3 171  2 dt 1 142  
34 0 0 6 49 142 0 0 188 /**
 * Returns the amount of elapsed time over which the information (pos and
 * orient) were computed.  It is an error to call this if has_dt() does not
 * return true.  See set_dt().
 */ 1 4 this 3 172  
35 0 0 7 53 176 0 0 10 /**
 *
 */ 2 6 client 1 153  11 device_name 1 161  
36 0 0 7 53 176 0 0 0 1 6 param0 0 177  
37 0 0 6 54 154 0 0 95 /**
 * Returns true if the DialNode is valid and connected to a server, false
 * otherwise.
 */ 1 4 this 3 177  
38 0 0 6 55 165 0 0 123 /**
 * Returns the number of dial dials known to the DialNode.  This number may
 * change as more dials are discovered.
 */ 1 4 this 3 177  
39 0 0 6 56 142 0 0 216 /**
 * Returns the number of complete revolutions of the dial since the last time
 * read_dial() was called.  This is a destructive operation; it is not
 * possible to read the dial without resetting the counter.
 */ 2 4 this 3 176  5 index 1 165  
40 0 0 6 57 154 0 0 145 /**
 * Returns true if the state of the indicated dial dial is known, or false if
 * we have never heard anything about this particular dial.
 */ 2 4 this 3 177  5 index 1 165  
41 0 0 7 58 160 0 0 0 0 
42 0 0 7 60 181 115 0 10 /**
 *
 */ 3 6 window 1 179  6 device 1 165  4 name 1 161  
43 0 0 7 60 181 115 0 0 1 6 param0 0 182  
44 0 0 4 61 158 0 0 134 /**
 * Redirects the class to get the data from the mouse and keyboard associated
 * with a different window and/or device number.
 */ 3 4 this 3 181  6 window 1 179  6 device 1 165  
45 0 0 7 62 179 0 0 48 /**
 * Returns the associated source window.
 */ 1 4 this 3 182  
46 0 0 6 63 165 0 0 48 /**
 * Returns the associated source device.
 */ 1 4 this 3 182  
47 0 0 7 64 160 0 0 0 0 
48 0 0 7 67 184 0 0 10 /**
 *
 */ 2 6 client 1 153  11 device_name 1 161  
49 0 0 7 67 184 0 0 10 /**
 *
 */ 1 6 device 1 185  
50 0 0 7 67 184 0 0 0 1 6 param0 0 187  
51 0 0 6 68 154 0 0 98 /**
 * Returns true if the TrackerNode is valid and connected to a server, false
 * otherwise.
 */ 1 4 this 3 187  
52 0 0 6 69 174 0 0 75 /**
 * Returns the current position of the tracker, if it is available.
 */ 1 4 this 3 187  
53 0 0 6 70 175 0 0 78 /**
 * Returns the current orientation of the tracker, if it is available.
 */ 1 4 this 3 187  
54 0 0 6 71 189 0 0 96 /**
 * Returns the current position and orientation of the tracker, as a combined
 * matrix.
 */ 1 4 this 3 187  
55 0 0 6 72 142 0 0 57 /**
 * Returns the time of the tracker's last update.
 */ 1 4 this 3 187  
56 0 0 6 73 154 0 0 51 /**
 * True if this data comes with timestamps.
 */ 1 4 this 3 187  
57 0 0 4 74 158 0 0 257 /**
 * Specifies the coordinate system that the tracker associated with this node
 * will operate in.  Normally, this is set from the ClientBase that's used to
 * create the TrackerNode, so it should not need to be set on an individual
 * tracker basis.
 */ 2 4 this 3 184  2 cs 1 157  
58 0 0 6 75 157 0 0 103 /**
 * Returns the coordinate system that the tracker associated with this node
 * will operate in.
 */ 1 4 this 3 187  
59 0 0 4 76 158 0 0 165 /**
 * Specifies the coordinate system that the TrackerNode will convert its
 * transform into for passing down the data graph.  Normally, this is
 * CS_default.
 */ 2 4 this 3 184  2 cs 1 157  
60 0 0 6 77 157 0 0 163 /**
 * Returns the coordinate system that the TrackerNode will convert its
 * transform into for passing down the data graph.  Normally, this is
 * CS_default.
 */ 1 4 this 3 187  
61 0 0 7 78 160 0 0 0 0 
62 0 0 7 80 195 135 0 0 1 6 param0 0 193  
63 0 0 7 80 195 135 0 10 /**
 *
 */ 1 4 name 1 161  
64 0 0 4 81 158 0 0 155 /**
 * Sets the current mouse pixel location, where (0,0) is the upper left, and
 * (width-1, height-1) is the lower right pixel of the virtual window.
 */ 3 4 this 3 195  1 x 1 165  1 y 1 165  
65 0 0 4 82 158 0 0 136 /**
 * Sets the size of the "window" in which the mouse rolls.  This changes the
 * meaning of the values passed to set_mouse_pos().
 */ 3 4 this 3 195  5 width 1 165  6 height 1 165  
66 0 0 4 83 158 0 0 217 /**
 * Sets whether the mouse should appear to be within the window or not.  If
 * this is true, the mouse is within the window; if false, the mouse is not
 * within the window (and set_mouse_pos() means nothing).
 */ 2 4 this 3 195  4 flag 1 154  
67 0 0 4 84 158 0 0 167 /**
 * Simulates a mouse or keyboard button being depressed.  This should be
 * followed up by a call to release_button() sometime later (possibly
 * immediately).
 */ 2 4 this 3 195  6 button 1 169  
68 0 0 4 85 158 0 0 105 /**
 * Simulates the button being released.  This should follow a previous call to
 * press_button().
 */ 2 4 this 3 195  6 button 1 169  
69 0 0 7 86 160 0 0 0 0 
60
136 10 ClientBase 0 75777 10 ClientBase 10 ClientBase 0 0 0 0 0 0 7 70 71 72 73 74 75 76 0 0 1 0 137 0 0 0 0 307
/**
 * An abstract base class for a family of client device interfaces--including
 * trackers, buttons, dials, and other analog inputs.
 *
 * This provides a common interface to connect to such devices and extract
 * their data; it is used by TrackerNode etc.  to put these devices in the
 * data graph.
 */

137 19 TypedReferenceCount 0 2049 19 TypedReferenceCount 19 TypedReferenceCount 0 0 0 0 0 0 0 0 0 0 0 0 410
/**
 * A base class for things which need to inherit from both TypedObject and
 * from ReferenceCount.  It's convenient to define this intermediate base
 * class instead of multiply inheriting from the two classes each time they
 * are needed, so that we can sensibly pass around pointers to things which
 * are both TypedObjects and ReferenceCounters.
 *
 * See also TypedObject for detailed instructions.
 */

138 10 AnalogNode 0 75777 10 AnalogNode 10 AnalogNode 0 0 0 1 77 0 0 9 78 79 80 81 82 83 84 85 86 0 0 1 0 139 0 0 0 0 712
/**
 * This is the primary interface to analog controls like sliders and joysticks
 * associated with a ClientBase.  This creates a node that connects to the
 * named analog device, if it exists, and provides hooks to the user to read
 * the state of any of the sequentially numbered controls associated with that
 * device.
 *
 * Each control can return a value ranging from -1 to 1, reflecting the
 * current position of the control within its total range of motion.
 *
 * The user may choose up to two analog controls to place on the data graph as
 * the two channels of an xy datagram, similarly to the way a mouse places its
 * position data.  In this way, an AnalogNode may be used in place of a mouse.
 */

139 8 DataNode 0 2049 8 DataNode 8 DataNode 0 0 0 0 0 0 0 0 0 0 0 0 422
/**
 * The fundamental type of node for the data graph.  The DataNode class is
 * itself primarily intended as an abstract class; it defines no inputs and no
 * outputs.  Most kinds of data nodes will derive from this to specify the
 * inputs and outputs in the constructor.
 *
 * DataNode does not attempt to cycle its data with a PipelineCycler.  The
 * data graph is intended to be used only within a single thread.
 */

140 10 ButtonNode 0 75777 10 ButtonNode 10 ButtonNode 0 0 0 1 87 0 0 7 88 89 90 91 92 93 94 0 0 1 0 139 0 0 0 0 527
/**
 * This is the primary interface to on/off button devices associated with a
 * ClientBase.  This creates a node that connects to the named button device,
 * if it exists, and provides hooks to the user to read the state of any of
 * the sequentially numbered buttons associated with that device.
 *
 * It also can associate an arbitrary ButtonHandle with each button; when
 * buttons are associated with ButtonHandles, this node will put appropriate
 * up and down events on the data graph for each button state change.
 */

141 11 TrackerData 0 141313 11 TrackerData 11 TrackerData 0 0 0 0 103 4 196 197 198 199 0 0 0 0 0 0 64
/**
 * Stores the kinds of data that a tracker might output.
 */

142 6 double 0 8194 6 double 6 double 0 3 0 0 0 0 0 0 0 0 0 0 0

143 13 LPoint3 const 0 8832 13 LPoint3 const 13 LPoint3 const 0 0 144 0 0 0 0 0 0 0 0 0 0

144 7 LPoint3 0 2105344 7 LPoint3 7 LPoint3 0 0 145 0 0 0 0 0 0 0 0 0 0

145 8 LPoint3f 0 2048 8 LPoint3f 8 LPoint3f 0 0 0 0 0 0 0 0 0 0 0 0 337
/**
 * This is a three-component point in space (as opposed to a three-component
 * vector, which represents a direction and a distance).  Some of the methods
 * are slightly different between LPoint3 and LVector3; in particular,
 * subtraction of two points yields a vector, while addition of a vector and a
 * point yields a point.
 */

146 18 LOrientation const 0 8832 18 LOrientation const 18 LOrientation const 0 0 147 0 0 0 0 0 0 0 0 0 0

147 12 LOrientation 0 2105344 12 LOrientation 12 LOrientation 0 0 148 0 0 0 0 0 0 0 0 0 0

148 13 LOrientationf 0 2048 13 LOrientationf 13 LOrientationf 0 0 0 0 0 0 0 0 0 0 0 0 65
/**
 * This is a unit quaternion representing an orientation.
 */

149 8 DialNode 0 75777 8 DialNode 8 DialNode 0 0 0 1 104 0 0 5 105 106 107 108 109 0 0 1 0 139 0 0 0 0 511
/**
 * This is the primary interface to infinite dial type devices associated with
 * a ClientBase.  This creates a node that connects to the named dial device,
 * if it exists, and provides hooks to the user to read the state of any of
 * the sequentially numbered dial controls associated with that device.
 *
 * A dial is a rotating device that does not have stops--it can keep rotating
 * any number of times.  Therefore it does not have a specific position at any
 * given time, unlike an AnalogDevice.
 */

150 16 MouseAndKeyboard 0 141313 16 MouseAndKeyboard 16 MouseAndKeyboard 0 0 0 1 110 115 0 4 111 112 113 114 0 0 1 0 139 0 0 0 0 772
/**
 * Reads the mouse and/or keyboard data sent from a GraphicsWindow, and
 * transmits it down the data graph.
 *
 * The mouse and keyboard devices are bundled together into one device here,
 * because they interrelate so much.  A mouse might be constrained by the
 * holding down of the shift key, for instance, or the clicking of the mouse
 * button might be handled in much the same way as a keyboard key.
 *
 * Mouse data is sent down the data graph as an x,y position as well as the
 * set of buttons currently being held down; keyboard data is sent down as a
 * set of keypress events in an EventDataTransition.  To throw these events to
 * the system, you must attach an EventThrower to the MouseAndKeyboard object;
 * otherwise, the events will be discarded.
 */

151 11 TrackerNode 0 75777 11 TrackerNode 11 TrackerNode 0 0 0 1 116 0 0 11 117 118 119 120 121 122 123 124 125 126 127 0 0 1 0 139 0 0 0 0 226
/**
 * This is the primary interface to a Tracker object associated with a
 * ClientBase.  It reads the position and orientation information from the
 * tracker and makes it available as a transformation on the data graph.
 */

152 12 VirtualMouse 0 141313 12 VirtualMouse 12 VirtualMouse 0 0 0 1 128 135 0 6 129 130 131 132 133 134 0 0 1 0 139 0 0 0 0 291
/**
 * Poses as a MouseAndKeyboard object in the datagraph, but accepts input from
 * user calls, rather than reading the actual mouse and keyboard from an input
 * device.  The user can write high-level code to put the mouse wherever
 * he/she wants, and to insert keypresses on demand.
 */

153 12 ClientBase * 0 8576 12 ClientBase * 12 ClientBase * 0 0 136 0 0 0 0 0 0 0 0 0 0

154 4 bool 0 8194 4 bool 4 bool 0 4 0 0 0 0 0 0 0 0 0 0 0

155 18 ClientBase const * 0 8576 18 ClientBase const * 18 ClientBase const * 0 0 156 0 0 0 0 0 0 0 0 0 0

156 16 ClientBase const 0 8832 16 ClientBase const 16 ClientBase const 0 0 136 0 0 0 0 0 0 0 0 0 0

157 16 CoordinateSystem 0 532480 16 CoordinateSystem 16 CoordinateSystem 0 0 0 0 0 0 0 0 0 0 6 10 CS_default 10 CS_default 210
// The CS_default entry does not refer to a particular coordinate system,
// but rather to the value stored in default_coordinate_system, which in
// turn is loaded from the config variable "coordinate-system".
0 12 CS_zup_right 12 CS_zup_right 0
1 12 CS_yup_right 12 CS_yup_right 0
2 11 CS_zup_left 11 CS_zup_left 0
3 11 CS_yup_left 11 CS_yup_left 0
4 10 CS_invalid 10 CS_invalid 156
// CS_invalid is not a coordinate system at all.  It can be used in user-
// input processing code to indicate a contradictory coordinate system
// request.
5 0 0

158 4 void 0 8194 4 void 4 void 0 6 0 0 0 0 0 0 0 0 0 0 0

159 10 TypeHandle 0 2048 10 TypeHandle 10 TypeHandle 0 0 0 0 0 0 0 0 0 0 0 0 732
/**
 * TypeHandle is the identifier used to differentiate C++ class types.  Any
 * C++ classes that inherit from some base class, and must be differentiated
 * at run time, should store a static TypeHandle object that can be queried
 * through a static member function named get_class_type().  Most of the time,
 * it is also desirable to inherit from TypedObject, which provides some
 * virtual functions to return the TypeHandle for a particular instance.
 *
 * At its essence, a TypeHandle is simply a unique identifier that is assigned
 * by the TypeRegistry.  The TypeRegistry stores a tree of TypeHandles, so
 * that ancestry of a particular type may be queried, and the type name may be
 * retrieved for run-time display.
 */

160 12 TypeHandle * 0 8576 12 TypeHandle * 12 TypeHandle * 0 0 159 0 0 0 0 0 0 0 0 0 0

161 13 atomic string 0 2 13 atomic string 13 atomic string 0 7 0 0 0 0 0 0 0 0 0 0 0

162 12 AnalogNode * 0 8576 12 AnalogNode * 12 AnalogNode * 0 0 138 0 0 0 0 0 0 0 0 0 0

163 18 AnalogNode const * 0 8576 18 AnalogNode const * 18 AnalogNode const * 0 0 164 0 0 0 0 0 0 0 0 0 0

164 16 AnalogNode const 0 8832 16 AnalogNode const 16 AnalogNode const 0 0 138 0 0 0 0 0 0 0 0 0 0

165 3 int 0 8194 3 int 3 int 0 1 0 0 0 0 0 0 0 0 0 0 0

166 18 ButtonNode const * 0 8576 18 ButtonNode const * 18 ButtonNode const * 0 0 167 0 0 0 0 0 0 0 0 0 0

167 16 ButtonNode const 0 8832 16 ButtonNode const 16 ButtonNode const 0 0 140 0 0 0 0 0 0 0 0 0 0

168 12 ButtonNode * 0 8576 12 ButtonNode * 12 ButtonNode * 0 0 140 0 0 0 0 0 0 0 0 0 0

169 14 ButtonHandle * 0 8576 14 ButtonHandle * 14 ButtonHandle * 0 0 170 0 0 0 0 0 0 0 0 0 0

170 12 ButtonHandle 0 2048 12 ButtonHandle 12 ButtonHandle 0 0 0 0 0 0 0 0 0 0 0 0 162
/**
 * A ButtonHandle represents a single button from any device, including
 * keyboard buttons and mouse buttons (but see KeyboardButton and
 * MouseButton).
 */

171 13 TrackerData * 0 8576 13 TrackerData * 13 TrackerData * 0 0 141 0 0 0 0 0 0 0 0 0 0

172 19 TrackerData const * 0 8576 19 TrackerData const * 19 TrackerData const * 0 0 173 0 0 0 0 0 0 0 0 0 0

173 17 TrackerData const 0 8832 17 TrackerData const 17 TrackerData const 0 0 141 0 0 0 0 0 0 0 0 0 0

174 15 LPoint3 const * 0 8576 15 LPoint3 const * 15 LPoint3 const * 0 0 143 0 0 0 0 0 0 0 0 0 0

175 20 LOrientation const * 0 8576 20 LOrientation const * 20 LOrientation const * 0 0 146 0 0 0 0 0 0 0 0 0 0

176 10 DialNode * 0 8576 10 DialNode * 10 DialNode * 0 0 149 0 0 0 0 0 0 0 0 0 0

177 16 DialNode const * 0 8576 16 DialNode const * 16 DialNode const * 0 0 178 0 0 0 0 0 0 0 0 0 0

178 14 DialNode const 0 8832 14 DialNode const 14 DialNode const 0 0 149 0 0 0 0 0 0 0 0 0 0

179 16 GraphicsWindow * 0 8576 16 GraphicsWindow * 16 GraphicsWindow * 0 0 180 0 0 0 0 0 0 0 0 0 0

180 14 GraphicsWindow 0 2048 14 GraphicsWindow 14 GraphicsWindow 0 0 0 0 0 0 0 0 0 0 0 0 122
/**
 * A window, fullscreen or on a desktop, into which a graphics device sends
 * its output for interactive display.
 */

181 18 MouseAndKeyboard * 0 8576 18 MouseAndKeyboard * 18 MouseAndKeyboard * 0 0 150 0 0 0 0 0 0 0 0 0 0

182 24 MouseAndKeyboard const * 0 8576 24 MouseAndKeyboard const * 24 MouseAndKeyboard const * 0 0 183 0 0 0 0 0 0 0 0 0 0

183 22 MouseAndKeyboard const 0 8832 22 MouseAndKeyboard const 22 MouseAndKeyboard const 0 0 150 0 0 0 0 0 0 0 0 0 0

184 13 TrackerNode * 0 8576 13 TrackerNode * 13 TrackerNode * 0 0 151 0 0 0 0 0 0 0 0 0 0

185 21 ClientTrackerDevice * 0 8576 21 ClientTrackerDevice * 21 ClientTrackerDevice * 0 0 186 0 0 0 0 0 0 0 0 0 0

186 19 ClientTrackerDevice 0 1050624 19 ClientTrackerDevice 19 ClientTrackerDevice 0 0 0 0 0 0 0 0 0 0 0 0 120
/**
 * A device, attached to the ClientBase by a TrackerNode, that records the
 * data from a single tracker device.
 */

187 19 TrackerNode const * 0 8576 19 TrackerNode const * 19 TrackerNode const * 0 0 188 0 0 0 0 0 0 0 0 0 0

188 17 TrackerNode const 0 8832 17 TrackerNode const 17 TrackerNode const 0 0 151 0 0 0 0 0 0 0 0 0 0

189 16 LMatrix4 const * 0 8576 16 LMatrix4 const * 16 LMatrix4 const * 0 0 190 0 0 0 0 0 0 0 0 0 0

190 14 LMatrix4 const 0 8832 14 LMatrix4 const 14 LMatrix4 const 0 0 191 0 0 0 0 0 0 0 0 0 0

191 8 LMatrix4 0 2105344 8 LMatrix4 8 LMatrix4 0 0 192 0 0 0 0 0 0 0 0 0 0

192 9 LMatrix4f 0 2048 9 LMatrix4f 9 LMatrix4f 0 0 0 0 0 0 0 0 0 0 0 0 45
/**
 * This is a 4-by-4 transform matrix.
 */

193 20 VirtualMouse const * 0 8576 20 VirtualMouse const * 20 VirtualMouse const * 0 0 194 0 0 0 0 0 0 0 0 0 0

194 18 VirtualMouse const 0 8832 18 VirtualMouse const 18 VirtualMouse const 0 0 152 0 0 0 0 0 0 0 0 0 0

195 14 VirtualMouse * 0 8576 14 VirtualMouse * 14 VirtualMouse * 0 0 152 0 0 0 0 0 0 0 0 0 0

0
4
196 4 time 0 6 142 95 96 0 0 0 0 17 TrackerData::time 0

197 3 pos 0 6 143 97 98 0 0 0 0 16 TrackerData::pos 0

198 6 orient 0 6 146 99 100 0 0 0 0 19 TrackerData::orient 0

199 2 dt 0 6 142 101 102 0 0 0 0 15 TrackerData::dt 0

0
