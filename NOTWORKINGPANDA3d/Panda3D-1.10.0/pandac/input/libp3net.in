1494874301
3 2
8 libp3net 4 7xrj 12 panda3d.core 
175
179 5 clear 0 4 355 34 PointerToBase< Connection >::clear 0 1 9 0
53
inline void PointerToBase< Connection >::clear(void);

180 6 output 0 4 355 35 PointerToBase< Connection >::output 0 1 10 0
61
void PointerToBase< Connection >::output(ostream &out) const;

181 9 PointerTo 0 4 354 34 PointerTo< Connection >::PointerTo 0 3 1 2 3 0
219
constexpr PointerTo< Connection >::PointerTo(void) noexcept = default;
inline PointerTo< Connection >::PointerTo(Connection *ptr) noexcept;
inline PointerTo< Connection >::PointerTo(PointerTo< Connection > const &copy);

182 1 p 0 4 354 26 PointerTo< Connection >::p 0 1 4 289
// If your base class is a derivative of TypedObject, you might want to use
// the DCAST macro defined in typedObject.h instead, e.g.  DCAST(MyType,
// ptr).  This provides a clean downcast that doesn't require .p() or any
// double-casting, and it can be run-time checked for correctness.
70
constexpr Connection *PointerTo< Connection >::p(void) const noexcept;

183 10 operator = 0 4 354 35 PointerTo< Connection >::operator = 0 2 5 6 0
191
inline PointerTo< Connection > &PointerTo< Connection >::operator =(Connection *ptr);
inline PointerTo< Connection > &PointerTo< Connection >::operator =(PointerTo< Connection > const &copy);

184 7 is_null 0 4 354 32 PointerTo< Connection >::is_null 0 1 7 0
57
inline bool PointerTo< Connection >::is_null(void) const;

185 5 clear 0 4 354 30 PointerTo< Connection >::clear 0 1 8 0
49
inline void PointerTo< Connection >::clear(void);

186 10 ~PointerTo 0 4 354 35 PointerTo< Connection >::~PointerTo 0 0 0
42
PointerTo< Connection >::~PointerTo(void);

187 10 NetAddress 0 4 357 22 NetAddress::NetAddress 0 3 11 12 13 271
/**
 * Constructs an unspecified address.
 */

/**
 * Constructs an address from a given Socket_Address.  Normally, this
 * constructor should not be used by user code; instead, create a default
 * NetAddress and use one of the set_*() functions to set up an address.
 */
142
NetAddress::NetAddress(void);
NetAddress::NetAddress(Socket_Address const &addr);
inline NetAddress::NetAddress(NetAddress const &) = default;

188 7 set_any 0 4 357 19 NetAddress::set_any 0 1 14 179
/**
 * Sets the address up to refer to a particular port, but not to any
 * particular IP.  Returns true if successful, false otherwise (currently,
 * this only returns true).
 */
35
bool NetAddress::set_any(int port);

189 13 set_localhost 0 4 357 25 NetAddress::set_localhost 0 1 15 75
/**
 * Sets the address up to refer to a particular port, on this host.
 */
41
bool NetAddress::set_localhost(int port);

190 13 set_broadcast 0 4 357 25 NetAddress::set_broadcast 0 1 16 53
/**
 * Sets the address to the broadcast address.
 */
41
bool NetAddress::set_broadcast(int port);

191 8 set_host 0 4 357 20 NetAddress::set_host 0 1 17 141
/**
 * Sets the address up to refer to a particular port on a particular host.
 * Returns true if the hostname is known, false otherwise.
 */
65
bool NetAddress::set_host(std::string const &hostname, int port);

192 5 clear 0 4 357 17 NetAddress::clear 0 1 18 54
/**
 * Resets the NetAddress to its initial state.
 */
29
void NetAddress::clear(void);

193 8 get_port 0 4 357 20 NetAddress::get_port 0 1 19 64
/**
 * Returns the port number to which this address refers.
 */
37
int NetAddress::get_port(void) const;

194 8 set_port 0 4 357 20 NetAddress::set_port 0 1 20 73
/**
 * Resets the port number without otherwise changing the address.
 */
36
void NetAddress::set_port(int port);

195 13 get_ip_string 0 4 357 25 NetAddress::get_ip_string 0 1 21 86
/**
 * Returns the IP address to which this address refers, formatted as a string.
 */
50
std::string NetAddress::get_ip_string(void) const;

196 6 is_any 0 4 357 18 NetAddress::is_any 0 1 22 58
/**
 * Returns true if the IP address has only zeroes.
 */
36
bool NetAddress::is_any(void) const;

197 6 get_ip 0 4 357 18 NetAddress::get_ip 0 1 23 158
/**
 * Returns the IP address to which this address refers, as a 32-bit integer,
 * in host byte order.
 * @deprecated  Does not work with IPv6 addresses.
 */
40
uint32_t NetAddress::get_ip(void) const;

198 16 get_ip_component 0 4 357 28 NetAddress::get_ip_component 0 1 24 213
/**
 * Returns the nth 8-bit component of the IP address.  An IP address has four
 * components; component 0 is the first (leftmost), and component 3 is the
 * last (rightmost) in the dotted number convention.
 */
50
uint8_t NetAddress::get_ip_component(int n) const;

199 8 get_addr 0 4 357 20 NetAddress::get_addr 0 1 25 55
/**
 * Returns the Socket_Address for this address.
 */
55
Socket_Address const &NetAddress::get_addr(void) const;

200 6 output 0 4 357 18 NetAddress::output 0 1 26 10
/**
 *
 */
44
void NetAddress::output(ostream &out) const;

201 8 get_hash 0 4 357 20 NetAddress::get_hash 0 1 27 10
/**
 *
 */
45
std::size_t NetAddress::get_hash(void) const;

202 11 operator == 0 4 357 23 NetAddress::operator == 0 1 28 0
60
bool NetAddress::operator ==(NetAddress const &other) const;

203 11 operator != 0 4 357 23 NetAddress::operator != 0 1 29 0
60
bool NetAddress::operator !=(NetAddress const &other) const;

204 11 ~NetAddress 0 4 357 23 NetAddress::~NetAddress 0 0 0
30
NetAddress::~NetAddress(void);

205 10 Connection 0 4 358 22 Connection::Connection 0 1 30 177
/**
 * Creates a connection.  Normally this constructor should not be used
 * directly by user code; use one of the methods in ConnectionManager to make
 * a new connection.
 */
70
Connection::Connection(ConnectionManager *manager, Socket_IP *socket);

206 11 get_address 0 4 358 23 Connection::get_address 0 1 31 83
/**
 * Returns the address bound to this connection, if it is a TCP connection.
 */
47
NetAddress Connection::get_address(void) const;

207 11 get_manager 0 4 358 23 Connection::get_manager 0 1 32 92
/**
 * Returns a pointer to the ConnectionManager object that serves this
 * connection.
 */
55
ConnectionManager *Connection::get_manager(void) const;

208 10 get_socket 0 4 358 22 Connection::get_socket 0 1 33 70
/**
 * Returns the internal Socket_IP that defines the connection.
 */
46
Socket_IP *Connection::get_socket(void) const;

209 15 set_collect_tcp 0 4 358 27 Connection::set_collect_tcp 0 1 34 719
/**
 * Enables or disables "collect-tcp" mode.  In this mode, individual TCP
 * packets are not sent immediately, but rather they are collected together
 * and accumulated to be sent periodically as one larger TCP packet.  This
 * cuts down on overhead from the TCP/IP protocol, especially if many small
 * packets need to be sent on the same connection, but it introduces
 * additional latency (since packets must be held before they can be sent).
 *
 * See set_collect_tcp_interval() to specify the interval of time for which to
 * hold packets before sending them.
 *
 * If you enable this mode, you may also need to periodically call
 * consider_flush() to flush the queue if no packets have been sent recently.
 */
51
void Connection::set_collect_tcp(bool collect_tcp);

210 15 get_collect_tcp 0 4 358 27 Connection::get_collect_tcp 0 1 35 85
/**
 * Returns the current setting of "collect-tcp" mode.  See set_collect_tcp().
 */
45
bool Connection::get_collect_tcp(void) const;

211 24 set_collect_tcp_interval 0 4 358 36 Connection::set_collect_tcp_interval 0 1 36 231
/**
 * Specifies the interval in time, in seconds, for which to hold TCP packets
 * before sending all of the recently received packets at once.  This only has
 * meaning if "collect-tcp" mode is enabled; see set_collect_tcp().
 */
59
void Connection::set_collect_tcp_interval(double interval);

212 24 get_collect_tcp_interval 0 4 358 36 Connection::get_collect_tcp_interval 0 1 37 229
/**
 * Returns the interval in time, in seconds, for which to hold TCP packets
 * before sending all of the recently received packets at once.  This only has
 * meaning if "collect-tcp" mode is enabled; see set_collect_tcp().
 */
56
double Connection::get_collect_tcp_interval(void) const;

213 14 consider_flush 0 4 358 26 Connection::consider_flush 0 1 38 153
/**
 * Sends the most recently queued TCP datagram(s) if enough time has elapsed.
 * This only has meaning if set_collect_tcp() has been set to true.
 */
38
bool Connection::consider_flush(void);

214 5 flush 0 4 358 17 Connection::flush 0 1 39 131
/**
 * Sends the most recently queued TCP datagram(s) now.  This only has meaning
 * if set_collect_tcp() has been set to true.
 */
29
bool Connection::flush(void);

215 10 set_linger 0 4 358 22 Connection::set_linger 0 1 40 467
// Socket options.  void set_nonblock(bool flag);

/**
 * Sets the time to linger on close if data is present.  If flag is false,
 * when you close a socket with data available the system attempts to deliver
 * the data to the peer (the default behavior).  If flag is false but time is
 * zero, the system discards any undelivered data when you close the socket.
 * If flag is false but time is nonzero, the system waits up to time seconds
 * to deliver the data.
 */
52
void Connection::set_linger(bool flag, double time);

216 14 set_reuse_addr 0 4 358 26 Connection::set_reuse_addr 0 1 41 55
/**
 * Sets whether local address reuse is allowed.
 */
43
void Connection::set_reuse_addr(bool flag);

217 14 set_keep_alive 0 4 358 26 Connection::set_keep_alive 0 1 42 93
/**
 * Sets whether the connection is periodically tested to see if it is still
 * alive.
 */
43
void Connection::set_keep_alive(bool flag);

218 20 set_recv_buffer_size 0 4 358 32 Connection::set_recv_buffer_size 0 1 43 57
/**
 * Sets the size of the receive buffer, in bytes.
 */
48
void Connection::set_recv_buffer_size(int size);

219 20 set_send_buffer_size 0 4 358 32 Connection::set_send_buffer_size 0 1 44 54
/**
 * Sets the size of the send buffer, in bytes.
 */
48
void Connection::set_send_buffer_size(int size);

220 19 set_ip_time_to_live 0 4 358 31 Connection::set_ip_time_to_live 0 1 45 32
/**
 * Sets IP time-to-live.
 */
46
void Connection::set_ip_time_to_live(int ttl);

221 22 set_ip_type_of_service 0 4 358 34 Connection::set_ip_type_of_service 0 1 46 50
/**
 * Sets IP type-of-service and precedence.
 */
49
void Connection::set_ip_type_of_service(int tos);

222 12 set_no_delay 0 4 358 24 Connection::set_no_delay 0 1 47 116
/**
 * If flag is true, this disables the Nagle algorithm, and prevents delaying
 * of send to coalesce packets.
 */
41
void Connection::set_no_delay(bool flag);

223 15 set_max_segment 0 4 358 27 Connection::set_max_segment 0 1 48 41
/**
 * Sets the maximum segment size.
 */
43
void Connection::set_max_segment(int size);

224 17 ~ConnectionReader 0 6 360 35 ConnectionReader::~ConnectionReader 0 0 10
/**
 *
 */
50
virtual ConnectionReader::~ConnectionReader(void);

225 14 add_connection 0 4 360 32 ConnectionReader::add_connection 0 1 49 504
/**
 * Adds a new socket to the list of sockets the ConnectionReader will monitor.
 * A datagram that comes in on any of the monitored sockets will be reported.
 * In the case of a ConnectionListener, this adds a new rendezvous socket; any
 * activity on any of the monitored sockets will cause a connection to be
 * accepted.
 *
 * The return value is true if the connection was added, false if it was
 * already there.
 *
 * add_connection() is thread-safe, and may be called at will by any thread.
 */
62
bool ConnectionReader::add_connection(Connection *connection);

226 17 remove_connection 0 4 360 35 ConnectionReader::remove_connection 0 1 50 264
/**
 * Removes a socket from the list of sockets being monitored.  Returns true if
 * the socket was correctly removed, false if it was not on the list in the
 * first place.
 *
 * remove_connection() is thread-safe, and may be called at will by any
 * thread.
 */
65
bool ConnectionReader::remove_connection(Connection *connection);

227 16 is_connection_ok 0 4 360 34 ConnectionReader::is_connection_ok 0 1 51 345
/**
 * Returns true if the indicated connection has been added to the
 * ConnectionReader and is being monitored properly, false if it is not known,
 * or if there was some error condition detected on the connection.  (If there
 * was an error condition, normally the ConnectionManager would have been
 * informed and closed the connection.)
 */
64
bool ConnectionReader::is_connection_ok(Connection *connection);

228 4 poll 0 4 360 22 ConnectionReader::poll 0 1 52 328
/**
 * Explicitly polls the available sockets to see if any of them have any
 * noise.  This function does nothing unless this is a polling-type
 * ConnectionReader, i.e.  it was created with zero threads (and is_polling()
 * will return true).
 *
 * It is not necessary to call this explicitly for a QueuedConnectionReader.
 */
34
void ConnectionReader::poll(void);

229 11 get_manager 0 4 360 29 ConnectionReader::get_manager 0 1 53 98
/**
 * Returns a pointer to the ConnectionManager object that serves this
 * ConnectionReader.
 */
61
ConnectionManager *ConnectionReader::get_manager(void) const;

230 10 is_polling 0 4 360 28 ConnectionReader::is_polling 0 1 54 83
/**
 * Returns true if the reader is a polling reader, i.e.  it has no threads.
 */
53
inline bool ConnectionReader::is_polling(void) const;

231 15 get_num_threads 0 4 360 33 ConnectionReader::get_num_threads 0 1 55 84
/**
 * Returns the number of threads the ConnectionReader has been created with.
 */
50
int ConnectionReader::get_num_threads(void) const;

232 12 set_raw_mode 0 4 360 30 ConnectionReader::set_raw_mode 0 1 56 314
/**
 * Sets the ConnectionReader into raw mode (or turns off raw mode).  In raw
 * mode, datagram headers are not expected; instead, all the data available on
 * the pipe is treated as a single datagram.
 *
 * This is similar to set_tcp_header_size(0), except that it also turns off
 * headers for UDP packets.
 */
47
void ConnectionReader::set_raw_mode(bool mode);

233 12 get_raw_mode 0 4 360 30 ConnectionReader::get_raw_mode 0 1 57 81
/**
 * Returns the current setting of the raw mode flag.  See set_raw_mode().
 */
48
bool ConnectionReader::get_raw_mode(void) const;

234 19 set_tcp_header_size 0 4 360 37 ConnectionReader::set_tcp_header_size 0 1 58 270
/**
 * Sets the header size of TCP packets.  At the present, legal values for this
 * are 0, 2, or 4; this specifies the number of bytes to use encode the
 * datagram length at the start of each TCP datagram.  Sender and receiver
 * must independently agree on this.
 */
64
void ConnectionReader::set_tcp_header_size(int tcp_header_size);

235 19 get_tcp_header_size 0 4 360 37 ConnectionReader::get_tcp_header_size 0 1 59 86
/**
 * Returns the current setting of TCP header size.  See set_tcp_header_size().
 */
54
int ConnectionReader::get_tcp_header_size(void) const;

236 8 shutdown 0 4 360 26 ConnectionReader::shutdown 0 1 60 146
/**
 * Terminates all threads cleanly.  Normally this is only called by the
 * destructor, but it may be called explicitly before destruction.
 */
38
void ConnectionReader::shutdown(void);

237 19 ~ConnectionListener 0 4 361 39 ConnectionListener::~ConnectionListener 0 0 0
46
ConnectionListener::~ConnectionListener(void);

238 11 NetDatagram 0 4 362 24 NetDatagram::NetDatagram 0 3 61 62 63 130
/**
 * Constructs an empty datagram.
 */

/**
 * Constructs a datagram from an existing block of data.
 */

/**
 *
 */

/**
 *
 */
192
NetDatagram::NetDatagram(void);
NetDatagram::NetDatagram(void const *data, std::size_t size);
NetDatagram::NetDatagram(Datagram const &copy);
NetDatagram::NetDatagram(NetDatagram const &copy);

239 10 operator = 0 4 362 23 NetDatagram::operator = 0 2 64 65 0
106
void NetDatagram::operator =(Datagram const &copy);
void NetDatagram::operator =(NetDatagram const &copy);

240 14 set_connection 0 4 362 27 NetDatagram::set_connection 0 1 66 72
/**
 * Specifies the socket to which the datagram should be written.
 */
76
void NetDatagram::set_connection(PointerTo< Connection > const &connection);

241 14 get_connection 0 4 362 27 NetDatagram::get_connection 0 1 67 111
/**
 * Retrieves the socket from which the datagram was read, or to which it is
 * scheduled to be written.
 */
64
PointerTo< Connection > NetDatagram::get_connection(void) const;

242 11 set_address 0 4 362 24 NetDatagram::set_address 0 1 68 67
/**
 * Specifies the host to which the datagram should be sent.
 */
57
void NetDatagram::set_address(NetAddress const &address);

243 11 get_address 0 4 362 24 NetDatagram::get_address 0 1 69 106
/**
 * Retrieves the host from which the datagram was read, or to which it is
 * scheduled to be sent.
 */
55
NetAddress const &NetDatagram::get_address(void) const;

244 14 get_class_type 0 4 362 27 NetDatagram::get_class_type 0 1 70 0
52
static TypeHandle NetDatagram::get_class_type(void);

245 12 ~NetDatagram 0 4 362 25 NetDatagram::~NetDatagram 0 0 0
32
NetDatagram::~NetDatagram(void);

246 17 ConnectionManager 0 4 364 36 ConnectionManager::ConnectionManager 0 1 71 10
/**
 *
 */
43
ConnectionManager::ConnectionManager(void);

247 18 ~ConnectionManager 0 6 364 37 ConnectionManager::~ConnectionManager 0 0 10
/**
 *
 */
52
virtual ConnectionManager::~ConnectionManager(void);

248 19 open_UDP_connection 0 4 364 38 ConnectionManager::open_UDP_connection 0 2 72 73 1047
/**
 * Opens a socket for sending and/or receiving UDP packets.  If the port
 * number is greater than zero, the UDP connection will be opened for
 * listening on the indicated port; otherwise, it will be useful only for
 * sending.
 *
 * Use a ConnectionReader and ConnectionWriter to handle the actual
 * communication.
 */

/**
 * Opens a socket for sending and/or receiving UDP packets.  If the port
 * number is greater than zero, the UDP connection will be opened for
 * listening on the indicated port; otherwise, it will be useful only for
 * sending.
 *
 * This variant accepts both a hostname and port to listen on a particular
 * interface; if the hostname is empty, all interfaces will be available,
 * both IPv4 and IPv6.
 *
 * If for_broadcast is true, this UDP connection will be configured to send
 * and/or receive messages on the broadcast address (255.255.255.255);
 * otherwise, these messages may be automatically filtered by the OS.
 *
 * Use a ConnectionReader and ConnectionWriter to handle the actual
 * communication.
 */
218
PointerTo< Connection > ConnectionManager::open_UDP_connection(uint16_t port = 0);
PointerTo< Connection > ConnectionManager::open_UDP_connection(std::string const &hostname, uint16_t port, bool for_broadcast = false);

249 26 open_TCP_server_rendezvous 0 4 364 45 ConnectionManager::open_TCP_server_rendezvous 0 3 74 75 76 1436
/**
 * Creates a socket to be used as a rendezvous socket for a server to listen
 * for TCP connections.  The socket returned by this call should only be added
 * to a ConnectionListener (not to a generic ConnectionReader).
 *
 * This variant of this method accepts a single port, and will listen to that
 * port on all available interfaces, both IPv4 and IPv6.
 *
 * backlog is the maximum length of the queue of pending connections.
 */

/**
 * Creates a socket to be used as a rendezvous socket for a server to listen
 * for TCP connections.  The socket returned by this call should only be added
 * to a ConnectionListener (not to a generic ConnectionReader).
 *
 * This variant of this method accepts a "hostname", which is usually just an
 * IP address in dotted notation, and a port number.  It will listen on the
 * interface indicated by the IP address.  If the IP address is empty string,
 * it will listen on all interfaces.
 *
 * backlog is the maximum length of the queue of pending connections.
 */

/**
 * Creates a socket to be used as a rendezvous socket for a server to listen
 * for TCP connections.  The socket returned by this call should only be added
 * to a ConnectionListener (not to a generic ConnectionReader).
 *
 * This variant of this method accepts a NetAddress, which allows you to
 * specify a specific interface to listen to.
 *
 * backlog is the maximum length of the queue of pending connections.
 */
337
PointerTo< Connection > ConnectionManager::open_TCP_server_rendezvous(uint16_t port, int backlog);
PointerTo< Connection > ConnectionManager::open_TCP_server_rendezvous(std::string const &hostname, uint16_t port, int backlog);
PointerTo< Connection > ConnectionManager::open_TCP_server_rendezvous(NetAddress const &address, int backlog);

250 26 open_TCP_client_connection 0 4 364 45 ConnectionManager::open_TCP_client_connection 0 2 77 78 323
/**
 * Attempts to establish a TCP client connection to a server at the indicated
 * address.  If the connection is not established within timeout_ms
 * milliseconds, a null connection is returned.
 */

/**
 * This is a shorthand version of the function to directly establish
 * communications to a named host and port.
 */
244
PointerTo< Connection > ConnectionManager::open_TCP_client_connection(NetAddress const &address, int timeout_ms);
PointerTo< Connection > ConnectionManager::open_TCP_client_connection(std::string const &hostname, uint16_t port, int timeout_ms);

251 16 close_connection 0 4 364 35 ConnectionManager::close_connection 0 1 79 693
/**
 * Terminates a UDP or TCP socket previously opened.  This also removes it
 * from any associated ConnectionReader or ConnectionListeners.
 *
 * The socket itself may not be immediately closed--it will not be closed
 * until all outstanding pointers to it are cleared, including any pointers
 * remaining in NetDatagrams recently received from the socket.
 *
 * The return value is true if the connection was marked to be closed, or
 * false if close_connection() had already been called (or the connection did
 * not belong to this ConnectionManager).  In neither case can you infer
 * anything about whether the connection has *actually* been closed yet based
 * on the return value.
 */
84
bool ConnectionManager::close_connection(PointerTo< Connection > const &connection);

252 16 wait_for_readers 0 4 364 35 ConnectionManager::wait_for_readers 0 1 80 664
/**
 * Blocks the process for timeout number of seconds, or until any data is
 * available on any of the non-threaded ConnectionReaders or
 * ConnectionListeners, whichever comes first.  The return value is true if
 * there is data available (but you have to iterate through all readers to
 * find it), or false if the timeout occurred without any data.
 *
 * If the timeout value is negative, this will block forever or until data is
 * available.
 *
 * This only works if all ConnectionReaders and ConnectionListeners are non-
 * threaded.  If any threaded ConnectionReaders are part of the
 * ConnectionManager, the timeout value is implicitly treated as 0.
 */
57
bool ConnectionManager::wait_for_readers(double timeout);

253 13 get_host_name 0 4 364 32 ConnectionManager::get_host_name 0 1 81 145
/**
 * Returns the name of this particular machine on the network, if available,
 * or the empty string if the hostname cannot be determined.
 */
58
static std::string ConnectionManager::get_host_name(void);

254 8 get_name 0 4 365 38 ConnectionManager::Interface::get_name 0 1 86 0
70
std::string const &ConnectionManager::Interface::get_name(void) const;

255 15 get_mac_address 0 4 365 45 ConnectionManager::Interface::get_mac_address 0 1 87 0
77
std::string const &ConnectionManager::Interface::get_mac_address(void) const;

256 6 has_ip 0 4 365 36 ConnectionManager::Interface::has_ip 0 1 88 0
54
bool ConnectionManager::Interface::has_ip(void) const;

257 6 get_ip 0 4 365 36 ConnectionManager::Interface::get_ip 0 1 89 0
67
NetAddress const &ConnectionManager::Interface::get_ip(void) const;

258 11 has_netmask 0 4 365 41 ConnectionManager::Interface::has_netmask 0 1 90 0
59
bool ConnectionManager::Interface::has_netmask(void) const;

259 11 get_netmask 0 4 365 41 ConnectionManager::Interface::get_netmask 0 1 91 0
72
NetAddress const &ConnectionManager::Interface::get_netmask(void) const;

260 13 has_broadcast 0 4 365 43 ConnectionManager::Interface::has_broadcast 0 1 92 0
61
bool ConnectionManager::Interface::has_broadcast(void) const;

261 13 get_broadcast 0 4 365 43 ConnectionManager::Interface::get_broadcast 0 1 93 0
74
NetAddress const &ConnectionManager::Interface::get_broadcast(void) const;

262 7 has_p2p 0 4 365 37 ConnectionManager::Interface::has_p2p 0 1 94 0
55
bool ConnectionManager::Interface::has_p2p(void) const;

263 7 get_p2p 0 4 365 37 ConnectionManager::Interface::get_p2p 0 1 95 0
68
NetAddress const &ConnectionManager::Interface::get_p2p(void) const;

264 6 output 0 4 365 36 ConnectionManager::Interface::output 0 1 96 10
/**
 *
 */
62
void ConnectionManager::Interface::output(ostream &out) const;

265 9 Interface 0 4 365 39 ConnectionManager::Interface::Interface 0 1 85 0
95
inline ConnectionManager::Interface::Interface(ConnectionManager::Interface const &) = default;

266 10 ~Interface 0 4 365 40 ConnectionManager::Interface::~Interface 0 0 0
47
ConnectionManager::Interface::~Interface(void);

267 15 scan_interfaces 0 4 364 34 ConnectionManager::scan_interfaces 0 1 82 258
/**
 * Repopulates the list reported by get_num_interface()/get_interface().  It
 * is not necessary to call this explicitly, unless you want to re-determine
 * the connected interfaces (for instance, if you suspect the hardware has
 * recently changed).
 */
46
void ConnectionManager::scan_interfaces(void);

268 18 get_num_interfaces 0 4 364 37 ConnectionManager::get_num_interfaces 0 1 83 140
/**
 * This returns the number of usable network interfaces detected on this
 * machine.  See scan_interfaces() to repopulate this list.
 */
56
std::size_t ConnectionManager::get_num_interfaces(void);

269 13 get_interface 0 4 364 32 ConnectionManager::get_interface 0 1 84 127
/**
 * Returns the nth usable network interface detected on this machine.
 * See scan_interfaces() to repopulate this list.
 */
84
ConnectionManager::Interface const &ConnectionManager::get_interface(std::size_t n);

270 16 ConnectionWriter 0 4 369 34 ConnectionWriter::ConnectionWriter 0 1 97 224
/**
 * Creates a new ConnectionWriter with the indicated number of threads to
 * handle output.
 *
 * If num_threads is 0, all datagrams will be sent immediately instead of
 * queueing for later transmission by a thread.
 */
123
ConnectionWriter::ConnectionWriter(ConnectionManager *manager, int num_threads, std::string const &thread_name = string());

271 17 ~ConnectionWriter 0 4 369 35 ConnectionWriter::~ConnectionWriter 0 0 10
/**
 *
 */
42
ConnectionWriter::~ConnectionWriter(void);

272 18 set_max_queue_size 0 4 369 36 ConnectionWriter::set_max_queue_size 0 1 98 192
/**
 * Limits the number of packets that may be pending on the outbound queue.
 * This only has an effect when using threads; if num_threads is 0, then all
 * packets are sent immediately.
 */
56
void ConnectionWriter::set_max_queue_size(int max_size);

273 18 get_max_queue_size 0 4 369 36 ConnectionWriter::get_max_queue_size 0 1 99 98
/**
 * Returns the maximum size the queue is allowed to grow to.  See
 * set_max_queue_size().
 */
53
int ConnectionWriter::get_max_queue_size(void) const;

274 22 get_current_queue_size 0 4 369 40 ConnectionWriter::get_current_queue_size 0 1 100 61
/**
 * Returns the current number of things in the queue.
 */
57
int ConnectionWriter::get_current_queue_size(void) const;

275 4 send 0 4 369 22 ConnectionWriter::send 0 2 101 102 1230
/**
 * Enqueues a datagram for transmittal on the indicated socket.  Since the
 * host address is not specified with this form, this function should only be
 * used for sending TCP packets.  Use the other send() method for sending UDP
 * packets.
 *
 * Returns true if successful, false if there was an error.  In the normal,
 * threaded case, this function only returns false if the send queue is
 * filled; it's impossible to detect a transmission error at this point.
 *
 * If block is true, this will not return false if the send queue is filled;
 * instead, it will wait until there is space available.
 */

/**
 * Enqueues a datagram for transmittal on the indicated socket.  This form of
 * the function allows the specification of a destination host address, and so
 * is appropriate for UDP packets.  Use the other send() method for sending
 * TCP packets.
 *
 * Returns true if successful, false if there was an error.  In the normal,
 * threaded case, this function only returns false if the send queue is
 * filled; it's impossible to detect a transmission error at this point.
 *
 * If block is true, this will not return false if the send queue is filled;
 * instead, it will wait until there is space available.
 */
262
bool ConnectionWriter::send(Datagram const &datagram, PointerTo< Connection > const &connection, bool block = false);
bool ConnectionWriter::send(Datagram const &datagram, PointerTo< Connection > const &connection, NetAddress const &address, bool block = false);

276 16 is_valid_for_udp 0 4 369 34 ConnectionWriter::is_valid_for_udp 0 1 103 105
/**
 * Returns true if the datagram is small enough to be sent over a UDP packet,
 * false otherwise.
 */
72
bool ConnectionWriter::is_valid_for_udp(Datagram const &datagram) const;

277 11 get_manager 0 4 369 29 ConnectionWriter::get_manager 0 1 104 98
/**
 * Returns a pointer to the ConnectionManager object that serves this
 * ConnectionWriter.
 */
61
ConnectionManager *ConnectionWriter::get_manager(void) const;

278 12 is_immediate 0 4 369 30 ConnectionWriter::is_immediate 0 1 105 86
/**
 * Returns true if the writer is an immediate writer, i.e.  it has no threads.
 */
48
bool ConnectionWriter::is_immediate(void) const;

279 15 get_num_threads 0 4 369 33 ConnectionWriter::get_num_threads 0 1 106 84
/**
 * Returns the number of threads the ConnectionWriter has been created with.
 */
50
int ConnectionWriter::get_num_threads(void) const;

280 12 set_raw_mode 0 4 369 30 ConnectionWriter::set_raw_mode 0 1 107 455
/**
 * Sets the ConnectionWriter into raw mode (or turns off raw mode).  In raw
 * mode, datagrams are not sent along with their headers; the bytes in the
 * datagram are simply sent down the pipe.
 *
 * Setting the ConnectionWriter to raw mode must be done with care.  This can
 * only be done when the matching ConnectionReader is also set to raw mode, or
 * when the ConnectionWriter is communicating to a process that does not
 * expect datagrams.
 */
47
void ConnectionWriter::set_raw_mode(bool mode);

281 12 get_raw_mode 0 4 369 30 ConnectionWriter::get_raw_mode 0 1 108 81
/**
 * Returns the current setting of the raw mode flag.  See set_raw_mode().
 */
48
bool ConnectionWriter::get_raw_mode(void) const;

282 19 set_tcp_header_size 0 4 369 37 ConnectionWriter::set_tcp_header_size 0 1 109 270
/**
 * Sets the header size of TCP packets.  At the present, legal values for this
 * are 0, 2, or 4; this specifies the number of bytes to use encode the
 * datagram length at the start of each TCP datagram.  Sender and receiver
 * must independently agree on this.
 */
64
void ConnectionWriter::set_tcp_header_size(int tcp_header_size);

283 19 get_tcp_header_size 0 4 369 37 ConnectionWriter::get_tcp_header_size 0 1 110 86
/**
 * Returns the current setting of TCP header size.  See set_tcp_header_size().
 */
54
int ConnectionWriter::get_tcp_header_size(void) const;

284 8 shutdown 0 4 369 26 ConnectionWriter::shutdown 0 1 111 156
/**
 * Stops all the threads and cleans them up.  This is called automatically by
 * the destructor, but it may be called explicitly before destruction.
 */
38
void ConnectionWriter::shutdown(void);

285 27 upcast_to_DatagramGenerator 0 12 370 49 DatagramGeneratorNet::upcast_to_DatagramGenerator 0 1 116 53
upcast from DatagramGeneratorNet to DatagramGenerator
75
DatagramGenerator *DatagramGeneratorNet::upcast_to_DatagramGenerator(void);

286 32 downcast_to_DatagramGeneratorNet 0 12 371 51 DatagramGenerator::downcast_to_DatagramGeneratorNet 0 1 117 55
downcast from DatagramGenerator to DatagramGeneratorNet
80
DatagramGeneratorNet *DatagramGenerator::downcast_to_DatagramGeneratorNet(void);

287 26 upcast_to_ConnectionReader 0 12 370 48 DatagramGeneratorNet::upcast_to_ConnectionReader 0 1 118 52
upcast from DatagramGeneratorNet to ConnectionReader
73
ConnectionReader *DatagramGeneratorNet::upcast_to_ConnectionReader(void);

288 32 downcast_to_DatagramGeneratorNet 0 12 360 50 ConnectionReader::downcast_to_DatagramGeneratorNet 0 1 119 54
downcast from ConnectionReader to DatagramGeneratorNet
79
DatagramGeneratorNet *ConnectionReader::downcast_to_DatagramGeneratorNet(void);

289 18 set_max_queue_size 0 4 372 44 QueuedReturn< Datagram >::set_max_queue_size 0 1 122 0
64
void QueuedReturn< Datagram >::set_max_queue_size(int max_size);

290 18 get_max_queue_size 0 4 372 44 QueuedReturn< Datagram >::get_max_queue_size 0 1 123 0
61
int QueuedReturn< Datagram >::get_max_queue_size(void) const;

291 22 get_current_queue_size 0 4 372 48 QueuedReturn< Datagram >::get_current_queue_size 0 1 124 0
65
int QueuedReturn< Datagram >::get_current_queue_size(void) const;

292 17 get_overflow_flag 0 4 372 43 QueuedReturn< Datagram >::get_overflow_flag 0 1 125 0
61
bool QueuedReturn< Datagram >::get_overflow_flag(void) const;

293 19 reset_overflow_flag 0 4 372 45 QueuedReturn< Datagram >::reset_overflow_flag 0 1 126 0
57
void QueuedReturn< Datagram >::reset_overflow_flag(void);

294 31 upcast_to_QueuedReturn_Datagram 0 12 370 53 DatagramGeneratorNet::upcast_to_QueuedReturn_Datagram 0 1 120 60
upcast from DatagramGeneratorNet to QueuedReturn< Datagram >
86
QueuedReturn< Datagram > *DatagramGeneratorNet::upcast_to_QueuedReturn_Datagram(void);

295 32 downcast_to_DatagramGeneratorNet 0 12 372 58 QueuedReturn< Datagram >::downcast_to_DatagramGeneratorNet 0 1 121 62
downcast from QueuedReturn< Datagram > to DatagramGeneratorNet
87
DatagramGeneratorNet *QueuedReturn< Datagram >::downcast_to_DatagramGeneratorNet(void);

296 20 DatagramGeneratorNet 0 4 370 42 DatagramGeneratorNet::DatagramGeneratorNet 0 1 112 243
/**
 * Creates a new DatagramGeneratorNet with the indicated number of threads to
 * handle requests.  Normally num_threads should be either 0 or 1 to guarantee
 * that datagrams are generated in the same order in which they were received.
 */
88
DatagramGeneratorNet::DatagramGeneratorNet(ConnectionManager *manager, int num_threads);

297 21 ~DatagramGeneratorNet 0 6 370 43 DatagramGeneratorNet::~DatagramGeneratorNet 0 0 10
/**
 *
 */
58
virtual DatagramGeneratorNet::~DatagramGeneratorNet(void);

298 12 get_datagram 0 6 370 34 DatagramGeneratorNet::get_datagram 0 1 113 189
// Inherited from DatagramGenerator

/**
 * Reads the next datagram from the stream.  Blocks until a datagram is
 * available.  Returns true on success, false on stream closed or error.
 */
64
virtual bool DatagramGeneratorNet::get_datagram(Datagram &data);

299 6 is_eof 0 6 370 28 DatagramGeneratorNet::is_eof 0 1 114 137
/**
 * Returns true if the stream has been closed normally.  This test may only be
 * made after a call to get_datagram() has failed.
 */
48
virtual bool DatagramGeneratorNet::is_eof(void);

300 8 is_error 0 6 370 30 DatagramGeneratorNet::is_error 0 1 115 61
/**
 * Returns true if the stream has an error condition.
 */
50
virtual bool DatagramGeneratorNet::is_error(void);

301 22 upcast_to_DatagramSink 0 12 373 39 DatagramSinkNet::upcast_to_DatagramSink 0 1 133 43
upcast from DatagramSinkNet to DatagramSink
60
DatagramSink *DatagramSinkNet::upcast_to_DatagramSink(void);

302 27 downcast_to_DatagramSinkNet 0 12 374 41 DatagramSink::downcast_to_DatagramSinkNet 0 1 134 45
downcast from DatagramSink to DatagramSinkNet
65
DatagramSinkNet *DatagramSink::downcast_to_DatagramSinkNet(void);

303 26 upcast_to_ConnectionWriter 0 12 373 43 DatagramSinkNet::upcast_to_ConnectionWriter 0 1 135 47
upcast from DatagramSinkNet to ConnectionWriter
68
ConnectionWriter *DatagramSinkNet::upcast_to_ConnectionWriter(void);

304 27 downcast_to_DatagramSinkNet 0 12 369 45 ConnectionWriter::downcast_to_DatagramSinkNet 0 1 136 49
downcast from ConnectionWriter to DatagramSinkNet
69
DatagramSinkNet *ConnectionWriter::downcast_to_DatagramSinkNet(void);

305 15 DatagramSinkNet 0 4 373 32 DatagramSinkNet::DatagramSinkNet 0 1 127 233
/**
 * Creates a new DatagramSinkNet with the indicated number of threads to
 * handle writing.  Normally num_threads should be either 0 or 1 to guarantee
 * that datagrams are delivered in the same order in which they were sent.
 */
78
DatagramSinkNet::DatagramSinkNet(ConnectionManager *manager, int num_threads);

306 10 set_target 0 4 373 27 DatagramSinkNet::set_target 0 1 128 80
/**
 * Specifies the Connection that will receive all future Datagrams sent.
 */
64
inline void DatagramSinkNet::set_target(Connection *connection);

307 10 get_target 0 4 373 27 DatagramSinkNet::get_target 0 1 129 115
/**
 * Returns the current target Connection, or NULL if the target has not yet
 * been set.  See set_target().
 */
59
inline Connection *DatagramSinkNet::get_target(void) const;

308 12 put_datagram 0 6 373 29 DatagramSinkNet::put_datagram 0 1 130 187
// Inherited from DatagramSink

/**
 * Sends the given datagram to the target.  Returns true on success, false if
 * there is an error.  Blocks if necessary until the target is ready.
 */
65
virtual bool DatagramSinkNet::put_datagram(Datagram const &data);

309 8 is_error 0 6 373 25 DatagramSinkNet::is_error 0 1 131 110
/**
 * Returns true if there is an error on the target connection, or if the
 * target has never been set.
 */
45
virtual bool DatagramSinkNet::is_error(void);

310 5 flush 0 6 373 22 DatagramSinkNet::flush 0 1 132 90
/**
 * Ensures that all datagrams previously written will be visible on the
 * stream.
 */
42
virtual void DatagramSinkNet::flush(void);

311 16 ~DatagramSinkNet 0 4 373 33 DatagramSinkNet::~DatagramSinkNet 0 0 0
40
DatagramSinkNet::~DatagramSinkNet(void);

312 28 upcast_to_ConnectionListener 0 12 375 54 QueuedConnectionListener::upcast_to_ConnectionListener 0 1 141 58
upcast from QueuedConnectionListener to ConnectionListener
81
ConnectionListener *QueuedConnectionListener::upcast_to_ConnectionListener(void);

313 36 downcast_to_QueuedConnectionListener 0 12 361 56 ConnectionListener::downcast_to_QueuedConnectionListener 0 1 142 60
downcast from ConnectionListener to QueuedConnectionListener
89
QueuedConnectionListener *ConnectionListener::downcast_to_QueuedConnectionListener(void);

314 18 set_max_queue_size 0 4 376 58 QueuedReturn< ConnectionListenerData >::set_max_queue_size 0 1 145 0
78
void QueuedReturn< ConnectionListenerData >::set_max_queue_size(int max_size);

315 18 get_max_queue_size 0 4 376 58 QueuedReturn< ConnectionListenerData >::get_max_queue_size 0 1 146 0
75
int QueuedReturn< ConnectionListenerData >::get_max_queue_size(void) const;

316 22 get_current_queue_size 0 4 376 62 QueuedReturn< ConnectionListenerData >::get_current_queue_size 0 1 147 0
79
int QueuedReturn< ConnectionListenerData >::get_current_queue_size(void) const;

317 17 get_overflow_flag 0 4 376 57 QueuedReturn< ConnectionListenerData >::get_overflow_flag 0 1 148 0
75
bool QueuedReturn< ConnectionListenerData >::get_overflow_flag(void) const;

318 19 reset_overflow_flag 0 4 376 59 QueuedReturn< ConnectionListenerData >::reset_overflow_flag 0 1 149 0
71
void QueuedReturn< ConnectionListenerData >::reset_overflow_flag(void);

319 45 upcast_to_QueuedReturn_ConnectionListenerData 0 12 375 71 QueuedConnectionListener::upcast_to_QueuedReturn_ConnectionListenerData 0 1 143 78
upcast from QueuedConnectionListener to QueuedReturn< ConnectionListenerData >
118
QueuedReturn< ConnectionListenerData > *QueuedConnectionListener::upcast_to_QueuedReturn_ConnectionListenerData(void);

320 36 downcast_to_QueuedConnectionListener 0 12 376 76 QueuedReturn< ConnectionListenerData >::downcast_to_QueuedConnectionListener 0 1 144 80
downcast from QueuedReturn< ConnectionListenerData > to QueuedConnectionListener
109
QueuedConnectionListener *QueuedReturn< ConnectionListenerData >::downcast_to_QueuedConnectionListener(void);

321 24 QueuedConnectionListener 0 4 375 50 QueuedConnectionListener::QueuedConnectionListener 0 1 137 10
/**
 *
 */
96
QueuedConnectionListener::QueuedConnectionListener(ConnectionManager *manager, int num_threads);

322 25 ~QueuedConnectionListener 0 6 375 51 QueuedConnectionListener::~QueuedConnectionListener 0 0 10
/**
 *
 */
66
virtual QueuedConnectionListener::~QueuedConnectionListener(void);

323 24 new_connection_available 0 4 375 50 QueuedConnectionListener::new_connection_available 0 1 138 147
/**
 * Returns true if a new connection was recently established; the connection
 * information may then be retrieved via get_new_connection().
 */
62
bool QueuedConnectionListener::new_connection_available(void);

324 18 get_new_connection 0 4 375 44 QueuedConnectionListener::get_new_connection 0 2 139 140 935
/**
 * If a previous call to new_connection_available() returned true, this
 * function will return information about the newly established connection.
 *
 * The rendezvous parameter is the particular rendezvous socket this new
 * connection originally communicated with; it is provided in case the
 * ConnectionListener was monitorind more than one and you care which one it
 * was.  The address parameter is the net address of the new client, and
 * new_connection is the socket of the newly established connection.
 *
 * The return value is true if a connection was successfully returned, or
 * false if there was, in fact, no new connection.  (This may happen if there
 * are multiple threads accessing the QueuedConnectionListener).
 */

/**
 * This flavor of get_new_connection() simply returns a new connection,
 * assuming the user doesn't care about the rendezvous socket that originated
 * it or the address it came from.
 */
241
bool QueuedConnectionListener::get_new_connection(PointerTo< Connection > &rendezvous, NetAddress &address, PointerTo< Connection > &new_connection);
bool QueuedConnectionListener::get_new_connection(PointerTo< Connection > &new_connection);

325 27 upcast_to_ConnectionManager 0 12 377 52 QueuedConnectionManager::upcast_to_ConnectionManager 0 1 153 56
upcast from QueuedConnectionManager to ConnectionManager
78
ConnectionManager *QueuedConnectionManager::upcast_to_ConnectionManager(void);

326 35 downcast_to_QueuedConnectionManager 0 12 364 54 ConnectionManager::downcast_to_QueuedConnectionManager 0 1 154 58
downcast from ConnectionManager to QueuedConnectionManager
86
QueuedConnectionManager *ConnectionManager::downcast_to_QueuedConnectionManager(void);

327 18 set_max_queue_size 0 4 378 59 QueuedReturn< PointerTo< Connection > >::set_max_queue_size 0 1 157 0
79
void QueuedReturn< PointerTo< Connection > >::set_max_queue_size(int max_size);

328 18 get_max_queue_size 0 4 378 59 QueuedReturn< PointerTo< Connection > >::get_max_queue_size 0 1 158 0
76
int QueuedReturn< PointerTo< Connection > >::get_max_queue_size(void) const;

329 22 get_current_queue_size 0 4 378 63 QueuedReturn< PointerTo< Connection > >::get_current_queue_size 0 1 159 0
80
int QueuedReturn< PointerTo< Connection > >::get_current_queue_size(void) const;

330 17 get_overflow_flag 0 4 378 58 QueuedReturn< PointerTo< Connection > >::get_overflow_flag 0 1 160 0
76
bool QueuedReturn< PointerTo< Connection > >::get_overflow_flag(void) const;

331 19 reset_overflow_flag 0 4 378 60 QueuedReturn< PointerTo< Connection > >::reset_overflow_flag 0 1 161 0
72
void QueuedReturn< PointerTo< Connection > >::reset_overflow_flag(void);

332 43 upcast_to_QueuedReturn_PointerTo_Connection 0 12 377 68 QueuedConnectionManager::upcast_to_QueuedReturn_PointerTo_Connection 0 1 155 78
upcast from QueuedConnectionManager to QueuedReturn< PointerTo< Connection > >
116
QueuedReturn< PointerTo< Connection > > *QueuedConnectionManager::upcast_to_QueuedReturn_PointerTo_Connection(void);

333 35 downcast_to_QueuedConnectionManager 0 12 378 76 QueuedReturn< PointerTo< Connection > >::downcast_to_QueuedConnectionManager 0 1 156 80
downcast from QueuedReturn< PointerTo< Connection > > to QueuedConnectionManager
108
QueuedConnectionManager *QueuedReturn< PointerTo< Connection > >::downcast_to_QueuedConnectionManager(void);

334 23 QueuedConnectionManager 0 4 377 48 QueuedConnectionManager::QueuedConnectionManager 0 1 150 10
/**
 *
 */
55
QueuedConnectionManager::QueuedConnectionManager(void);

335 24 ~QueuedConnectionManager 0 6 377 49 QueuedConnectionManager::~QueuedConnectionManager 0 0 10
/**
 *
 */
64
virtual QueuedConnectionManager::~QueuedConnectionManager(void);

336 26 reset_connection_available 0 4 377 51 QueuedConnectionManager::reset_connection_available 0 1 151 631
/**
 * Returns true if one of the readers/writers/listeners reported a connection
 * reset recently.  If so, the particular connection that has been reset can
 * be extracted via get_reset_connection().
 *
 * Only connections which were externally reset are certain to appear in this
 * list.  Those which were explicitly closed via a call to close_connection()
 * may or may not be reported.  Furthermore, it is the responsibility of the
 * caller to subsequently call close_connection() with any connection reported
 * reset by this call.  (There is no harm in calling close_connection() more
 * than once on a given socket.)
 */
69
bool QueuedConnectionManager::reset_connection_available(void) const;

337 20 get_reset_connection 0 4 377 45 QueuedConnectionManager::get_reset_connection 0 1 152 797
/**
 * If a previous call to reset_connection_available() returned true, this
 * function will return information about the newly reset connection.
 *
 * Only connections which were externally reset are certain to appear in this
 * list.  Those which were explicitly closed via a call to close_connection()
 * may or may not be reported.  Furthermore, it is the responsibility of the
 * caller to subsequently call close_connection() with any connection reported
 * reset by this call.  (There is no harm in calling close_connection() more
 * than once on a given socket.)
 *
 * The return value is true if a connection was successfully returned, or
 * false if there was, in fact, no reset connection.  (This may happen if
 * there are multiple threads accessing the QueuedConnectionManager).
 */
88
bool QueuedConnectionManager::get_reset_connection(PointerTo< Connection > &connection);

338 26 upcast_to_ConnectionReader 0 12 379 50 QueuedConnectionReader::upcast_to_ConnectionReader 0 1 166 54
upcast from QueuedConnectionReader to ConnectionReader
75
ConnectionReader *QueuedConnectionReader::upcast_to_ConnectionReader(void);

339 34 downcast_to_QueuedConnectionReader 0 12 360 52 ConnectionReader::downcast_to_QueuedConnectionReader 0 1 167 56
downcast from ConnectionReader to QueuedConnectionReader
83
QueuedConnectionReader *ConnectionReader::downcast_to_QueuedConnectionReader(void);

340 18 set_max_queue_size 0 4 380 47 QueuedReturn< NetDatagram >::set_max_queue_size 0 1 170 0
67
void QueuedReturn< NetDatagram >::set_max_queue_size(int max_size);

341 18 get_max_queue_size 0 4 380 47 QueuedReturn< NetDatagram >::get_max_queue_size 0 1 171 0
64
int QueuedReturn< NetDatagram >::get_max_queue_size(void) const;

342 22 get_current_queue_size 0 4 380 51 QueuedReturn< NetDatagram >::get_current_queue_size 0 1 172 0
68
int QueuedReturn< NetDatagram >::get_current_queue_size(void) const;

343 17 get_overflow_flag 0 4 380 46 QueuedReturn< NetDatagram >::get_overflow_flag 0 1 173 0
64
bool QueuedReturn< NetDatagram >::get_overflow_flag(void) const;

344 19 reset_overflow_flag 0 4 380 48 QueuedReturn< NetDatagram >::reset_overflow_flag 0 1 174 0
60
void QueuedReturn< NetDatagram >::reset_overflow_flag(void);

345 34 upcast_to_QueuedReturn_NetDatagram 0 12 379 58 QueuedConnectionReader::upcast_to_QueuedReturn_NetDatagram 0 1 168 65
upcast from QueuedConnectionReader to QueuedReturn< NetDatagram >
94
QueuedReturn< NetDatagram > *QueuedConnectionReader::upcast_to_QueuedReturn_NetDatagram(void);

346 34 downcast_to_QueuedConnectionReader 0 12 380 63 QueuedReturn< NetDatagram >::downcast_to_QueuedConnectionReader 0 1 169 67
downcast from QueuedReturn< NetDatagram > to QueuedConnectionReader
94
QueuedConnectionReader *QueuedReturn< NetDatagram >::downcast_to_QueuedConnectionReader(void);

347 22 QueuedConnectionReader 0 4 379 46 QueuedConnectionReader::QueuedConnectionReader 0 1 162 10
/**
 *
 */
92
QueuedConnectionReader::QueuedConnectionReader(ConnectionManager *manager, int num_threads);

348 23 ~QueuedConnectionReader 0 6 379 47 QueuedConnectionReader::~QueuedConnectionReader 0 0 10
/**
 *
 */
62
virtual QueuedConnectionReader::~QueuedConnectionReader(void);

349 14 data_available 0 4 379 38 QueuedConnectionReader::data_available 0 1 163 108
/**
 * Returns true if a datagram is available on the queue; call get_data() to
 * extract the datagram.
 */
50
bool QueuedConnectionReader::data_available(void);

350 8 get_data 0 4 379 32 QueuedConnectionReader::get_data 0 2 164 165 650
/**
 * If a previous call to data_available() returned true, this function will
 * return the datagram that has become available.
 *
 * The return value is true if a datagram was successfully returned, or false
 * if there was, in fact, no datagram available.  (This may happen if there
 * are multiple threads accessing the QueuedConnectionReader).
 */

/**
 * This flavor of QueuedConnectionReader::get_data(), works like the other,
 * except that it only fills a Datagram object, not a NetDatagram object.
 * This means that the Datagram cannot be queried for its source Connection
 * and/or NetAddress, but it is useful in all other respects.
 */
116
bool QueuedConnectionReader::get_data(NetDatagram &result);
bool QueuedConnectionReader::get_data(Datagram &result);

351 22 RecentConnectionReader 0 4 381 46 RecentConnectionReader::RecentConnectionReader 0 1 175 10
/**
 *
 */
75
RecentConnectionReader::RecentConnectionReader(ConnectionManager *manager);

352 14 data_available 0 4 381 38 RecentConnectionReader::data_available 0 1 176 108
/**
 * Returns true if a datagram is available on the queue; call get_data() to
 * extract the datagram.
 */
50
bool RecentConnectionReader::data_available(void);

353 8 get_data 0 4 381 32 RecentConnectionReader::get_data 0 2 177 178 650
/**
 * If a previous call to data_available() returned true, this function will
 * return the datagram that has become available.
 *
 * The return value is true if a datagram was successfully returned, or false
 * if there was, in fact, no datagram available.  (This may happen if there
 * are multiple threads accessing the RecentConnectionReader).
 */

/**
 * This flavor of RecentConnectionReader::get_data(), works like the other,
 * except that it only fills a Datagram object, not a NetDatagram object.
 * This means that the Datagram cannot be queried for its source Connection
 * and/or NetAddress, but it is useful in all other respects.
 */
116
bool RecentConnectionReader::get_data(NetDatagram &result);
bool RecentConnectionReader::get_data(Datagram &result);

178
1 0 0 7 6 382 186 0 0 0 
2 0 0 7 6 382 186 0 0 1 3 ptr 1 383  
3 0 0 7 6 382 186 0 0 1 4 copy 1 383  
4 0 0 7 7 383 0 0 289 // If your base class is a derivative of TypedObject, you might want to use
// the DCAST macro defined in typedObject.h instead, e.g.  DCAST(MyType,
// ptr).  This provides a clean downcast that doesn't require .p() or any
// double-casting, and it can be run-time checked for correctness. 1 4 this 3 384  
5 0 0 6 8 382 0 0 0 2 4 this 3 382  3 ptr 1 383  
6 0 0 6 8 382 0 0 0 2 4 this 3 382  4 copy 1 383  
7 0 0 6 9 386 0 0 0 1 4 this 3 384  
8 0 0 4 10 387 0 0 0 1 4 this 3 382  
9 0 0 4 4 387 0 0 0 1 4 this 3 388  
10 0 0 4 5 387 0 0 0 2 4 this 3 389  3 out 1 391  
11 0 0 7 13 393 204 0 45 /**
 * Constructs an unspecified address.
 */ 0 
12 0 0 7 13 393 204 0 0 1 6 param0 0 394  
13 0 0 7 13 393 204 0 224 /**
 * Constructs an address from a given Socket_Address.  Normally, this
 * constructor should not be used by user code; instead, create a default
 * NetAddress and use one of the set_*() functions to set up an address.
 */ 1 4 addr 1 396  
14 0 0 6 14 386 0 0 179 /**
 * Sets the address up to refer to a particular port, but not to any
 * particular IP.  Returns true if successful, false otherwise (currently,
 * this only returns true).
 */ 2 4 this 3 393  4 port 1 399  
15 0 0 6 15 386 0 0 75 /**
 * Sets the address up to refer to a particular port, on this host.
 */ 2 4 this 3 393  4 port 1 399  
16 0 0 6 16 386 0 0 53 /**
 * Sets the address to the broadcast address.
 */ 2 4 this 3 393  4 port 1 399  
17 0 0 6 17 386 0 0 141 /**
 * Sets the address up to refer to a particular port on a particular host.
 * Returns true if the hostname is known, false otherwise.
 */ 3 4 this 3 393  8 hostname 1 400  4 port 1 399  
18 0 0 4 18 387 0 0 54 /**
 * Resets the NetAddress to its initial state.
 */ 1 4 this 3 393  
19 0 0 6 19 399 0 0 64 /**
 * Returns the port number to which this address refers.
 */ 1 4 this 3 394  
20 0 0 4 20 387 0 0 73 /**
 * Resets the port number without otherwise changing the address.
 */ 2 4 this 3 393  4 port 1 399  
21 0 0 6 21 400 0 0 86 /**
 * Returns the IP address to which this address refers, formatted as a string.
 */ 1 4 this 3 394  
22 0 0 6 22 386 0 0 58 /**
 * Returns true if the IP address has only zeroes.
 */ 1 4 this 3 394  
23 0 0 6 23 401 0 0 158 /**
 * Returns the IP address to which this address refers, as a 32-bit integer,
 * in host byte order.
 * @deprecated  Does not work with IPv6 addresses.
 */ 1 4 this 3 394  
24 0 0 6 24 403 0 0 213 /**
 * Returns the nth 8-bit component of the IP address.  An IP address has four
 * components; component 0 is the first (leftmost), and component 3 is the
 * last (rightmost) in the dotted number convention.
 */ 2 4 this 3 394  1 n 1 399  
25 0 0 6 25 396 0 0 55 /**
 * Returns the Socket_Address for this address.
 */ 1 4 this 3 394  
26 0 0 4 26 387 0 0 10 /**
 *
 */ 2 4 this 3 394  3 out 1 391  
27 0 0 6 27 405 0 0 10 /**
 *
 */ 1 4 this 3 394  
28 0 0 6 28 386 0 0 0 2 4 this 3 394  5 other 1 394  
29 0 0 6 29 386 0 0 0 2 4 this 3 394  5 other 1 394  
30 0 0 7 33 383 0 0 177 /**
 * Creates a connection.  Normally this constructor should not be used
 * directly by user code; use one of the methods in ConnectionManager to make
 * a new connection.
 */ 2 7 manager 1 407  6 socket 1 408  
31 0 0 7 34 393 204 0 83 /**
 * Returns the address bound to this connection, if it is a TCP connection.
 */ 1 4 this 3 410  
32 0 0 6 35 407 0 0 92 /**
 * Returns a pointer to the ConnectionManager object that serves this
 * connection.
 */ 1 4 this 3 410  
33 0 0 6 36 408 0 0 70 /**
 * Returns the internal Socket_IP that defines the connection.
 */ 1 4 this 3 410  
34 0 0 4 37 387 0 0 719 /**
 * Enables or disables "collect-tcp" mode.  In this mode, individual TCP
 * packets are not sent immediately, but rather they are collected together
 * and accumulated to be sent periodically as one larger TCP packet.  This
 * cuts down on overhead from the TCP/IP protocol, especially if many small
 * packets need to be sent on the same connection, but it introduces
 * additional latency (since packets must be held before they can be sent).
 *
 * See set_collect_tcp_interval() to specify the interval of time for which to
 * hold packets before sending them.
 *
 * If you enable this mode, you may also need to periodically call
 * consider_flush() to flush the queue if no packets have been sent recently.
 */ 2 4 this 3 383  11 collect_tcp 1 386  
35 0 0 6 38 386 0 0 85 /**
 * Returns the current setting of "collect-tcp" mode.  See set_collect_tcp().
 */ 1 4 this 3 410  
36 0 0 4 39 387 0 0 231 /**
 * Specifies the interval in time, in seconds, for which to hold TCP packets
 * before sending all of the recently received packets at once.  This only has
 * meaning if "collect-tcp" mode is enabled; see set_collect_tcp().
 */ 2 4 this 3 383  8 interval 1 412  
37 0 0 6 40 412 0 0 229 /**
 * Returns the interval in time, in seconds, for which to hold TCP packets
 * before sending all of the recently received packets at once.  This only has
 * meaning if "collect-tcp" mode is enabled; see set_collect_tcp().
 */ 1 4 this 3 410  
38 0 0 6 41 386 0 0 153 /**
 * Sends the most recently queued TCP datagram(s) if enough time has elapsed.
 * This only has meaning if set_collect_tcp() has been set to true.
 */ 1 4 this 3 383  
39 0 0 6 42 386 0 0 131 /**
 * Sends the most recently queued TCP datagram(s) now.  This only has meaning
 * if set_collect_tcp() has been set to true.
 */ 1 4 this 3 383  
40 0 0 4 43 387 0 0 416 /**
 * Sets the time to linger on close if data is present.  If flag is false,
 * when you close a socket with data available the system attempts to deliver
 * the data to the peer (the default behavior).  If flag is false but time is
 * zero, the system discards any undelivered data when you close the socket.
 * If flag is false but time is nonzero, the system waits up to time seconds
 * to deliver the data.
 */ 3 4 this 3 383  4 flag 1 386  4 time 1 412  
41 0 0 4 44 387 0 0 55 /**
 * Sets whether local address reuse is allowed.
 */ 2 4 this 3 383  4 flag 1 386  
42 0 0 4 45 387 0 0 93 /**
 * Sets whether the connection is periodically tested to see if it is still
 * alive.
 */ 2 4 this 3 383  4 flag 1 386  
43 0 0 4 46 387 0 0 57 /**
 * Sets the size of the receive buffer, in bytes.
 */ 2 4 this 3 383  4 size 1 399  
44 0 0 4 47 387 0 0 54 /**
 * Sets the size of the send buffer, in bytes.
 */ 2 4 this 3 383  4 size 1 399  
45 0 0 4 48 387 0 0 32 /**
 * Sets IP time-to-live.
 */ 2 4 this 3 383  3 ttl 1 399  
46 0 0 4 49 387 0 0 50 /**
 * Sets IP type-of-service and precedence.
 */ 2 4 this 3 383  3 tos 1 399  
47 0 0 4 50 387 0 0 116 /**
 * If flag is true, this disables the Nagle algorithm, and prevents delaying
 * of send to coalesce packets.
 */ 2 4 this 3 383  4 flag 1 386  
48 0 0 4 51 387 0 0 41 /**
 * Sets the maximum segment size.
 */ 2 4 this 3 383  4 size 1 399  
49 0 0 6 54 386 0 0 504 /**
 * Adds a new socket to the list of sockets the ConnectionReader will monitor.
 * A datagram that comes in on any of the monitored sockets will be reported.
 * In the case of a ConnectionListener, this adds a new rendezvous socket; any
 * activity on any of the monitored sockets will cause a connection to be
 * accepted.
 *
 * The return value is true if the connection was added, false if it was
 * already there.
 *
 * add_connection() is thread-safe, and may be called at will by any thread.
 */ 2 4 this 3 413  10 connection 1 383  
50 0 0 6 55 386 0 0 264 /**
 * Removes a socket from the list of sockets being monitored.  Returns true if
 * the socket was correctly removed, false if it was not on the list in the
 * first place.
 *
 * remove_connection() is thread-safe, and may be called at will by any
 * thread.
 */ 2 4 this 3 413  10 connection 1 383  
51 0 0 6 56 386 0 0 345 /**
 * Returns true if the indicated connection has been added to the
 * ConnectionReader and is being monitored properly, false if it is not known,
 * or if there was some error condition detected on the connection.  (If there
 * was an error condition, normally the ConnectionManager would have been
 * informed and closed the connection.)
 */ 2 4 this 3 413  10 connection 1 383  
52 0 0 4 57 387 0 0 328 /**
 * Explicitly polls the available sockets to see if any of them have any
 * noise.  This function does nothing unless this is a polling-type
 * ConnectionReader, i.e.  it was created with zero threads (and is_polling()
 * will return true).
 *
 * It is not necessary to call this explicitly for a QueuedConnectionReader.
 */ 1 4 this 3 413  
53 0 0 6 58 407 0 0 98 /**
 * Returns a pointer to the ConnectionManager object that serves this
 * ConnectionReader.
 */ 1 4 this 3 414  
54 0 0 6 59 386 0 0 83 /**
 * Returns true if the reader is a polling reader, i.e.  it has no threads.
 */ 1 4 this 3 414  
55 0 0 6 60 399 0 0 84 /**
 * Returns the number of threads the ConnectionReader has been created with.
 */ 1 4 this 3 414  
56 0 0 4 61 387 0 0 314 /**
 * Sets the ConnectionReader into raw mode (or turns off raw mode).  In raw
 * mode, datagram headers are not expected; instead, all the data available on
 * the pipe is treated as a single datagram.
 *
 * This is similar to set_tcp_header_size(0), except that it also turns off
 * headers for UDP packets.
 */ 2 4 this 3 413  4 mode 1 386  
57 0 0 6 62 386 0 0 81 /**
 * Returns the current setting of the raw mode flag.  See set_raw_mode().
 */ 1 4 this 3 414  
58 0 0 4 63 387 0 0 270 /**
 * Sets the header size of TCP packets.  At the present, legal values for this
 * are 0, 2, or 4; this specifies the number of bytes to use encode the
 * datagram length at the start of each TCP datagram.  Sender and receiver
 * must independently agree on this.
 */ 2 4 this 3 413  15 tcp_header_size 1 399  
59 0 0 6 64 399 0 0 86 /**
 * Returns the current setting of TCP header size.  See set_tcp_header_size().
 */ 1 4 this 3 414  
60 0 0 4 65 387 0 0 146 /**
 * Terminates all threads cleanly.  Normally this is only called by the
 * destructor, but it may be called explicitly before destruction.
 */ 1 4 this 3 413  
61 0 0 7 70 416 245 0 40 /**
 * Constructs an empty datagram.
 */ 0 
62 0 0 7 70 416 245 0 10 /**
 *
 */ 1 4 copy 1 417  
63 0 0 7 70 416 245 0 10 /**
 *
 */ 1 4 copy 1 419  
64 0 0 6 71 416 0 0 0 2 4 this 3 416  4 copy 1 417  
65 0 0 6 71 416 0 0 0 2 4 this 3 416  4 copy 1 419  
66 0 0 4 72 387 0 0 72 /**
 * Specifies the socket to which the datagram should be written.
 */ 2 4 this 3 416  10 connection 1 383  
67 0 0 7 73 383 0 0 111 /**
 * Retrieves the socket from which the datagram was read, or to which it is
 * scheduled to be written.
 */ 1 4 this 3 419  
68 0 0 4 74 387 0 0 67 /**
 * Specifies the host to which the datagram should be sent.
 */ 2 4 this 3 416  7 address 1 394  
69 0 0 6 75 394 0 0 106 /**
 * Retrieves the host from which the datagram was read, or to which it is
 * scheduled to be sent.
 */ 1 4 this 3 419  
70 0 0 7 76 422 0 0 0 0 
71 0 0 7 79 407 247 0 10 /**
 *
 */ 0 
72 0 0 7 81 383 0 0 720 /**
 * Opens a socket for sending and/or receiving UDP packets.  If the port
 * number is greater than zero, the UDP connection will be opened for
 * listening on the indicated port; otherwise, it will be useful only for
 * sending.
 *
 * This variant accepts both a hostname and port to listen on a particular
 * interface; if the hostname is empty, all interfaces will be available,
 * both IPv4 and IPv6.
 *
 * If for_broadcast is true, this UDP connection will be configured to send
 * and/or receive messages on the broadcast address (255.255.255.255);
 * otherwise, these messages may be automatically filtered by the OS.
 *
 * Use a ConnectionReader and ConnectionWriter to handle the actual
 * communication.
 */ 4 4 this 3 407  8 hostname 1 400  4 port 1 423  13 for_broadcast 1 386  
73 0 0 7 81 383 0 0 325 /**
 * Opens a socket for sending and/or receiving UDP packets.  If the port
 * number is greater than zero, the UDP connection will be opened for
 * listening on the indicated port; otherwise, it will be useful only for
 * sending.
 *
 * Use a ConnectionReader and ConnectionWriter to handle the actual
 * communication.
 */ 2 4 this 3 407  4 port 1 423  
74 0 0 7 82 383 0 0 422 /**
 * Creates a socket to be used as a rendezvous socket for a server to listen
 * for TCP connections.  The socket returned by this call should only be added
 * to a ConnectionListener (not to a generic ConnectionReader).
 *
 * This variant of this method accepts a NetAddress, which allows you to
 * specify a specific interface to listen to.
 *
 * backlog is the maximum length of the queue of pending connections.
 */ 3 4 this 3 407  7 address 1 394  7 backlog 1 399  
75 0 0 7 82 383 0 0 572 /**
 * Creates a socket to be used as a rendezvous socket for a server to listen
 * for TCP connections.  The socket returned by this call should only be added
 * to a ConnectionListener (not to a generic ConnectionReader).
 *
 * This variant of this method accepts a "hostname", which is usually just an
 * IP address in dotted notation, and a port number.  It will listen on the
 * interface indicated by the IP address.  If the IP address is empty string,
 * it will listen on all interfaces.
 *
 * backlog is the maximum length of the queue of pending connections.
 */ 4 4 this 3 407  8 hostname 1 400  4 port 1 423  7 backlog 1 399  
76 0 0 7 82 383 0 0 438 /**
 * Creates a socket to be used as a rendezvous socket for a server to listen
 * for TCP connections.  The socket returned by this call should only be added
 * to a ConnectionListener (not to a generic ConnectionReader).
 *
 * This variant of this method accepts a single port, and will listen to that
 * port on all available interfaces, both IPv4 and IPv6.
 *
 * backlog is the maximum length of the queue of pending connections.
 */ 3 4 this 3 407  4 port 1 423  7 backlog 1 399  
77 0 0 7 83 383 0 0 201 /**
 * Attempts to establish a TCP client connection to a server at the indicated
 * address.  If the connection is not established within timeout_ms
 * milliseconds, a null connection is returned.
 */ 3 4 this 3 407  7 address 1 394  10 timeout_ms 1 399  
78 0 0 7 83 383 0 0 120 /**
 * This is a shorthand version of the function to directly establish
 * communications to a named host and port.
 */ 4 4 this 3 407  8 hostname 1 400  4 port 1 423  10 timeout_ms 1 399  
79 0 0 6 84 386 0 0 693 /**
 * Terminates a UDP or TCP socket previously opened.  This also removes it
 * from any associated ConnectionReader or ConnectionListeners.
 *
 * The socket itself may not be immediately closed--it will not be closed
 * until all outstanding pointers to it are cleared, including any pointers
 * remaining in NetDatagrams recently received from the socket.
 *
 * The return value is true if the connection was marked to be closed, or
 * false if close_connection() had already been called (or the connection did
 * not belong to this ConnectionManager).  In neither case can you infer
 * anything about whether the connection has *actually* been closed yet based
 * on the return value.
 */ 2 4 this 3 407  10 connection 1 383  
80 0 0 6 85 386 0 0 664 /**
 * Blocks the process for timeout number of seconds, or until any data is
 * available on any of the non-threaded ConnectionReaders or
 * ConnectionListeners, whichever comes first.  The return value is true if
 * there is data available (but you have to iterate through all readers to
 * find it), or false if the timeout occurred without any data.
 *
 * If the timeout value is negative, this will block forever or until data is
 * available.
 *
 * This only works if all ConnectionReaders and ConnectionListeners are non-
 * threaded.  If any threaded ConnectionReaders are part of the
 * ConnectionManager, the timeout value is implicitly treated as 0.
 */ 2 4 this 3 407  7 timeout 1 412  
81 0 0 6 86 400 0 0 145 /**
 * Returns the name of this particular machine on the network, if available,
 * or the empty string if the hostname cannot be determined.
 */ 0 
82 0 0 4 101 387 0 0 258 /**
 * Repopulates the list reported by get_num_interface()/get_interface().  It
 * is not necessary to call this explicitly, unless you want to re-determine
 * the connected interfaces (for instance, if you suspect the hardware has
 * recently changed).
 */ 1 4 this 3 407  
83 0 0 6 102 405 0 0 140 /**
 * This returns the number of usable network interfaces detected on this
 * machine.  See scan_interfaces() to repopulate this list.
 */ 1 4 this 3 407  
84 0 0 6 103 425 0 0 127 /**
 * Returns the nth usable network interface detected on this machine.
 * See scan_interfaces() to repopulate this list.
 */ 2 4 this 3 407  1 n 1 405  
85 0 0 7 99 426 266 0 0 1 6 param0 0 425  
86 0 0 6 88 400 0 0 0 1 4 this 3 425  
87 0 0 6 89 400 0 0 0 1 4 this 3 425  
88 0 0 6 90 386 0 0 0 1 4 this 3 425  
89 0 0 6 91 394 0 0 0 1 4 this 3 425  
90 0 0 6 92 386 0 0 0 1 4 this 3 425  
91 0 0 6 93 394 0 0 0 1 4 this 3 425  
92 0 0 6 94 386 0 0 0 1 4 this 3 425  
93 0 0 6 95 394 0 0 0 1 4 this 3 425  
94 0 0 6 96 386 0 0 0 1 4 this 3 425  
95 0 0 6 97 394 0 0 0 1 4 this 3 425  
96 0 0 4 98 387 0 0 10 /**
 *
 */ 2 4 this 3 425  3 out 1 391  
97 0 0 7 111 427 271 0 224 /**
 * Creates a new ConnectionWriter with the indicated number of threads to
 * handle output.
 *
 * If num_threads is 0, all datagrams will be sent immediately instead of
 * queueing for later transmission by a thread.
 */ 3 7 manager 1 407  11 num_threads 1 399  11 thread_name 1 400  
98 0 0 4 113 387 0 0 192 /**
 * Limits the number of packets that may be pending on the outbound queue.
 * This only has an effect when using threads; if num_threads is 0, then all
 * packets are sent immediately.
 */ 2 4 this 3 427  8 max_size 1 399  
99 0 0 6 114 399 0 0 98 /**
 * Returns the maximum size the queue is allowed to grow to.  See
 * set_max_queue_size().
 */ 1 4 this 3 428  
100 0 0 6 115 399 0 0 61 /**
 * Returns the current number of things in the queue.
 */ 1 4 this 3 428  
101 0 0 6 116 386 0 0 617 /**
 * Enqueues a datagram for transmittal on the indicated socket.  This form of
 * the function allows the specification of a destination host address, and so
 * is appropriate for UDP packets.  Use the other send() method for sending
 * TCP packets.
 *
 * Returns true if successful, false if there was an error.  In the normal,
 * threaded case, this function only returns false if the send queue is
 * filled; it's impossible to detect a transmission error at this point.
 *
 * If block is true, this will not return false if the send queue is filled;
 * instead, it will wait until there is space available.
 */ 5 4 this 3 427  8 datagram 1 417  10 connection 1 383  7 address 1 394  5 block 1 386  
102 0 0 6 116 386 0 0 611 /**
 * Enqueues a datagram for transmittal on the indicated socket.  Since the
 * host address is not specified with this form, this function should only be
 * used for sending TCP packets.  Use the other send() method for sending UDP
 * packets.
 *
 * Returns true if successful, false if there was an error.  In the normal,
 * threaded case, this function only returns false if the send queue is
 * filled; it's impossible to detect a transmission error at this point.
 *
 * If block is true, this will not return false if the send queue is filled;
 * instead, it will wait until there is space available.
 */ 4 4 this 3 427  8 datagram 1 417  10 connection 1 383  5 block 1 386  
103 0 0 6 117 386 0 0 105 /**
 * Returns true if the datagram is small enough to be sent over a UDP packet,
 * false otherwise.
 */ 2 4 this 3 428  8 datagram 1 417  
104 0 0 6 118 407 0 0 98 /**
 * Returns a pointer to the ConnectionManager object that serves this
 * ConnectionWriter.
 */ 1 4 this 3 428  
105 0 0 6 119 386 0 0 86 /**
 * Returns true if the writer is an immediate writer, i.e.  it has no threads.
 */ 1 4 this 3 428  
106 0 0 6 120 399 0 0 84 /**
 * Returns the number of threads the ConnectionWriter has been created with.
 */ 1 4 this 3 428  
107 0 0 4 121 387 0 0 455 /**
 * Sets the ConnectionWriter into raw mode (or turns off raw mode).  In raw
 * mode, datagrams are not sent along with their headers; the bytes in the
 * datagram are simply sent down the pipe.
 *
 * Setting the ConnectionWriter to raw mode must be done with care.  This can
 * only be done when the matching ConnectionReader is also set to raw mode, or
 * when the ConnectionWriter is communicating to a process that does not
 * expect datagrams.
 */ 2 4 this 3 427  4 mode 1 386  
108 0 0 6 122 386 0 0 81 /**
 * Returns the current setting of the raw mode flag.  See set_raw_mode().
 */ 1 4 this 3 428  
109 0 0 4 123 387 0 0 270 /**
 * Sets the header size of TCP packets.  At the present, legal values for this
 * are 0, 2, or 4; this specifies the number of bytes to use encode the
 * datagram length at the start of each TCP datagram.  Sender and receiver
 * must independently agree on this.
 */ 2 4 this 3 427  15 tcp_header_size 1 399  
110 0 0 6 124 399 0 0 86 /**
 * Returns the current setting of TCP header size.  See set_tcp_header_size().
 */ 1 4 this 3 428  
111 0 0 4 125 387 0 0 156 /**
 * Stops all the threads and cleans them up.  This is called automatically by
 * the destructor, but it may be called explicitly before destruction.
 */ 1 4 this 3 427  
112 0 0 7 140 430 297 0 243 /**
 * Creates a new DatagramGeneratorNet with the indicated number of threads to
 * handle requests.  Normally num_threads should be either 0 or 1 to guarantee
 * that datagrams are generated in the same order in which they were received.
 */ 2 7 manager 1 407  11 num_threads 1 399  
113 0 0 6 142 386 0 0 152 /**
 * Reads the next datagram from the stream.  Blocks until a datagram is
 * available.  Returns true on success, false on stream closed or error.
 */ 2 4 this 3 430  4 data 1 431  
114 0 0 6 143 386 0 0 137 /**
 * Returns true if the stream has been closed normally.  This test may only be
 * made after a call to get_datagram() has failed.
 */ 1 4 this 3 430  
115 0 0 6 144 386 0 0 61 /**
 * Returns true if the stream has an error condition.
 */ 1 4 this 3 430  
116 0 0 6 128 432 0 0 0 1 4 this 3 430  
117 0 0 6 129 430 0 0 0 1 4 this 3 432  
118 0 0 6 130 413 0 0 0 1 4 this 3 430  
119 0 0 6 131 430 0 0 0 1 4 this 3 413  
120 0 0 6 138 433 0 0 0 1 4 this 3 430  
121 0 0 6 139 430 0 0 0 1 4 this 3 433  
122 0 0 4 133 387 0 0 0 2 4 this 3 433  8 max_size 1 399  
123 0 0 6 134 399 0 0 0 1 4 this 3 434  
124 0 0 6 135 399 0 0 0 1 4 this 3 434  
125 0 0 6 136 386 0 0 0 1 4 this 3 434  
126 0 0 4 137 387 0 0 0 1 4 this 3 433  
127 0 0 7 151 436 311 0 233 /**
 * Creates a new DatagramSinkNet with the indicated number of threads to
 * handle writing.  Normally num_threads should be either 0 or 1 to guarantee
 * that datagrams are delivered in the same order in which they were sent.
 */ 2 7 manager 1 407  11 num_threads 1 399  
128 0 0 4 152 387 0 0 80 /**
 * Specifies the Connection that will receive all future Datagrams sent.
 */ 2 4 this 3 436  10 connection 1 383  
129 0 0 7 153 383 0 0 115 /**
 * Returns the current target Connection, or NULL if the target has not yet
 * been set.  See set_target().
 */ 1 4 this 3 437  
130 0 0 6 154 386 0 0 155 /**
 * Sends the given datagram to the target.  Returns true on success, false if
 * there is an error.  Blocks if necessary until the target is ready.
 */ 2 4 this 3 436  4 data 1 417  
131 0 0 6 155 386 0 0 110 /**
 * Returns true if there is an error on the target connection, or if the
 * target has never been set.
 */ 1 4 this 3 436  
132 0 0 4 156 387 0 0 90 /**
 * Ensures that all datagrams previously written will be visible on the
 * stream.
 */ 1 4 this 3 436  
133 0 0 6 147 439 0 0 0 1 4 this 3 436  
134 0 0 6 148 436 0 0 0 1 4 this 3 439  
135 0 0 6 149 427 0 0 0 1 4 this 3 436  
136 0 0 6 150 436 0 0 0 1 4 this 3 427  
137 0 0 7 169 440 322 0 10 /**
 *
 */ 2 7 manager 1 407  11 num_threads 1 399  
138 0 0 6 171 386 0 0 147 /**
 * Returns true if a new connection was recently established; the connection
 * information may then be retrieved via get_new_connection().
 */ 1 4 this 3 440  
139 0 0 6 172 386 0 0 192 /**
 * This flavor of get_new_connection() simply returns a new connection,
 * assuming the user doesn't care about the rendezvous socket that originated
 * it or the address it came from.
 */ 2 4 this 3 440  14 new_connection 1 382  
140 0 0 6 172 386 0 0 741 /**
 * If a previous call to new_connection_available() returned true, this
 * function will return information about the newly established connection.
 *
 * The rendezvous parameter is the particular rendezvous socket this new
 * connection originally communicated with; it is provided in case the
 * ConnectionListener was monitorind more than one and you care which one it
 * was.  The address parameter is the net address of the new client, and
 * new_connection is the socket of the newly established connection.
 *
 * The return value is true if a connection was successfully returned, or
 * false if there was, in fact, no new connection.  (This may happen if there
 * are multiple threads accessing the QueuedConnectionListener).
 */ 4 4 this 3 440  10 rendezvous 1 382  7 address 1 393  14 new_connection 1 382  
141 0 0 6 159 441 0 0 0 1 4 this 3 440  
142 0 0 6 160 440 0 0 0 1 4 this 3 441  
143 0 0 6 167 442 0 0 0 1 4 this 3 440  
144 0 0 6 168 440 0 0 0 1 4 this 3 442  
145 0 0 4 162 387 0 0 0 2 4 this 3 442  8 max_size 1 399  
146 0 0 6 163 399 0 0 0 1 4 this 3 443  
147 0 0 6 164 399 0 0 0 1 4 this 3 443  
148 0 0 6 165 386 0 0 0 1 4 this 3 443  
149 0 0 4 166 387 0 0 0 1 4 this 3 442  
150 0 0 7 184 445 335 0 10 /**
 *
 */ 0 
151 0 0 6 186 386 0 0 631 /**
 * Returns true if one of the readers/writers/listeners reported a connection
 * reset recently.  If so, the particular connection that has been reset can
 * be extracted via get_reset_connection().
 *
 * Only connections which were externally reset are certain to appear in this
 * list.  Those which were explicitly closed via a call to close_connection()
 * may or may not be reported.  Furthermore, it is the responsibility of the
 * caller to subsequently call close_connection() with any connection reported
 * reset by this call.  (There is no harm in calling close_connection() more
 * than once on a given socket.)
 */ 1 4 this 3 446  
152 0 0 6 187 386 0 0 797 /**
 * If a previous call to reset_connection_available() returned true, this
 * function will return information about the newly reset connection.
 *
 * Only connections which were externally reset are certain to appear in this
 * list.  Those which were explicitly closed via a call to close_connection()
 * may or may not be reported.  Furthermore, it is the responsibility of the
 * caller to subsequently call close_connection() with any connection reported
 * reset by this call.  (There is no harm in calling close_connection() more
 * than once on a given socket.)
 *
 * The return value is true if a connection was successfully returned, or
 * false if there was, in fact, no reset connection.  (This may happen if
 * there are multiple threads accessing the QueuedConnectionManager).
 */ 2 4 this 3 445  10 connection 1 382  
153 0 0 6 174 407 0 0 0 1 4 this 3 445  
154 0 0 6 175 445 0 0 0 1 4 this 3 407  
155 0 0 6 182 448 0 0 0 1 4 this 3 445  
156 0 0 6 183 445 0 0 0 1 4 this 3 448  
157 0 0 4 177 387 0 0 0 2 4 this 3 448  8 max_size 1 399  
158 0 0 6 178 399 0 0 0 1 4 this 3 449  
159 0 0 6 179 399 0 0 0 1 4 this 3 449  
160 0 0 6 180 386 0 0 0 1 4 this 3 449  
161 0 0 4 181 387 0 0 0 1 4 this 3 448  
162 0 0 7 199 451 348 0 10 /**
 *
 */ 2 7 manager 1 407  11 num_threads 1 399  
163 0 0 6 201 386 0 0 108 /**
 * Returns true if a datagram is available on the queue; call get_data() to
 * extract the datagram.
 */ 1 4 this 3 451  
164 0 0 6 202 386 0 0 295 /**
 * This flavor of QueuedConnectionReader::get_data(), works like the other,
 * except that it only fills a Datagram object, not a NetDatagram object.
 * This means that the Datagram cannot be queried for its source Connection
 * and/or NetAddress, but it is useful in all other respects.
 */ 2 4 this 3 451  6 result 1 431  
165 0 0 6 202 386 0 0 353 /**
 * If a previous call to data_available() returned true, this function will
 * return the datagram that has become available.
 *
 * The return value is true if a datagram was successfully returned, or false
 * if there was, in fact, no datagram available.  (This may happen if there
 * are multiple threads accessing the QueuedConnectionReader).
 */ 2 4 this 3 451  6 result 1 416  
166 0 0 6 189 413 0 0 0 1 4 this 3 451  
167 0 0 6 190 451 0 0 0 1 4 this 3 413  
168 0 0 6 197 452 0 0 0 1 4 this 3 451  
169 0 0 6 198 451 0 0 0 1 4 this 3 452  
170 0 0 4 192 387 0 0 0 2 4 this 3 452  8 max_size 1 399  
171 0 0 6 193 399 0 0 0 1 4 this 3 453  
172 0 0 6 194 399 0 0 0 1 4 this 3 453  
173 0 0 6 195 386 0 0 0 1 4 this 3 453  
174 0 0 4 196 387 0 0 0 1 4 this 3 452  
175 0 0 7 204 455 224 0 10 /**
 *
 */ 1 7 manager 1 407  
176 0 0 6 205 386 0 0 108 /**
 * Returns true if a datagram is available on the queue; call get_data() to
 * extract the datagram.
 */ 1 4 this 3 455  
177 0 0 6 206 386 0 0 295 /**
 * This flavor of RecentConnectionReader::get_data(), works like the other,
 * except that it only fills a Datagram object, not a NetDatagram object.
 * This means that the Datagram cannot be queried for its source Connection
 * and/or NetAddress, but it is useful in all other respects.
 */ 2 4 this 3 455  6 result 1 431  
178 0 0 6 206 386 0 0 353 /**
 * If a previous call to data_available() returned true, this function will
 * return the datagram that has become available.
 *
 * The return value is true if a datagram was successfully returned, or false
 * if there was, in fact, no datagram available.  (This may happen if there
 * are multiple threads accessing the RecentConnectionReader).
 */ 2 4 this 3 455  6 result 1 416  
102
354 23 PointerTo< Connection > 0 141313 23 PointerTo< Connection > 23 PointerTo< Connection > 0 0 0 1 181 186 0 4 182 183 184 185 0 0 1 0 355 0 0 0 0 0

355 27 PointerToBase< Connection > 0 43009 27 PointerToBase< Connection > 27 PointerToBase< Connection > 0 0 0 0 0 0 2 179 180 0 0 1 0 356 0 0 0 0 0

356 13 PointerToVoid 0 2049 13 PointerToVoid 13 PointerToVoid 0 0 0 0 0 0 0 0 0 0 0 0 373
/**
 * This is the non-template part of the base class for PointerTo and
 * ConstPointerTo.  It is necessary so we can keep a pointer to a non-template
 * class within the ReferenceCount object, to implement weak reference
 * pointers--we need to have something to clean up when the ReferenceCount
 * object destructs.
 *
 * This is the base class for PointerToBase<T>.
 */

357 10 NetAddress 0 141313 10 NetAddress 10 NetAddress 0 0 0 1 187 204 0 16 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 0 0 0 0 0 114
/**
 * Represents a network address to which UDP packets may be sent or to which a
 * TCP socket may be bound.
 */

358 10 Connection 0 75777 10 Connection 10 Connection 0 0 0 1 205 0 0 18 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 0 0 1 0 359 0 0 0 0 69
/**
 * Represents a single TCP or UDP socket for input or output.
 */

359 14 ReferenceCount 0 2049 14 ReferenceCount 14 ReferenceCount 0 0 0 0 0 0 0 0 0 0 0 0 203
/**
 * A base class for all things that want to be reference-counted.
 * ReferenceCount works in conjunction with PointerTo to automatically delete
 * objects when the last pointer to them goes away.
 */

360 16 ConnectionReader 0 26625 16 ConnectionReader 16 ConnectionReader 0 0 0 0 224 0 12 225 226 227 228 229 230 231 232 233 234 235 236 0 0 0 0 0 844
/**
 * This is an abstract base class for a family of classes that listen for
 * activity on a socket and respond to it, for instance by reading a datagram
 * and serving it (or queueing it up for later service).
 *
 * A ConnectionReader may define an arbitrary number of threads (at least one)
 * to process datagrams coming in from an arbitrary number of sockets that it
 * is monitoring.  The number of threads is specified at construction time and
 * cannot be changed, but the set of sockets that is to be monitored may be
 * constantly modified at will.
 *
 * This is an abstract class because it doesn't define how to process each
 * received datagram.  See QueuedConnectionReader.  Also note that
 * ConnectionListener derives from this class, extending it to accept
 * connections on a rendezvous socket rather than read datagrams.
 */

361 18 ConnectionListener 0 141313 18 ConnectionListener 18 ConnectionListener 0 0 0 0 237 0 0 0 0 1 0 360 0 0 0 0 339
/**
 * This is a special kind of ConnectionReader that waits for activity on a
 * rendezvous port and accepts a TCP connection (instead of attempting to read
 * a datagram from the rendezvous port).
 *
 * It is itself an abstract class, as it doesn't define what to do with the
 * established connection.  See QueuedConnectionListener.
 */

362 11 NetDatagram 0 141313 11 NetDatagram 11 NetDatagram 0 0 0 1 238 245 0 6 239 240 241 242 243 244 0 0 1 0 363 0 0 0 0 219
/**
 * A specific kind of Datagram, especially for sending across or receiving
 * from a network.  It's different only in that it knows which Connection
 * and/or NetAddress it is to be sent to or was received from.
 */

363 8 Datagram 0 2049 8 Datagram 8 Datagram 0 0 0 0 0 0 0 0 0 0 0 0 565
/**
 * An ordered list of data elements, formatted in memory for transmission over
 * a socket or writing to a data file.
 *
 * Data elements should be added one at a time, in order, to the Datagram.
 * The nature and contents of the data elements are totally up to the user.
 * When a Datagram has been transmitted and received, its data elements may be
 * extracted using a DatagramIterator; it is up to the caller to know the
 * correct type of each data element in order.
 *
 * A Datagram is itself headerless; it is simply a collection of data
 * elements.
 */

364 17 ConnectionManager 0 26625 17 ConnectionManager 17 ConnectionManager 0 0 0 1 246 247 2 456 457 9 248 249 250 251 252 253 267 268 269 1 458 0 0 0 1 365 573
/**
 * The primary interface to the low-level networking layer in this package.  A
 * ConnectionManager is used to establish and destroy TCP and UDP connections.
 * Communication on these connections, once established, is handled via
 * ConnectionReader, ConnectionWriter, and ConnectionListener.
 *
 * You may use this class directly if you don't care about tracking which
 * connections have been unexpectedly closed; otherwise, you should use
 * QueuedConnectionManager to get reports about these events (or derive your
 * own class to handle these events properly).
 */

365 9 Interface 0 403457 28 ConnectionManager::Interface 28 ConnectionManager::Interface 364 0 0 1 265 266 0 11 254 255 256 257 258 259 260 261 262 263 264 0 0 0 0 0 0

366 6 string 0 2105344 11 std::string 11 std::string 0 0 367 0 0 0 0 0 0 0 0 0 0

367 20 basic_string< char > 0 2048 25 std::basic_string< char > 25 std::basic_string< char > 0 0 0 0 0 0 0 0 0 0 0 0 0

368 15 Interface const 0 8832 34 ConnectionManager::Interface const 34 ConnectionManager::Interface const 0 0 365 0 0 0 0 0 0 0 0 0 0

369 16 ConnectionWriter 0 26625 16 ConnectionWriter 16 ConnectionWriter 0 0 0 1 270 271 0 13 272 273 274 275 276 277 278 279 280 281 282 283 284 0 0 0 0 0 294
/**
 * This class handles threaded delivery of datagrams to various TCP or UDP
 * sockets.
 *
 * A ConnectionWriter may define an arbitrary number of threads (0 or more) to
 * write its datagrams to sockets.  The number of threads is specified at
 * construction time and cannot be changed.
 */

370 20 DatagramGeneratorNet 0 26625 20 DatagramGeneratorNet 20 DatagramGeneratorNet 0 0 0 1 296 297 0 3 298 299 300 0 0 3 3 371 285 286 3 360 287 288 3 372 294 295 0 0 186
/**
 * This class provides datagrams one-at-a-time as read directly from the net,
 * via a TCP connection.  If a datagram is not available, get_datagram() will
 * block until one is.
 */

371 17 DatagramGenerator 0 2049 17 DatagramGenerator 17 DatagramGenerator 0 0 0 0 0 0 0 0 0 0 0 0 125
/**
 * This class defines the abstract interace to any source of datagrams,
 * whether it be from a file or from the net.
 */

372 24 QueuedReturn< Datagram > 0 43009 24 QueuedReturn< Datagram > 24 QueuedReturn< Datagram > 0 0 0 0 0 0 5 289 290 291 292 293 0 0 0 0 0 0

373 15 DatagramSinkNet 0 141313 15 DatagramSinkNet 15 DatagramSinkNet 0 0 0 1 305 311 0 5 306 307 308 309 310 0 0 2 3 374 301 302 3 369 303 304 0 0 107
/**
 * This class accepts datagrams one-at-a-time and sends them over the net, via
 * a TCP connection.
 */

374 12 DatagramSink 0 2049 12 DatagramSink 12 DatagramSink 0 0 0 0 0 0 0 0 0 0 0 0 135
/**
 * This class defines the abstract interface to sending datagrams to any
 * target, whether it be into a file or across the net
 */

375 24 QueuedConnectionListener 0 26625 24 QueuedConnectionListener 24 QueuedConnectionListener 0 0 0 1 321 322 0 2 323 324 0 0 2 3 361 312 313 3 376 319 320 0 0 143
/**
 * This flavor of ConnectionListener will queue up all of the TCP connections
 * it established for later detection by the client code.
 */

376 38 QueuedReturn< ConnectionListenerData > 0 43009 38 QueuedReturn< ConnectionListenerData > 38 QueuedReturn< ConnectionListenerData > 0 0 0 0 0 0 5 314 315 316 317 318 0 0 0 0 0 0

377 23 QueuedConnectionManager 0 26625 23 QueuedConnectionManager 23 QueuedConnectionManager 0 0 0 1 334 335 0 2 336 337 0 0 2 3 364 325 326 3 378 332 333 0 0 423
/**
 * This flavor of ConnectionManager will queue up all of the reset-connection
 * messages from the ConnectionReaders and ConnectionWriters and report them
 * to the client on demand.
 *
 * When a reset connection has been discovered via
 * reset_connection_available()/get_reset_connection(), it is still the
 * responsibility of the client to call close_connection() on that connection
 * to free up its resources.
 */

378 39 QueuedReturn< PointerTo< Connection > > 0 43009 39 QueuedReturn< PointerTo< Connection > > 39 QueuedReturn< PointerTo< Connection > > 0 0 0 0 0 0 5 327 328 329 330 331 0 0 0 0 0 0

379 22 QueuedConnectionReader 0 26625 22 QueuedConnectionReader 22 QueuedConnectionReader 0 0 0 1 347 348 0 2 349 350 0 0 2 3 360 338 339 3 380 345 346 0 0 291
/**
 * This flavor of ConnectionReader will read from its sockets and queue up all
 * of the datagrams read for later receipt by the client code.  This class is
 * useful for client code that doesn't want to deal with threading and is
 * willing to poll for datagrams at its convenience.
 */

380 27 QueuedReturn< NetDatagram > 0 43009 27 QueuedReturn< NetDatagram > 27 QueuedReturn< NetDatagram > 0 0 0 0 0 0 5 340 341 342 343 344 0 0 0 0 0 0

381 22 RecentConnectionReader 0 75777 22 RecentConnectionReader 22 RecentConnectionReader 0 0 0 1 351 224 0 2 352 353 0 0 1 0 360 0 0 0 0 430
/**
 * This flavor of ConnectionReader will read from its sockets and retain only
 * the single most recent datagram for inspection by client code.  It's useful
 * particularly for reading telemetry-type data from UDP sockets where you
 * don't care about getting every last socket, and in fact if the sockets are
 * coming too fast you'd prefer to skip some of them.
 *
 * This class will always create one thread for itself.
 */

382 25 PointerTo< Connection > * 0 8576 25 PointerTo< Connection > * 25 PointerTo< Connection > * 0 0 354 0 0 0 0 0 0 0 0 0 0

383 12 Connection * 0 8576 12 Connection * 12 Connection * 0 0 358 0 0 0 0 0 0 0 0 0 0

384 31 PointerTo< Connection > const * 0 8576 31 PointerTo< Connection > const * 31 PointerTo< Connection > const * 0 0 385 0 0 0 0 0 0 0 0 0 0

385 29 PointerTo< Connection > const 0 8832 29 PointerTo< Connection > const 29 PointerTo< Connection > const 0 0 354 0 0 0 0 0 0 0 0 0 0

386 4 bool 0 8194 4 bool 4 bool 0 4 0 0 0 0 0 0 0 0 0 0 0

387 4 void 0 8194 4 void 4 void 0 6 0 0 0 0 0 0 0 0 0 0 0

388 29 PointerToBase< Connection > * 0 8576 29 PointerToBase< Connection > * 29 PointerToBase< Connection > * 0 0 355 0 0 0 0 0 0 0 0 0 0

389 35 PointerToBase< Connection > const * 0 8576 35 PointerToBase< Connection > const * 35 PointerToBase< Connection > const * 0 0 390 0 0 0 0 0 0 0 0 0 0

390 33 PointerToBase< Connection > const 0 8832 33 PointerToBase< Connection > const 33 PointerToBase< Connection > const 0 0 355 0 0 0 0 0 0 0 0 0 0

391 9 ostream * 0 8576 9 ostream * 9 ostream * 0 0 392 0 0 0 0 0 0 0 0 0 0

392 7 ostream 0 2048 7 ostream 7 ostream 0 0 0 0 0 0 0 0 0 0 0 0 0

393 12 NetAddress * 0 8576 12 NetAddress * 12 NetAddress * 0 0 357 0 0 0 0 0 0 0 0 0 0

394 18 NetAddress const * 0 8576 18 NetAddress const * 18 NetAddress const * 0 0 395 0 0 0 0 0 0 0 0 0 0

395 16 NetAddress const 0 8832 16 NetAddress const 16 NetAddress const 0 0 357 0 0 0 0 0 0 0 0 0 0

396 22 Socket_Address const * 0 8576 22 Socket_Address const * 22 Socket_Address const * 0 0 397 0 0 0 0 0 0 0 0 0 0

397 20 Socket_Address const 0 8832 20 Socket_Address const 20 Socket_Address const 0 0 398 0 0 0 0 0 0 0 0 0 0

398 14 Socket_Address 0 2048 14 Socket_Address 14 Socket_Address 0 0 0 0 0 0 0 0 0 0 0 0 97
/**
 * A simple place to store and manipulate tcp and port address for
 * communication layer
 */

399 3 int 0 8194 3 int 3 int 0 1 0 0 0 0 0 0 0 0 0 0 0

400 13 atomic string 0 2 13 atomic string 13 atomic string 0 7 0 0 0 0 0 0 0 0 0 0 0

401 8 uint32_t 0 2105344 8 uint32_t 8 uint32_t 0 0 402 0 0 0 0 0 0 0 0 0 0

402 12 unsigned int 0 8198 12 unsigned int 12 unsigned int 0 1 0 0 0 0 0 0 0 0 0 0 0

403 7 uint8_t 0 2105344 7 uint8_t 7 uint8_t 0 0 404 0 0 0 0 0 0 0 0 0 0

404 13 unsigned char 0 8198 13 unsigned char 13 unsigned char 0 5 0 0 0 0 0 0 0 0 0 0 0

405 6 size_t 0 2105344 11 std::size_t 11 std::size_t 0 0 406 0 0 0 0 0 0 0 0 0 0

406 17 unsigned long int 0 8214 17 unsigned long int 17 unsigned long int 0 1 0 0 0 0 0 0 0 0 0 0 0

407 19 ConnectionManager * 0 8576 19 ConnectionManager * 19 ConnectionManager * 0 0 364 0 0 0 0 0 0 0 0 0 0

408 11 Socket_IP * 0 8576 11 Socket_IP * 11 Socket_IP * 0 0 409 0 0 0 0 0 0 0 0 0 0

409 9 Socket_IP 0 2048 9 Socket_IP 9 Socket_IP 0 0 0 0 0 0 0 0 0 0 0 0 354
/**
 * Base functionality for a INET domain Socket This call should be the
 * starting point for all other unix domain sockets.
 *
 * SocketIP |
 * ------------------------------------------------------------------- |
 * |                       |                           | SocketTCP
 * SocketTCP_Listen    SocketUDP_Incoming   SocketUDP_OutBound
 *
 */

410 18 Connection const * 0 8576 18 Connection const * 18 Connection const * 0 0 411 0 0 0 0 0 0 0 0 0 0

411 16 Connection const 0 8832 16 Connection const 16 Connection const 0 0 358 0 0 0 0 0 0 0 0 0 0

412 6 double 0 8194 6 double 6 double 0 3 0 0 0 0 0 0 0 0 0 0 0

413 18 ConnectionReader * 0 8576 18 ConnectionReader * 18 ConnectionReader * 0 0 360 0 0 0 0 0 0 0 0 0 0

414 24 ConnectionReader const * 0 8576 24 ConnectionReader const * 24 ConnectionReader const * 0 0 415 0 0 0 0 0 0 0 0 0 0

415 22 ConnectionReader const 0 8832 22 ConnectionReader const 22 ConnectionReader const 0 0 360 0 0 0 0 0 0 0 0 0 0

416 13 NetDatagram * 0 8576 13 NetDatagram * 13 NetDatagram * 0 0 362 0 0 0 0 0 0 0 0 0 0

417 16 Datagram const * 0 8576 16 Datagram const * 16 Datagram const * 0 0 418 0 0 0 0 0 0 0 0 0 0

418 14 Datagram const 0 8832 14 Datagram const 14 Datagram const 0 0 363 0 0 0 0 0 0 0 0 0 0

419 19 NetDatagram const * 0 8576 19 NetDatagram const * 19 NetDatagram const * 0 0 420 0 0 0 0 0 0 0 0 0 0

420 17 NetDatagram const 0 8832 17 NetDatagram const 17 NetDatagram const 0 0 362 0 0 0 0 0 0 0 0 0 0

421 10 TypeHandle 0 2048 10 TypeHandle 10 TypeHandle 0 0 0 0 0 0 0 0 0 0 0 0 732
/**
 * TypeHandle is the identifier used to differentiate C++ class types.  Any
 * C++ classes that inherit from some base class, and must be differentiated
 * at run time, should store a static TypeHandle object that can be queried
 * through a static member function named get_class_type().  Most of the time,
 * it is also desirable to inherit from TypedObject, which provides some
 * virtual functions to return the TypeHandle for a particular instance.
 *
 * At its essence, a TypeHandle is simply a unique identifier that is assigned
 * by the TypeRegistry.  The TypeRegistry stores a tree of TypeHandles, so
 * that ancestry of a particular type may be queried, and the type name may be
 * retrieved for run-time display.
 */

422 12 TypeHandle * 0 8576 12 TypeHandle * 12 TypeHandle * 0 0 421 0 0 0 0 0 0 0 0 0 0

423 8 uint16_t 0 2105344 8 uint16_t 8 uint16_t 0 0 424 0 0 0 0 0 0 0 0 0 0

424 18 unsigned short int 0 8262 18 unsigned short int 18 unsigned short int 0 1 0 0 0 0 0 0 0 0 0 0 0

425 17 Interface const * 0 8576 36 ConnectionManager::Interface const * 36 ConnectionManager::Interface const * 0 0 368 0 0 0 0 0 0 0 0 0 0

426 11 Interface * 0 8576 30 ConnectionManager::Interface * 30 ConnectionManager::Interface * 0 0 365 0 0 0 0 0 0 0 0 0 0

427 18 ConnectionWriter * 0 8576 18 ConnectionWriter * 18 ConnectionWriter * 0 0 369 0 0 0 0 0 0 0 0 0 0

428 24 ConnectionWriter const * 0 8576 24 ConnectionWriter const * 24 ConnectionWriter const * 0 0 429 0 0 0 0 0 0 0 0 0 0

429 22 ConnectionWriter const 0 8832 22 ConnectionWriter const 22 ConnectionWriter const 0 0 369 0 0 0 0 0 0 0 0 0 0

430 22 DatagramGeneratorNet * 0 8576 22 DatagramGeneratorNet * 22 DatagramGeneratorNet * 0 0 370 0 0 0 0 0 0 0 0 0 0

431 10 Datagram * 0 8576 10 Datagram * 10 Datagram * 0 0 363 0 0 0 0 0 0 0 0 0 0

432 19 DatagramGenerator * 0 8576 19 DatagramGenerator * 19 DatagramGenerator * 0 0 371 0 0 0 0 0 0 0 0 0 0

433 26 QueuedReturn< Datagram > * 0 8576 26 QueuedReturn< Datagram > * 26 QueuedReturn< Datagram > * 0 0 372 0 0 0 0 0 0 0 0 0 0

434 32 QueuedReturn< Datagram > const * 0 8576 32 QueuedReturn< Datagram > const * 32 QueuedReturn< Datagram > const * 0 0 435 0 0 0 0 0 0 0 0 0 0

435 30 QueuedReturn< Datagram > const 0 8832 30 QueuedReturn< Datagram > const 30 QueuedReturn< Datagram > const 0 0 372 0 0 0 0 0 0 0 0 0 0

436 17 DatagramSinkNet * 0 8576 17 DatagramSinkNet * 17 DatagramSinkNet * 0 0 373 0 0 0 0 0 0 0 0 0 0

437 23 DatagramSinkNet const * 0 8576 23 DatagramSinkNet const * 23 DatagramSinkNet const * 0 0 438 0 0 0 0 0 0 0 0 0 0

438 21 DatagramSinkNet const 0 8832 21 DatagramSinkNet const 21 DatagramSinkNet const 0 0 373 0 0 0 0 0 0 0 0 0 0

439 14 DatagramSink * 0 8576 14 DatagramSink * 14 DatagramSink * 0 0 374 0 0 0 0 0 0 0 0 0 0

440 26 QueuedConnectionListener * 0 8576 26 QueuedConnectionListener * 26 QueuedConnectionListener * 0 0 375 0 0 0 0 0 0 0 0 0 0

441 20 ConnectionListener * 0 8576 20 ConnectionListener * 20 ConnectionListener * 0 0 361 0 0 0 0 0 0 0 0 0 0

442 40 QueuedReturn< ConnectionListenerData > * 0 8576 40 QueuedReturn< ConnectionListenerData > * 40 QueuedReturn< ConnectionListenerData > * 0 0 376 0 0 0 0 0 0 0 0 0 0

443 46 QueuedReturn< ConnectionListenerData > const * 0 8576 46 QueuedReturn< ConnectionListenerData > const * 46 QueuedReturn< ConnectionListenerData > const * 0 0 444 0 0 0 0 0 0 0 0 0 0

444 44 QueuedReturn< ConnectionListenerData > const 0 8832 44 QueuedReturn< ConnectionListenerData > const 44 QueuedReturn< ConnectionListenerData > const 0 0 376 0 0 0 0 0 0 0 0 0 0

445 25 QueuedConnectionManager * 0 8576 25 QueuedConnectionManager * 25 QueuedConnectionManager * 0 0 377 0 0 0 0 0 0 0 0 0 0

446 31 QueuedConnectionManager const * 0 8576 31 QueuedConnectionManager const * 31 QueuedConnectionManager const * 0 0 447 0 0 0 0 0 0 0 0 0 0

447 29 QueuedConnectionManager const 0 8832 29 QueuedConnectionManager const 29 QueuedConnectionManager const 0 0 377 0 0 0 0 0 0 0 0 0 0

448 41 QueuedReturn< PointerTo< Connection > > * 0 8576 41 QueuedReturn< PointerTo< Connection > > * 41 QueuedReturn< PointerTo< Connection > > * 0 0 378 0 0 0 0 0 0 0 0 0 0

449 47 QueuedReturn< PointerTo< Connection > > const * 0 8576 47 QueuedReturn< PointerTo< Connection > > const * 47 QueuedReturn< PointerTo< Connection > > const * 0 0 450 0 0 0 0 0 0 0 0 0 0

450 45 QueuedReturn< PointerTo< Connection > > const 0 8832 45 QueuedReturn< PointerTo< Connection > > const 45 QueuedReturn< PointerTo< Connection > > const 0 0 378 0 0 0 0 0 0 0 0 0 0

451 24 QueuedConnectionReader * 0 8576 24 QueuedConnectionReader * 24 QueuedConnectionReader * 0 0 379 0 0 0 0 0 0 0 0 0 0

452 29 QueuedReturn< NetDatagram > * 0 8576 29 QueuedReturn< NetDatagram > * 29 QueuedReturn< NetDatagram > * 0 0 380 0 0 0 0 0 0 0 0 0 0

453 35 QueuedReturn< NetDatagram > const * 0 8576 35 QueuedReturn< NetDatagram > const * 35 QueuedReturn< NetDatagram > const * 0 0 454 0 0 0 0 0 0 0 0 0 0

454 33 QueuedReturn< NetDatagram > const 0 8832 33 QueuedReturn< NetDatagram > const 33 QueuedReturn< NetDatagram > const 0 0 380 0 0 0 0 0 0 0 0 0 0

455 24 RecentConnectionReader * 0 8576 24 RecentConnectionReader * 24 RecentConnectionReader * 0 0 381 0 0 0 0 0 0 0 0 0 0

0
2
456 9 host_name 0 2 366 253 0 0 0 0 0 28 ConnectionManager::host_name 0

457 10 interfaces 0 66 368 269 0 0 0 0 268 29 ConnectionManager::interfaces 0

1
458 14 get_interfaces 0 268 269 33 ConnectionManager::get_interfaces 0

