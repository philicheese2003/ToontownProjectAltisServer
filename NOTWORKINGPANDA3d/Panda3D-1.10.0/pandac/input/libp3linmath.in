1494874276
3 2
12 libp3linmath 4 Ns0b 12 panda3d.core 
1526
1936 11 MathNumbers 0 4 3462 24 MathNumbers::MathNumbers 0 2 1 2 0
112
inline MathNumbers::MathNumbers(void) = default;
inline MathNumbers::MathNumbers(MathNumbers const &) = default;

1937 12 ~MathNumbers 0 4 3462 25 MathNumbers::~MathNumbers 0 0 0
32
MathNumbers::~MathNumbers(void);

1938 9 deg_2_rad 0 1 0 9 deg_2_rad 0 2 1846 1847 0
67
inline double deg_2_rad(double f);
inline float deg_2_rad(float f);

1939 9 rad_2_deg 0 1 0 9 rad_2_deg 0 2 1848 1849 0
67
inline double rad_2_deg(double f);
inline float rad_2_deg(float f);

1940 10 LVecBase2f 0 4 3463 22 LVecBase2f::LVecBase2f 0 4 3 4 5 6 22
/**
 *
 */

/**
 *
 */
205
inline LVecBase2f::LVecBase2f(void) = default;
inline LVecBase2f::LVecBase2f(float fill_value);
inline LVecBase2f::LVecBase2f(float x, float y);
inline LVecBase2f::LVecBase2f(LVecBase2f const &) = default;

1941 12 operator new 0 4 3463 24 LVecBase2f::operator new 0 1 7 0
124
inline void *LVecBase2f::operator new(std::size_t size);
inline void *LVecBase2f::operator new(std::size_t size, void *ptr);

1942 15 operator delete 0 4 3463 27 LVecBase2f::operator delete 0 0 0
108
inline void LVecBase2f::operator delete(void *ptr);
inline void LVecBase2f::operator delete(void *, void *);

1943 12 validate_ptr 0 4 3463 24 LVecBase2f::validate_ptr 0 0 0
61
static inline bool LVecBase2f::validate_ptr(void const *ptr);

1944 10 operator = 0 4 3463 22 LVecBase2f::operator = 0 2 8 9 0
133
LVecBase2f &LVecBase2f::operator =(LVecBase2f const &copy) = default;
LVecBase2f &LVecBase2f::operator =(float fill_value) = default;

1945 4 zero 0 4 3463 16 LVecBase2f::zero 0 1 10 40
/**
 * Returns a zero-length vector.
 */
55
static inline LVecBase2f const &LVecBase2f::zero(void);

1946 6 unit_x 0 4 3463 18 LVecBase2f::unit_x 0 1 11 35
/**
 * Returns a unit X vector.
 */
57
static inline LVecBase2f const &LVecBase2f::unit_x(void);

1947 6 unit_y 0 4 3463 18 LVecBase2f::unit_y 0 1 12 35
/**
 * Returns a unit Y vector.
 */
57
static inline LVecBase2f const &LVecBase2f::unit_y(void);

1948 10 __reduce__ 0 4 3463 22 LVecBase2f::__reduce__ 0 1 13 0
62
inline PyObject *LVecBase2f::__reduce__(PyObject *self) const;

1949 11 __getattr__ 0 4 3463 23 LVecBase2f::__getattr__ 0 1 14 0
93
inline PyObject *LVecBase2f::__getattr__(PyObject *self, std::string const &attr_name) const;

1950 11 __setattr__ 0 4 3463 23 LVecBase2f::__setattr__ 0 1 15 0
99
inline int LVecBase2f::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

1951 11 operator [] 0 4 3463 23 LVecBase2f::operator [] 0 2 16 17 10
/**
 *
 */
96
inline float LVecBase2f::operator [](int i) const;
inline float &LVecBase2f::operator [](int i);

1952 4 size 0 4 3463 16 LVecBase2f::size 0 1 18 0
44
static constexpr int LVecBase2f::size(void);

1953 6 is_nan 0 4 3463 18 LVecBase2f::is_nan 0 1 19 91
/**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */
43
inline bool LVecBase2f::is_nan(void) const;

1954 8 get_cell 0 4 3463 20 LVecBase2f::get_cell 0 1 20 10
/**
 *
 */
47
inline float LVecBase2f::get_cell(int i) const;

1955 8 set_cell 0 4 3463 20 LVecBase2f::set_cell 0 1 21 10
/**
 *
 */
53
inline void LVecBase2f::set_cell(int i, float value);

1956 5 get_x 0 4 3463 17 LVecBase2f::get_x 0 1 22 10
/**
 *
 */
43
inline float LVecBase2f::get_x(void) const;

1957 5 get_y 0 4 3463 17 LVecBase2f::get_y 0 1 23 10
/**
 *
 */
43
inline float LVecBase2f::get_y(void) const;

1958 5 set_x 0 4 3463 17 LVecBase2f::set_x 0 1 24 10
/**
 *
 */
43
inline void LVecBase2f::set_x(float value);

1959 5 set_y 0 4 3463 17 LVecBase2f::set_y 0 1 25 10
/**
 *
 */
43
inline void LVecBase2f::set_y(float value);

1960 11 add_to_cell 0 4 3463 23 LVecBase2f::add_to_cell 0 1 26 164
// These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages:

/**
 *
 */
56
inline void LVecBase2f::add_to_cell(int i, float value);

1961 5 add_x 0 4 3463 17 LVecBase2f::add_x 0 1 27 10
/**
 *
 */
43
inline void LVecBase2f::add_x(float value);

1962 5 add_y 0 4 3463 17 LVecBase2f::add_y 0 1 28 10
/**
 *
 */
43
inline void LVecBase2f::add_y(float value);

1963 8 get_data 0 4 3463 20 LVecBase2f::get_data 0 1 29 155
/**
 * Returns the address of the first of the two data elements in the vector.
 * The next element occupies the next position consecutively in memory.
 */
53
inline float const *LVecBase2f::get_data(void) const;

1964 18 get_num_components 0 4 3463 30 LVecBase2f::get_num_components 0 1 30 0
58
static constexpr int LVecBase2f::get_num_components(void);

1965 4 fill 0 4 3463 16 LVecBase2f::fill 0 1 31 129
/**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */
47
inline void LVecBase2f::fill(float fill_value);

1966 3 set 0 4 3463 15 LVecBase2f::set 0 1 32 10
/**
 *
 */
46
inline void LVecBase2f::set(float x, float y);

1967 3 dot 0 4 3463 15 LVecBase2f::dot 0 1 33 10
/**
 *
 */
60
inline float LVecBase2f::dot(LVecBase2f const &other) const;

1968 14 length_squared 0 4 3463 26 LVecBase2f::length_squared 0 1 34 69
/**
 * Returns the square of the vector's length, cheap and easy.
 */
52
inline float LVecBase2f::length_squared(void) const;

1969 6 length 0 4 3463 18 LVecBase2f::length 0 1 35 72
/**
 * Returns the length of the vector, by the Pythagorean theorem.
 */
44
inline float LVecBase2f::length(void) const;

1970 9 normalize 0 4 3463 21 LVecBase2f::normalize 0 1 36 127
/**
 * Normalizes the vector in place.  Returns true if the vector was normalized,
 * false if it was a zero-length vector.
 */
40
inline bool LVecBase2f::normalize(void);

1971 10 normalized 0 4 3463 22 LVecBase2f::normalized 0 1 37 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
53
inline LVecBase2f LVecBase2f::normalized(void) const;

1972 7 project 0 4 3463 19 LVecBase2f::project 0 1 38 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
68
inline LVecBase2f LVecBase2f::project(LVecBase2f const &onto) const;

1973 10 operator < 0 4 3463 22 LVecBase2f::operator < 0 1 39 0
66
inline bool LVecBase2f::operator <(LVecBase2f const &other) const;

1974 11 operator == 0 4 3463 23 LVecBase2f::operator == 0 1 40 0
67
inline bool LVecBase2f::operator ==(LVecBase2f const &other) const;

1975 11 operator != 0 4 3463 23 LVecBase2f::operator != 0 1 41 0
67
inline bool LVecBase2f::operator !=(LVecBase2f const &other) const;

1976 10 compare_to 0 4 3463 22 LVecBase2f::compare_to 0 2 42 43 332
/**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */

/**
 * Sorts vectors lexicographically, componentwise.  Returns a number less than
 * 0 if this vector sorts before the other one, greater than zero if it sorts
 * after, 0 if they are equivalent (within the indicated tolerance).
 */
148
inline int LVecBase2f::compare_to(LVecBase2f const &other) const;
inline int LVecBase2f::compare_to(LVecBase2f const &other, float threshold) const;

1977 8 get_hash 0 4 3463 20 LVecBase2f::get_hash 0 2 44 45 100
/**
 * Returns a suitable hash for phash_map.
 */

/**
 * Returns a suitable hash for phash_map.
 */
116
inline std::size_t LVecBase2f::get_hash(void) const;
inline std::size_t LVecBase2f::get_hash(float threshold) const;

1978 8 add_hash 0 4 3463 20 LVecBase2f::add_hash 0 2 46 47 100
/**
 * Adds the vector into the running hash.
 */

/**
 * Adds the vector into the running hash.
 */
146
inline std::size_t LVecBase2f::add_hash(std::size_t hash) const;
inline std::size_t LVecBase2f::add_hash(std::size_t hash, float threshold) const;

1979 13 generate_hash 0 4 3463 25 LVecBase2f::generate_hash 0 2 48 49 120
/**
 * Adds the vector to the indicated hash generator.
 */

/**
 * Adds the vector to the indicated hash generator.
 */
170
inline void LVecBase2f::generate_hash(ChecksumHashGenerator &hashgen) const;
inline void LVecBase2f::generate_hash(ChecksumHashGenerator &hashgen, float threshold) const;

1980 10 operator - 0 68 3463 22 LVecBase2f::operator - 0 1 50 0
53
inline LVecBase2f LVecBase2f::operator -(void) const;

1981 10 operator + 0 4 3463 22 LVecBase2f::operator + 0 1 51 0
72
inline LVecBase2f LVecBase2f::operator +(LVecBase2f const &other) const;

1982 10 operator - 0 4 3463 22 LVecBase2f::operator - 0 1 52 0
72
inline LVecBase2f LVecBase2f::operator -(LVecBase2f const &other) const;

1983 10 operator * 0 4 3463 22 LVecBase2f::operator * 0 1 53 0
61
inline LVecBase2f LVecBase2f::operator *(float scalar) const;

1984 10 operator / 0 4 3463 22 LVecBase2f::operator / 0 1 54 0
61
inline LVecBase2f LVecBase2f::operator /(float scalar) const;

1985 11 operator += 0 4 3463 23 LVecBase2f::operator += 0 1 55 0
61
inline void LVecBase2f::operator +=(LVecBase2f const &other);

1986 11 operator -= 0 4 3463 23 LVecBase2f::operator -= 0 1 56 0
61
inline void LVecBase2f::operator -=(LVecBase2f const &other);

1987 11 operator *= 0 4 3463 23 LVecBase2f::operator *= 0 1 57 0
50
inline void LVecBase2f::operator *=(float scalar);

1988 11 operator /= 0 4 3463 23 LVecBase2f::operator /= 0 1 58 0
50
inline void LVecBase2f::operator /=(float scalar);

1989 18 componentwise_mult 0 4 3463 30 LVecBase2f::componentwise_mult 0 1 59 10
/**
 *
 */
68
inline void LVecBase2f::componentwise_mult(LVecBase2f const &other);

1990 7 __pow__ 0 4 3463 19 LVecBase2f::__pow__ 0 1 60 0
60
inline LVecBase2f LVecBase2f::__pow__(float exponent) const;

1991 8 __ipow__ 0 4 3463 20 LVecBase2f::__ipow__ 0 1 61 0
70
inline PyObject *LVecBase2f::__ipow__(PyObject *self, float exponent);

1992 4 fmax 0 4 3463 16 LVecBase2f::fmax 0 1 62 10
/**
 *
 */
66
inline LVecBase2f LVecBase2f::fmax(LVecBase2f const &other) const;

1993 4 fmin 0 4 3463 16 LVecBase2f::fmin 0 1 63 10
/**
 *
 */
66
inline LVecBase2f LVecBase2f::fmin(LVecBase2f const &other) const;

1994 12 almost_equal 0 4 3463 24 LVecBase2f::almost_equal 0 2 64 65 210
/**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */

/**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */
154
inline bool LVecBase2f::almost_equal(LVecBase2f const &other, float threshold) const;
inline bool LVecBase2f::almost_equal(LVecBase2f const &other) const;

1995 6 output 0 4 3463 18 LVecBase2f::output 0 1 66 10
/**
 *
 */
51
inline void LVecBase2f::output(ostream &out) const;

1996 8 __repr__ 0 4 3463 20 LVecBase2f::__repr__ 0 1 67 0
52
inline std::string LVecBase2f::__repr__(void) const;

1997 20 write_datagram_fixed 0 4 3463 32 LVecBase2f::write_datagram_fixed 0 1 68 332
/**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */
74
inline void LVecBase2f::write_datagram_fixed(Datagram &destination) const;

1998 19 read_datagram_fixed 0 4 3463 31 LVecBase2f::read_datagram_fixed 0 1 69 114
/**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */
70
inline void LVecBase2f::read_datagram_fixed(DatagramIterator &source);

1999 14 write_datagram 0 4 3463 26 LVecBase2f::write_datagram 0 1 70 205
/**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */
68
inline void LVecBase2f::write_datagram(Datagram &destination) const;

2000 13 read_datagram 0 4 3463 25 LVecBase2f::read_datagram 0 1 71 67
/**
 * Reads the vector from the Datagram using get_stdfloat().
 */
64
inline void LVecBase2f::read_datagram(DatagramIterator &source);

2001 14 get_class_type 0 4 3463 26 LVecBase2f::get_class_type 0 1 72 0
51
static TypeHandle LVecBase2f::get_class_type(void);

2002 11 ~LVecBase2f 0 4 3463 23 LVecBase2f::~LVecBase2f 0 0 0
30
LVecBase2f::~LVecBase2f(void);

2003 10 LVecBase2d 0 4 3466 22 LVecBase2d::LVecBase2d 0 4 73 74 75 76 22
/**
 *
 */

/**
 *
 */
208
inline LVecBase2d::LVecBase2d(void) = default;
inline LVecBase2d::LVecBase2d(double fill_value);
inline LVecBase2d::LVecBase2d(double x, double y);
inline LVecBase2d::LVecBase2d(LVecBase2d const &) = default;

2004 12 operator new 0 4 3466 24 LVecBase2d::operator new 0 1 77 0
124
inline void *LVecBase2d::operator new(std::size_t size);
inline void *LVecBase2d::operator new(std::size_t size, void *ptr);

2005 15 operator delete 0 4 3466 27 LVecBase2d::operator delete 0 0 0
108
inline void LVecBase2d::operator delete(void *ptr);
inline void LVecBase2d::operator delete(void *, void *);

2006 12 validate_ptr 0 4 3466 24 LVecBase2d::validate_ptr 0 0 0
61
static inline bool LVecBase2d::validate_ptr(void const *ptr);

2007 10 operator = 0 4 3466 22 LVecBase2d::operator = 0 2 78 79 0
134
LVecBase2d &LVecBase2d::operator =(LVecBase2d const &copy) = default;
LVecBase2d &LVecBase2d::operator =(double fill_value) = default;

2008 4 zero 0 4 3466 16 LVecBase2d::zero 0 1 80 40
/**
 * Returns a zero-length vector.
 */
55
static inline LVecBase2d const &LVecBase2d::zero(void);

2009 6 unit_x 0 4 3466 18 LVecBase2d::unit_x 0 1 81 35
/**
 * Returns a unit X vector.
 */
57
static inline LVecBase2d const &LVecBase2d::unit_x(void);

2010 6 unit_y 0 4 3466 18 LVecBase2d::unit_y 0 1 82 35
/**
 * Returns a unit Y vector.
 */
57
static inline LVecBase2d const &LVecBase2d::unit_y(void);

2011 10 __reduce__ 0 4 3466 22 LVecBase2d::__reduce__ 0 1 83 0
62
inline PyObject *LVecBase2d::__reduce__(PyObject *self) const;

2012 11 __getattr__ 0 4 3466 23 LVecBase2d::__getattr__ 0 1 84 0
93
inline PyObject *LVecBase2d::__getattr__(PyObject *self, std::string const &attr_name) const;

2013 11 __setattr__ 0 4 3466 23 LVecBase2d::__setattr__ 0 1 85 0
99
inline int LVecBase2d::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2014 11 operator [] 0 4 3466 23 LVecBase2d::operator [] 0 2 86 87 10
/**
 *
 */
98
inline double LVecBase2d::operator [](int i) const;
inline double &LVecBase2d::operator [](int i);

2015 4 size 0 4 3466 16 LVecBase2d::size 0 1 88 0
44
static constexpr int LVecBase2d::size(void);

2016 6 is_nan 0 4 3466 18 LVecBase2d::is_nan 0 1 89 91
/**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */
43
inline bool LVecBase2d::is_nan(void) const;

2017 8 get_cell 0 4 3466 20 LVecBase2d::get_cell 0 1 90 10
/**
 *
 */
48
inline double LVecBase2d::get_cell(int i) const;

2018 8 set_cell 0 4 3466 20 LVecBase2d::set_cell 0 1 91 10
/**
 *
 */
54
inline void LVecBase2d::set_cell(int i, double value);

2019 5 get_x 0 4 3466 17 LVecBase2d::get_x 0 1 92 10
/**
 *
 */
44
inline double LVecBase2d::get_x(void) const;

2020 5 get_y 0 4 3466 17 LVecBase2d::get_y 0 1 93 10
/**
 *
 */
44
inline double LVecBase2d::get_y(void) const;

2021 5 set_x 0 4 3466 17 LVecBase2d::set_x 0 1 94 10
/**
 *
 */
44
inline void LVecBase2d::set_x(double value);

2022 5 set_y 0 4 3466 17 LVecBase2d::set_y 0 1 95 10
/**
 *
 */
44
inline void LVecBase2d::set_y(double value);

2023 11 add_to_cell 0 4 3466 23 LVecBase2d::add_to_cell 0 1 96 164
// These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages:

/**
 *
 */
57
inline void LVecBase2d::add_to_cell(int i, double value);

2024 5 add_x 0 4 3466 17 LVecBase2d::add_x 0 1 97 10
/**
 *
 */
44
inline void LVecBase2d::add_x(double value);

2025 5 add_y 0 4 3466 17 LVecBase2d::add_y 0 1 98 10
/**
 *
 */
44
inline void LVecBase2d::add_y(double value);

2026 8 get_data 0 4 3466 20 LVecBase2d::get_data 0 1 99 155
/**
 * Returns the address of the first of the two data elements in the vector.
 * The next element occupies the next position consecutively in memory.
 */
54
inline double const *LVecBase2d::get_data(void) const;

2027 18 get_num_components 0 4 3466 30 LVecBase2d::get_num_components 0 1 100 0
58
static constexpr int LVecBase2d::get_num_components(void);

2028 4 fill 0 4 3466 16 LVecBase2d::fill 0 1 101 129
/**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */
48
inline void LVecBase2d::fill(double fill_value);

2029 3 set 0 4 3466 15 LVecBase2d::set 0 1 102 10
/**
 *
 */
48
inline void LVecBase2d::set(double x, double y);

2030 3 dot 0 4 3466 15 LVecBase2d::dot 0 1 103 10
/**
 *
 */
61
inline double LVecBase2d::dot(LVecBase2d const &other) const;

2031 14 length_squared 0 4 3466 26 LVecBase2d::length_squared 0 1 104 69
/**
 * Returns the square of the vector's length, cheap and easy.
 */
53
inline double LVecBase2d::length_squared(void) const;

2032 6 length 0 4 3466 18 LVecBase2d::length 0 1 105 72
/**
 * Returns the length of the vector, by the Pythagorean theorem.
 */
45
inline double LVecBase2d::length(void) const;

2033 9 normalize 0 4 3466 21 LVecBase2d::normalize 0 1 106 127
/**
 * Normalizes the vector in place.  Returns true if the vector was normalized,
 * false if it was a zero-length vector.
 */
40
inline bool LVecBase2d::normalize(void);

2034 10 normalized 0 4 3466 22 LVecBase2d::normalized 0 1 107 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
53
inline LVecBase2d LVecBase2d::normalized(void) const;

2035 7 project 0 4 3466 19 LVecBase2d::project 0 1 108 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
68
inline LVecBase2d LVecBase2d::project(LVecBase2d const &onto) const;

2036 10 operator < 0 4 3466 22 LVecBase2d::operator < 0 1 109 0
66
inline bool LVecBase2d::operator <(LVecBase2d const &other) const;

2037 11 operator == 0 4 3466 23 LVecBase2d::operator == 0 1 110 0
67
inline bool LVecBase2d::operator ==(LVecBase2d const &other) const;

2038 11 operator != 0 4 3466 23 LVecBase2d::operator != 0 1 111 0
67
inline bool LVecBase2d::operator !=(LVecBase2d const &other) const;

2039 10 compare_to 0 4 3466 22 LVecBase2d::compare_to 0 2 112 113 332
/**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */

/**
 * Sorts vectors lexicographically, componentwise.  Returns a number less than
 * 0 if this vector sorts before the other one, greater than zero if it sorts
 * after, 0 if they are equivalent (within the indicated tolerance).
 */
149
inline int LVecBase2d::compare_to(LVecBase2d const &other) const;
inline int LVecBase2d::compare_to(LVecBase2d const &other, double threshold) const;

2040 8 get_hash 0 4 3466 20 LVecBase2d::get_hash 0 2 114 115 100
/**
 * Returns a suitable hash for phash_map.
 */

/**
 * Returns a suitable hash for phash_map.
 */
117
inline std::size_t LVecBase2d::get_hash(void) const;
inline std::size_t LVecBase2d::get_hash(double threshold) const;

2041 8 add_hash 0 4 3466 20 LVecBase2d::add_hash 0 2 116 117 100
/**
 * Adds the vector into the running hash.
 */

/**
 * Adds the vector into the running hash.
 */
147
inline std::size_t LVecBase2d::add_hash(std::size_t hash) const;
inline std::size_t LVecBase2d::add_hash(std::size_t hash, double threshold) const;

2042 13 generate_hash 0 4 3466 25 LVecBase2d::generate_hash 0 2 118 119 120
/**
 * Adds the vector to the indicated hash generator.
 */

/**
 * Adds the vector to the indicated hash generator.
 */
171
inline void LVecBase2d::generate_hash(ChecksumHashGenerator &hashgen) const;
inline void LVecBase2d::generate_hash(ChecksumHashGenerator &hashgen, double threshold) const;

2043 10 operator - 0 68 3466 22 LVecBase2d::operator - 0 1 120 0
53
inline LVecBase2d LVecBase2d::operator -(void) const;

2044 10 operator + 0 4 3466 22 LVecBase2d::operator + 0 1 121 0
72
inline LVecBase2d LVecBase2d::operator +(LVecBase2d const &other) const;

2045 10 operator - 0 4 3466 22 LVecBase2d::operator - 0 1 122 0
72
inline LVecBase2d LVecBase2d::operator -(LVecBase2d const &other) const;

2046 10 operator * 0 4 3466 22 LVecBase2d::operator * 0 1 123 0
62
inline LVecBase2d LVecBase2d::operator *(double scalar) const;

2047 10 operator / 0 4 3466 22 LVecBase2d::operator / 0 1 124 0
62
inline LVecBase2d LVecBase2d::operator /(double scalar) const;

2048 11 operator += 0 4 3466 23 LVecBase2d::operator += 0 1 125 0
61
inline void LVecBase2d::operator +=(LVecBase2d const &other);

2049 11 operator -= 0 4 3466 23 LVecBase2d::operator -= 0 1 126 0
61
inline void LVecBase2d::operator -=(LVecBase2d const &other);

2050 11 operator *= 0 4 3466 23 LVecBase2d::operator *= 0 1 127 0
51
inline void LVecBase2d::operator *=(double scalar);

2051 11 operator /= 0 4 3466 23 LVecBase2d::operator /= 0 1 128 0
51
inline void LVecBase2d::operator /=(double scalar);

2052 18 componentwise_mult 0 4 3466 30 LVecBase2d::componentwise_mult 0 1 129 10
/**
 *
 */
68
inline void LVecBase2d::componentwise_mult(LVecBase2d const &other);

2053 7 __pow__ 0 4 3466 19 LVecBase2d::__pow__ 0 1 130 0
61
inline LVecBase2d LVecBase2d::__pow__(double exponent) const;

2054 8 __ipow__ 0 4 3466 20 LVecBase2d::__ipow__ 0 1 131 0
71
inline PyObject *LVecBase2d::__ipow__(PyObject *self, double exponent);

2055 4 fmax 0 4 3466 16 LVecBase2d::fmax 0 1 132 10
/**
 *
 */
66
inline LVecBase2d LVecBase2d::fmax(LVecBase2d const &other) const;

2056 4 fmin 0 4 3466 16 LVecBase2d::fmin 0 1 133 10
/**
 *
 */
66
inline LVecBase2d LVecBase2d::fmin(LVecBase2d const &other) const;

2057 12 almost_equal 0 4 3466 24 LVecBase2d::almost_equal 0 2 134 135 210
/**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */

/**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */
155
inline bool LVecBase2d::almost_equal(LVecBase2d const &other, double threshold) const;
inline bool LVecBase2d::almost_equal(LVecBase2d const &other) const;

2058 6 output 0 4 3466 18 LVecBase2d::output 0 1 136 10
/**
 *
 */
51
inline void LVecBase2d::output(ostream &out) const;

2059 8 __repr__ 0 4 3466 20 LVecBase2d::__repr__ 0 1 137 0
52
inline std::string LVecBase2d::__repr__(void) const;

2060 20 write_datagram_fixed 0 4 3466 32 LVecBase2d::write_datagram_fixed 0 1 138 332
/**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */
74
inline void LVecBase2d::write_datagram_fixed(Datagram &destination) const;

2061 19 read_datagram_fixed 0 4 3466 31 LVecBase2d::read_datagram_fixed 0 1 139 114
/**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */
70
inline void LVecBase2d::read_datagram_fixed(DatagramIterator &source);

2062 14 write_datagram 0 4 3466 26 LVecBase2d::write_datagram 0 1 140 205
/**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */
68
inline void LVecBase2d::write_datagram(Datagram &destination) const;

2063 13 read_datagram 0 4 3466 25 LVecBase2d::read_datagram 0 1 141 67
/**
 * Reads the vector from the Datagram using get_stdfloat().
 */
64
inline void LVecBase2d::read_datagram(DatagramIterator &source);

2064 14 get_class_type 0 4 3466 26 LVecBase2d::get_class_type 0 1 142 0
51
static TypeHandle LVecBase2d::get_class_type(void);

2065 11 ~LVecBase2d 0 4 3466 23 LVecBase2d::~LVecBase2d 0 0 0
30
LVecBase2d::~LVecBase2d(void);

2066 10 LVecBase2i 0 4 3469 22 LVecBase2i::LVecBase2i 0 4 143 144 145 146 22
/**
 *
 */

/**
 *
 */
199
inline LVecBase2i::LVecBase2i(void) = default;
inline LVecBase2i::LVecBase2i(int fill_value);
inline LVecBase2i::LVecBase2i(int x, int y);
inline LVecBase2i::LVecBase2i(LVecBase2i const &) = default;

2067 12 operator new 0 4 3469 24 LVecBase2i::operator new 0 1 147 0
124
inline void *LVecBase2i::operator new(std::size_t size);
inline void *LVecBase2i::operator new(std::size_t size, void *ptr);

2068 15 operator delete 0 4 3469 27 LVecBase2i::operator delete 0 0 0
108
inline void LVecBase2i::operator delete(void *ptr);
inline void LVecBase2i::operator delete(void *, void *);

2069 12 validate_ptr 0 4 3469 24 LVecBase2i::validate_ptr 0 0 0
61
static inline bool LVecBase2i::validate_ptr(void const *ptr);

2070 10 operator = 0 4 3469 22 LVecBase2i::operator = 0 2 148 149 0
131
LVecBase2i &LVecBase2i::operator =(LVecBase2i const &copy) = default;
LVecBase2i &LVecBase2i::operator =(int fill_value) = default;

2071 4 zero 0 4 3469 16 LVecBase2i::zero 0 1 150 40
/**
 * Returns a zero-length vector.
 */
55
static inline LVecBase2i const &LVecBase2i::zero(void);

2072 6 unit_x 0 4 3469 18 LVecBase2i::unit_x 0 1 151 35
/**
 * Returns a unit X vector.
 */
57
static inline LVecBase2i const &LVecBase2i::unit_x(void);

2073 6 unit_y 0 4 3469 18 LVecBase2i::unit_y 0 1 152 35
/**
 * Returns a unit Y vector.
 */
57
static inline LVecBase2i const &LVecBase2i::unit_y(void);

2074 10 __reduce__ 0 4 3469 22 LVecBase2i::__reduce__ 0 1 153 0
62
inline PyObject *LVecBase2i::__reduce__(PyObject *self) const;

2075 11 __getattr__ 0 4 3469 23 LVecBase2i::__getattr__ 0 1 154 0
93
inline PyObject *LVecBase2i::__getattr__(PyObject *self, std::string const &attr_name) const;

2076 11 __setattr__ 0 4 3469 23 LVecBase2i::__setattr__ 0 1 155 0
99
inline int LVecBase2i::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2077 11 operator [] 0 4 3469 23 LVecBase2i::operator [] 0 2 156 157 10
/**
 *
 */
92
inline int LVecBase2i::operator [](int i) const;
inline int &LVecBase2i::operator [](int i);

2078 4 size 0 4 3469 16 LVecBase2i::size 0 1 158 0
44
static constexpr int LVecBase2i::size(void);

2079 6 is_nan 0 4 3469 18 LVecBase2i::is_nan 0 1 159 91
/**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */
43
inline bool LVecBase2i::is_nan(void) const;

2080 8 get_cell 0 4 3469 20 LVecBase2i::get_cell 0 1 160 10
/**
 *
 */
45
inline int LVecBase2i::get_cell(int i) const;

2081 8 set_cell 0 4 3469 20 LVecBase2i::set_cell 0 1 161 10
/**
 *
 */
51
inline void LVecBase2i::set_cell(int i, int value);

2082 5 get_x 0 4 3469 17 LVecBase2i::get_x 0 1 162 10
/**
 *
 */
41
inline int LVecBase2i::get_x(void) const;

2083 5 get_y 0 4 3469 17 LVecBase2i::get_y 0 1 163 10
/**
 *
 */
41
inline int LVecBase2i::get_y(void) const;

2084 5 set_x 0 4 3469 17 LVecBase2i::set_x 0 1 164 10
/**
 *
 */
41
inline void LVecBase2i::set_x(int value);

2085 5 set_y 0 4 3469 17 LVecBase2i::set_y 0 1 165 10
/**
 *
 */
41
inline void LVecBase2i::set_y(int value);

2086 11 add_to_cell 0 4 3469 23 LVecBase2i::add_to_cell 0 1 166 164
// These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages:

/**
 *
 */
54
inline void LVecBase2i::add_to_cell(int i, int value);

2087 5 add_x 0 4 3469 17 LVecBase2i::add_x 0 1 167 10
/**
 *
 */
41
inline void LVecBase2i::add_x(int value);

2088 5 add_y 0 4 3469 17 LVecBase2i::add_y 0 1 168 10
/**
 *
 */
41
inline void LVecBase2i::add_y(int value);

2089 8 get_data 0 4 3469 20 LVecBase2i::get_data 0 1 169 155
/**
 * Returns the address of the first of the two data elements in the vector.
 * The next element occupies the next position consecutively in memory.
 */
51
inline int const *LVecBase2i::get_data(void) const;

2090 18 get_num_components 0 4 3469 30 LVecBase2i::get_num_components 0 1 170 0
58
static constexpr int LVecBase2i::get_num_components(void);

2091 4 fill 0 4 3469 16 LVecBase2i::fill 0 1 171 129
/**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */
45
inline void LVecBase2i::fill(int fill_value);

2092 3 set 0 4 3469 15 LVecBase2i::set 0 1 172 10
/**
 *
 */
42
inline void LVecBase2i::set(int x, int y);

2093 3 dot 0 4 3469 15 LVecBase2i::dot 0 1 173 10
/**
 *
 */
58
inline int LVecBase2i::dot(LVecBase2i const &other) const;

2094 14 length_squared 0 4 3469 26 LVecBase2i::length_squared 0 1 174 69
/**
 * Returns the square of the vector's length, cheap and easy.
 */
50
inline int LVecBase2i::length_squared(void) const;

2095 10 operator < 0 4 3469 22 LVecBase2i::operator < 0 1 175 0
66
inline bool LVecBase2i::operator <(LVecBase2i const &other) const;

2096 11 operator == 0 4 3469 23 LVecBase2i::operator == 0 1 176 0
67
inline bool LVecBase2i::operator ==(LVecBase2i const &other) const;

2097 11 operator != 0 4 3469 23 LVecBase2i::operator != 0 1 177 0
67
inline bool LVecBase2i::operator !=(LVecBase2i const &other) const;

2098 10 compare_to 0 4 3469 22 LVecBase2i::compare_to 0 1 178 97
/**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */
65
inline int LVecBase2i::compare_to(LVecBase2i const &other) const;

2099 8 get_hash 0 4 3469 20 LVecBase2i::get_hash 0 1 179 49
/**
 * Returns a suitable hash for phash_map.
 */
52
inline std::size_t LVecBase2i::get_hash(void) const;

2100 8 add_hash 0 4 3469 20 LVecBase2i::add_hash 0 1 180 49
/**
 * Adds the vector into the running hash.
 */
64
inline std::size_t LVecBase2i::add_hash(std::size_t hash) const;

2101 13 generate_hash 0 4 3469 25 LVecBase2i::generate_hash 0 1 181 59
/**
 * Adds the vector to the indicated hash generator.
 */
76
inline void LVecBase2i::generate_hash(ChecksumHashGenerator &hashgen) const;

2102 10 operator - 0 68 3469 22 LVecBase2i::operator - 0 1 182 0
53
inline LVecBase2i LVecBase2i::operator -(void) const;

2103 10 operator + 0 4 3469 22 LVecBase2i::operator + 0 1 183 0
72
inline LVecBase2i LVecBase2i::operator +(LVecBase2i const &other) const;

2104 10 operator - 0 4 3469 22 LVecBase2i::operator - 0 1 184 0
72
inline LVecBase2i LVecBase2i::operator -(LVecBase2i const &other) const;

2105 10 operator * 0 4 3469 22 LVecBase2i::operator * 0 1 185 0
59
inline LVecBase2i LVecBase2i::operator *(int scalar) const;

2106 10 operator / 0 4 3469 22 LVecBase2i::operator / 0 1 186 0
59
inline LVecBase2i LVecBase2i::operator /(int scalar) const;

2107 11 operator += 0 4 3469 23 LVecBase2i::operator += 0 1 187 0
61
inline void LVecBase2i::operator +=(LVecBase2i const &other);

2108 11 operator -= 0 4 3469 23 LVecBase2i::operator -= 0 1 188 0
61
inline void LVecBase2i::operator -=(LVecBase2i const &other);

2109 11 operator *= 0 4 3469 23 LVecBase2i::operator *= 0 1 189 0
48
inline void LVecBase2i::operator *=(int scalar);

2110 11 operator /= 0 4 3469 23 LVecBase2i::operator /= 0 1 190 0
48
inline void LVecBase2i::operator /=(int scalar);

2111 18 componentwise_mult 0 4 3469 30 LVecBase2i::componentwise_mult 0 1 191 10
/**
 *
 */
68
inline void LVecBase2i::componentwise_mult(LVecBase2i const &other);

2112 7 __pow__ 0 4 3469 19 LVecBase2i::__pow__ 0 1 192 0
58
inline LVecBase2i LVecBase2i::__pow__(int exponent) const;

2113 8 __ipow__ 0 4 3469 20 LVecBase2i::__ipow__ 0 1 193 0
68
inline PyObject *LVecBase2i::__ipow__(PyObject *self, int exponent);

2114 4 fmax 0 4 3469 16 LVecBase2i::fmax 0 1 194 10
/**
 *
 */
66
inline LVecBase2i LVecBase2i::fmax(LVecBase2i const &other) const;

2115 4 fmin 0 4 3469 16 LVecBase2i::fmin 0 1 195 10
/**
 *
 */
66
inline LVecBase2i LVecBase2i::fmin(LVecBase2i const &other) const;

2116 12 almost_equal 0 4 3469 24 LVecBase2i::almost_equal 0 2 196 197 210
/**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */

/**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */
152
inline bool LVecBase2i::almost_equal(LVecBase2i const &other, int threshold) const;
inline bool LVecBase2i::almost_equal(LVecBase2i const &other) const;

2117 6 output 0 4 3469 18 LVecBase2i::output 0 1 198 10
/**
 *
 */
51
inline void LVecBase2i::output(ostream &out) const;

2118 8 __repr__ 0 4 3469 20 LVecBase2i::__repr__ 0 1 199 0
52
inline std::string LVecBase2i::__repr__(void) const;

2119 20 write_datagram_fixed 0 4 3469 32 LVecBase2i::write_datagram_fixed 0 1 200 332
/**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */
74
inline void LVecBase2i::write_datagram_fixed(Datagram &destination) const;

2120 19 read_datagram_fixed 0 4 3469 31 LVecBase2i::read_datagram_fixed 0 1 201 114
/**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */
70
inline void LVecBase2i::read_datagram_fixed(DatagramIterator &source);

2121 14 write_datagram 0 4 3469 26 LVecBase2i::write_datagram 0 1 202 205
/**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */
68
inline void LVecBase2i::write_datagram(Datagram &destination) const;

2122 13 read_datagram 0 4 3469 25 LVecBase2i::read_datagram 0 1 203 67
/**
 * Reads the vector from the Datagram using get_stdfloat().
 */
64
inline void LVecBase2i::read_datagram(DatagramIterator &source);

2123 14 get_class_type 0 4 3469 26 LVecBase2i::get_class_type 0 1 204 0
51
static TypeHandle LVecBase2i::get_class_type(void);

2124 11 ~LVecBase2i 0 4 3469 23 LVecBase2i::~LVecBase2i 0 0 0
30
LVecBase2i::~LVecBase2i(void);

2125 9 LVector2f 0 4 3472 20 LVector2f::LVector2f 0 5 205 206 207 208 209 146
/**
 * Constructs a new LVector2 from a LVecBase2
 */

/**
 * Constructs a new LVector2 with all components set to the fill value.
 */

/**
 *
 */
249
inline LVector2f::LVector2f(void) = default;
inline LVector2f::LVector2f(LVecBase2f const &copy);
inline LVector2f::LVector2f(float fill_value);
inline LVector2f::LVector2f(float x, float y);
inline LVector2f::LVector2f(LVector2f const &) = default;

2126 11 __getattr__ 0 4 3472 22 LVector2f::__getattr__ 0 1 210 0
92
inline PyObject *LVector2f::__getattr__(PyObject *self, std::string const &attr_name) const;

2127 11 __setattr__ 0 4 3472 22 LVector2f::__setattr__ 0 1 211 0
98
inline int LVector2f::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2128 4 zero 0 4 3472 15 LVector2f::zero 0 1 212 40
/**
 * Returns a zero-length vector.
 */
53
static inline LVector2f const &LVector2f::zero(void);

2129 6 unit_x 0 4 3472 17 LVector2f::unit_x 0 1 213 35
/**
 * Returns a unit X vector.
 */
55
static inline LVector2f const &LVector2f::unit_x(void);

2130 6 unit_y 0 4 3472 17 LVector2f::unit_y 0 1 214 35
/**
 * Returns a unit Y vector.
 */
55
static inline LVector2f const &LVector2f::unit_y(void);

2131 10 operator - 0 68 3472 21 LVector2f::operator - 0 1 215 0
51
inline LVector2f LVector2f::operator -(void) const;

2132 10 operator + 0 4 3472 21 LVector2f::operator + 0 2 216 217 0
141
inline LVecBase2f LVector2f::operator +(LVecBase2f const &other) const;
inline LVector2f LVector2f::operator +(LVector2f const &other) const;

2133 10 operator - 0 4 3472 21 LVector2f::operator - 0 2 218 219 0
141
inline LVecBase2f LVector2f::operator -(LVecBase2f const &other) const;
inline LVector2f LVector2f::operator -(LVector2f const &other) const;

2134 10 operator * 0 4 3472 21 LVector2f::operator * 0 1 220 0
59
inline LVector2f LVector2f::operator *(float scalar) const;

2135 10 operator / 0 4 3472 21 LVector2f::operator / 0 1 221 0
59
inline LVector2f LVector2f::operator /(float scalar) const;

2136 10 normalized 0 4 3472 21 LVector2f::normalized 0 1 222 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
51
inline LVector2f LVector2f::normalized(void) const;

2137 7 project 0 4 3472 18 LVector2f::project 0 1 223 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
66
inline LVector2f LVector2f::project(LVecBase2f const &onto) const;

2138 16 signed_angle_rad 0 4 3472 27 LVector2f::signed_angle_rad 0 1 224 92
/**
 * returns the signed angled between two vectors.  normalization is NOT
 * necessary
 */
71
inline float LVector2f::signed_angle_rad(LVector2f const &other) const;

2139 16 signed_angle_deg 0 4 3472 27 LVector2f::signed_angle_deg 0 1 225 92
/**
 * returns the signed angled between two vectors.  normalization is NOT
 * necessary
 */
71
inline float LVector2f::signed_angle_deg(LVector2f const &other) const;

2140 8 __repr__ 0 4 3472 19 LVector2f::__repr__ 0 1 226 0
51
inline std::string LVector2f::__repr__(void) const;

2141 14 get_class_type 0 4 3472 25 LVector2f::get_class_type 0 1 227 0
50
static TypeHandle LVector2f::get_class_type(void);

2142 10 ~LVector2f 0 4 3472 21 LVector2f::~LVector2f 0 0 0
28
LVector2f::~LVector2f(void);

2143 9 LVector2d 0 4 3473 20 LVector2d::LVector2d 0 5 228 229 230 231 232 146
/**
 * Constructs a new LVector2 from a LVecBase2
 */

/**
 * Constructs a new LVector2 with all components set to the fill value.
 */

/**
 *
 */
252
inline LVector2d::LVector2d(void) = default;
inline LVector2d::LVector2d(LVecBase2d const &copy);
inline LVector2d::LVector2d(double fill_value);
inline LVector2d::LVector2d(double x, double y);
inline LVector2d::LVector2d(LVector2d const &) = default;

2144 11 __getattr__ 0 4 3473 22 LVector2d::__getattr__ 0 1 233 0
92
inline PyObject *LVector2d::__getattr__(PyObject *self, std::string const &attr_name) const;

2145 11 __setattr__ 0 4 3473 22 LVector2d::__setattr__ 0 1 234 0
98
inline int LVector2d::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2146 4 zero 0 4 3473 15 LVector2d::zero 0 1 235 40
/**
 * Returns a zero-length vector.
 */
53
static inline LVector2d const &LVector2d::zero(void);

2147 6 unit_x 0 4 3473 17 LVector2d::unit_x 0 1 236 35
/**
 * Returns a unit X vector.
 */
55
static inline LVector2d const &LVector2d::unit_x(void);

2148 6 unit_y 0 4 3473 17 LVector2d::unit_y 0 1 237 35
/**
 * Returns a unit Y vector.
 */
55
static inline LVector2d const &LVector2d::unit_y(void);

2149 10 operator - 0 68 3473 21 LVector2d::operator - 0 1 238 0
51
inline LVector2d LVector2d::operator -(void) const;

2150 10 operator + 0 4 3473 21 LVector2d::operator + 0 2 239 240 0
141
inline LVecBase2d LVector2d::operator +(LVecBase2d const &other) const;
inline LVector2d LVector2d::operator +(LVector2d const &other) const;

2151 10 operator - 0 4 3473 21 LVector2d::operator - 0 2 241 242 0
141
inline LVecBase2d LVector2d::operator -(LVecBase2d const &other) const;
inline LVector2d LVector2d::operator -(LVector2d const &other) const;

2152 10 operator * 0 4 3473 21 LVector2d::operator * 0 1 243 0
60
inline LVector2d LVector2d::operator *(double scalar) const;

2153 10 operator / 0 4 3473 21 LVector2d::operator / 0 1 244 0
60
inline LVector2d LVector2d::operator /(double scalar) const;

2154 10 normalized 0 4 3473 21 LVector2d::normalized 0 1 245 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
51
inline LVector2d LVector2d::normalized(void) const;

2155 7 project 0 4 3473 18 LVector2d::project 0 1 246 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
66
inline LVector2d LVector2d::project(LVecBase2d const &onto) const;

2156 16 signed_angle_rad 0 4 3473 27 LVector2d::signed_angle_rad 0 1 247 92
/**
 * returns the signed angled between two vectors.  normalization is NOT
 * necessary
 */
72
inline double LVector2d::signed_angle_rad(LVector2d const &other) const;

2157 16 signed_angle_deg 0 4 3473 27 LVector2d::signed_angle_deg 0 1 248 92
/**
 * returns the signed angled between two vectors.  normalization is NOT
 * necessary
 */
72
inline double LVector2d::signed_angle_deg(LVector2d const &other) const;

2158 8 __repr__ 0 4 3473 19 LVector2d::__repr__ 0 1 249 0
51
inline std::string LVector2d::__repr__(void) const;

2159 14 get_class_type 0 4 3473 25 LVector2d::get_class_type 0 1 250 0
50
static TypeHandle LVector2d::get_class_type(void);

2160 10 ~LVector2d 0 4 3473 21 LVector2d::~LVector2d 0 0 0
28
LVector2d::~LVector2d(void);

2161 9 LVector2i 0 4 3474 20 LVector2i::LVector2i 0 5 251 252 253 254 255 146
/**
 * Constructs a new LVector2 from a LVecBase2
 */

/**
 * Constructs a new LVector2 with all components set to the fill value.
 */

/**
 *
 */
243
inline LVector2i::LVector2i(void) = default;
inline LVector2i::LVector2i(LVecBase2i const &copy);
inline LVector2i::LVector2i(int fill_value);
inline LVector2i::LVector2i(int x, int y);
inline LVector2i::LVector2i(LVector2i const &) = default;

2162 11 __getattr__ 0 4 3474 22 LVector2i::__getattr__ 0 1 256 0
92
inline PyObject *LVector2i::__getattr__(PyObject *self, std::string const &attr_name) const;

2163 11 __setattr__ 0 4 3474 22 LVector2i::__setattr__ 0 1 257 0
98
inline int LVector2i::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2164 4 zero 0 4 3474 15 LVector2i::zero 0 1 258 40
/**
 * Returns a zero-length vector.
 */
53
static inline LVector2i const &LVector2i::zero(void);

2165 6 unit_x 0 4 3474 17 LVector2i::unit_x 0 1 259 35
/**
 * Returns a unit X vector.
 */
55
static inline LVector2i const &LVector2i::unit_x(void);

2166 6 unit_y 0 4 3474 17 LVector2i::unit_y 0 1 260 35
/**
 * Returns a unit Y vector.
 */
55
static inline LVector2i const &LVector2i::unit_y(void);

2167 10 operator - 0 68 3474 21 LVector2i::operator - 0 1 261 0
51
inline LVector2i LVector2i::operator -(void) const;

2168 10 operator + 0 4 3474 21 LVector2i::operator + 0 2 262 263 0
141
inline LVecBase2i LVector2i::operator +(LVecBase2i const &other) const;
inline LVector2i LVector2i::operator +(LVector2i const &other) const;

2169 10 operator - 0 4 3474 21 LVector2i::operator - 0 2 264 265 0
141
inline LVecBase2i LVector2i::operator -(LVecBase2i const &other) const;
inline LVector2i LVector2i::operator -(LVector2i const &other) const;

2170 10 operator * 0 4 3474 21 LVector2i::operator * 0 1 266 0
57
inline LVector2i LVector2i::operator *(int scalar) const;

2171 10 operator / 0 4 3474 21 LVector2i::operator / 0 1 267 0
57
inline LVector2i LVector2i::operator /(int scalar) const;

2172 8 __repr__ 0 4 3474 19 LVector2i::__repr__ 0 1 268 0
51
inline std::string LVector2i::__repr__(void) const;

2173 14 get_class_type 0 4 3474 25 LVector2i::get_class_type 0 1 269 0
50
static TypeHandle LVector2i::get_class_type(void);

2174 10 ~LVector2i 0 4 3474 21 LVector2i::~LVector2i 0 0 0
28
LVector2i::~LVector2i(void);

2175 8 LPoint2f 0 4 3475 18 LPoint2f::LPoint2f 0 5 270 271 272 273 274 190
/**
 * Constructs a new LPoint2 from a LVecBase2
 */

/**
 * Constructs a new LPoint2 all components set to the fill value.
 */

/**
 * Constructs a new LPoint2 with the given components
 */
238
inline LPoint2f::LPoint2f(void) = default;
inline LPoint2f::LPoint2f(LVecBase2f const &copy);
inline LPoint2f::LPoint2f(float fill_value);
inline LPoint2f::LPoint2f(float x, float y);
inline LPoint2f::LPoint2f(LPoint2f const &) = default;

2176 11 __getattr__ 0 4 3475 21 LPoint2f::__getattr__ 0 1 275 0
91
inline PyObject *LPoint2f::__getattr__(PyObject *self, std::string const &attr_name) const;

2177 11 __setattr__ 0 4 3475 21 LPoint2f::__setattr__ 0 1 276 0
97
inline int LPoint2f::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2178 4 zero 0 4 3475 14 LPoint2f::zero 0 1 277 39
/**
 * Returns a zero-length point.
 */
51
static inline LPoint2f const &LPoint2f::zero(void);

2179 6 unit_x 0 4 3475 16 LPoint2f::unit_x 0 1 278 34
/**
 * Returns a unit X point.
 */
53
static inline LPoint2f const &LPoint2f::unit_x(void);

2180 6 unit_y 0 4 3475 16 LPoint2f::unit_y 0 1 279 34
/**
 * Returns a unit Y point.
 */
53
static inline LPoint2f const &LPoint2f::unit_y(void);

2181 10 operator - 0 68 3475 20 LPoint2f::operator - 0 1 280 0
49
inline LPoint2f LPoint2f::operator -(void) const;

2182 10 operator + 0 4 3475 20 LPoint2f::operator + 0 2 281 282 0
138
inline LVecBase2f LPoint2f::operator +(LVecBase2f const &other) const;
inline LPoint2f LPoint2f::operator +(LVector2f const &other) const;

2183 10 operator - 0 4 3475 20 LPoint2f::operator - 0 3 283 284 285 0
206
inline LVecBase2f LPoint2f::operator -(LVecBase2f const &other) const;
inline LVector2f LPoint2f::operator -(LPoint2f const &other) const;
inline LPoint2f LPoint2f::operator -(LVector2f const &other) const;

2184 10 operator * 0 4 3475 20 LPoint2f::operator * 0 1 286 0
57
inline LPoint2f LPoint2f::operator *(float scalar) const;

2185 10 operator / 0 4 3475 20 LPoint2f::operator / 0 1 287 0
57
inline LPoint2f LPoint2f::operator /(float scalar) const;

2186 10 normalized 0 4 3475 20 LPoint2f::normalized 0 1 288 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
49
inline LPoint2f LPoint2f::normalized(void) const;

2187 7 project 0 4 3475 17 LPoint2f::project 0 1 289 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
64
inline LPoint2f LPoint2f::project(LVecBase2f const &onto) const;

2188 8 __repr__ 0 4 3475 18 LPoint2f::__repr__ 0 1 290 0
50
inline std::string LPoint2f::__repr__(void) const;

2189 14 get_class_type 0 4 3475 24 LPoint2f::get_class_type 0 1 291 0
49
static TypeHandle LPoint2f::get_class_type(void);

2190 9 ~LPoint2f 0 4 3475 19 LPoint2f::~LPoint2f 0 0 0
26
LPoint2f::~LPoint2f(void);

2191 8 LPoint2d 0 4 3476 18 LPoint2d::LPoint2d 0 5 292 293 294 295 296 190
/**
 * Constructs a new LPoint2 from a LVecBase2
 */

/**
 * Constructs a new LPoint2 all components set to the fill value.
 */

/**
 * Constructs a new LPoint2 with the given components
 */
241
inline LPoint2d::LPoint2d(void) = default;
inline LPoint2d::LPoint2d(LVecBase2d const &copy);
inline LPoint2d::LPoint2d(double fill_value);
inline LPoint2d::LPoint2d(double x, double y);
inline LPoint2d::LPoint2d(LPoint2d const &) = default;

2192 11 __getattr__ 0 4 3476 21 LPoint2d::__getattr__ 0 1 297 0
91
inline PyObject *LPoint2d::__getattr__(PyObject *self, std::string const &attr_name) const;

2193 11 __setattr__ 0 4 3476 21 LPoint2d::__setattr__ 0 1 298 0
97
inline int LPoint2d::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2194 4 zero 0 4 3476 14 LPoint2d::zero 0 1 299 39
/**
 * Returns a zero-length point.
 */
51
static inline LPoint2d const &LPoint2d::zero(void);

2195 6 unit_x 0 4 3476 16 LPoint2d::unit_x 0 1 300 34
/**
 * Returns a unit X point.
 */
53
static inline LPoint2d const &LPoint2d::unit_x(void);

2196 6 unit_y 0 4 3476 16 LPoint2d::unit_y 0 1 301 34
/**
 * Returns a unit Y point.
 */
53
static inline LPoint2d const &LPoint2d::unit_y(void);

2197 10 operator - 0 68 3476 20 LPoint2d::operator - 0 1 302 0
49
inline LPoint2d LPoint2d::operator -(void) const;

2198 10 operator + 0 4 3476 20 LPoint2d::operator + 0 2 303 304 0
138
inline LVecBase2d LPoint2d::operator +(LVecBase2d const &other) const;
inline LPoint2d LPoint2d::operator +(LVector2d const &other) const;

2199 10 operator - 0 4 3476 20 LPoint2d::operator - 0 3 305 306 307 0
206
inline LVecBase2d LPoint2d::operator -(LVecBase2d const &other) const;
inline LVector2d LPoint2d::operator -(LPoint2d const &other) const;
inline LPoint2d LPoint2d::operator -(LVector2d const &other) const;

2200 10 operator * 0 4 3476 20 LPoint2d::operator * 0 1 308 0
58
inline LPoint2d LPoint2d::operator *(double scalar) const;

2201 10 operator / 0 4 3476 20 LPoint2d::operator / 0 1 309 0
58
inline LPoint2d LPoint2d::operator /(double scalar) const;

2202 10 normalized 0 4 3476 20 LPoint2d::normalized 0 1 310 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
49
inline LPoint2d LPoint2d::normalized(void) const;

2203 7 project 0 4 3476 17 LPoint2d::project 0 1 311 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
64
inline LPoint2d LPoint2d::project(LVecBase2d const &onto) const;

2204 8 __repr__ 0 4 3476 18 LPoint2d::__repr__ 0 1 312 0
50
inline std::string LPoint2d::__repr__(void) const;

2205 14 get_class_type 0 4 3476 24 LPoint2d::get_class_type 0 1 313 0
49
static TypeHandle LPoint2d::get_class_type(void);

2206 9 ~LPoint2d 0 4 3476 19 LPoint2d::~LPoint2d 0 0 0
26
LPoint2d::~LPoint2d(void);

2207 8 LPoint2i 0 4 3477 18 LPoint2i::LPoint2i 0 5 314 315 316 317 318 190
/**
 * Constructs a new LPoint2 from a LVecBase2
 */

/**
 * Constructs a new LPoint2 all components set to the fill value.
 */

/**
 * Constructs a new LPoint2 with the given components
 */
232
inline LPoint2i::LPoint2i(void) = default;
inline LPoint2i::LPoint2i(LVecBase2i const &copy);
inline LPoint2i::LPoint2i(int fill_value);
inline LPoint2i::LPoint2i(int x, int y);
inline LPoint2i::LPoint2i(LPoint2i const &) = default;

2208 11 __getattr__ 0 4 3477 21 LPoint2i::__getattr__ 0 1 319 0
91
inline PyObject *LPoint2i::__getattr__(PyObject *self, std::string const &attr_name) const;

2209 11 __setattr__ 0 4 3477 21 LPoint2i::__setattr__ 0 1 320 0
97
inline int LPoint2i::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2210 4 zero 0 4 3477 14 LPoint2i::zero 0 1 321 39
/**
 * Returns a zero-length point.
 */
51
static inline LPoint2i const &LPoint2i::zero(void);

2211 6 unit_x 0 4 3477 16 LPoint2i::unit_x 0 1 322 34
/**
 * Returns a unit X point.
 */
53
static inline LPoint2i const &LPoint2i::unit_x(void);

2212 6 unit_y 0 4 3477 16 LPoint2i::unit_y 0 1 323 34
/**
 * Returns a unit Y point.
 */
53
static inline LPoint2i const &LPoint2i::unit_y(void);

2213 10 operator - 0 68 3477 20 LPoint2i::operator - 0 1 324 0
49
inline LPoint2i LPoint2i::operator -(void) const;

2214 10 operator + 0 4 3477 20 LPoint2i::operator + 0 2 325 326 0
138
inline LVecBase2i LPoint2i::operator +(LVecBase2i const &other) const;
inline LPoint2i LPoint2i::operator +(LVector2i const &other) const;

2215 10 operator - 0 4 3477 20 LPoint2i::operator - 0 3 327 328 329 0
206
inline LVecBase2i LPoint2i::operator -(LVecBase2i const &other) const;
inline LVector2i LPoint2i::operator -(LPoint2i const &other) const;
inline LPoint2i LPoint2i::operator -(LVector2i const &other) const;

2216 10 operator * 0 4 3477 20 LPoint2i::operator * 0 1 330 0
55
inline LPoint2i LPoint2i::operator *(int scalar) const;

2217 10 operator / 0 4 3477 20 LPoint2i::operator / 0 1 331 0
55
inline LPoint2i LPoint2i::operator /(int scalar) const;

2218 8 __repr__ 0 4 3477 18 LPoint2i::__repr__ 0 1 332 0
50
inline std::string LPoint2i::__repr__(void) const;

2219 14 get_class_type 0 4 3477 24 LPoint2i::get_class_type 0 1 333 0
49
static TypeHandle LPoint2i::get_class_type(void);

2220 9 ~LPoint2i 0 4 3477 19 LPoint2i::~LPoint2i 0 0 0
26
LPoint2i::~LPoint2i(void);

2221 10 LVecBase3f 0 4 3478 22 LVecBase3f::LVecBase3f 0 5 334 335 336 337 338 34
/**
 *
 */

/**
 *
 */

/**
 *
 */
278
inline LVecBase3f::LVecBase3f(void) = default;
inline LVecBase3f::LVecBase3f(float fill_value);
inline LVecBase3f::LVecBase3f(float x, float y, float z);
inline LVecBase3f::LVecBase3f(LVecBase2f const &copy, float z);
inline LVecBase3f::LVecBase3f(LVecBase3f const &) = default;

2222 12 operator new 0 4 3478 24 LVecBase3f::operator new 0 1 339 0
124
inline void *LVecBase3f::operator new(std::size_t size);
inline void *LVecBase3f::operator new(std::size_t size, void *ptr);

2223 15 operator delete 0 4 3478 27 LVecBase3f::operator delete 0 0 0
108
inline void LVecBase3f::operator delete(void *ptr);
inline void LVecBase3f::operator delete(void *, void *);

2224 12 validate_ptr 0 4 3478 24 LVecBase3f::validate_ptr 0 0 0
61
static inline bool LVecBase3f::validate_ptr(void const *ptr);

2225 10 operator = 0 4 3478 22 LVecBase3f::operator = 0 2 340 341 0
133
LVecBase3f &LVecBase3f::operator =(LVecBase3f const &copy) = default;
LVecBase3f &LVecBase3f::operator =(float fill_value) = default;

2226 4 zero 0 4 3478 16 LVecBase3f::zero 0 1 342 40
/**
 * Returns a zero-length vector.
 */
55
static inline LVecBase3f const &LVecBase3f::zero(void);

2227 6 unit_x 0 4 3478 18 LVecBase3f::unit_x 0 1 343 35
/**
 * Returns a unit X vector.
 */
57
static inline LVecBase3f const &LVecBase3f::unit_x(void);

2228 6 unit_y 0 4 3478 18 LVecBase3f::unit_y 0 1 344 35
/**
 * Returns a unit Y vector.
 */
57
static inline LVecBase3f const &LVecBase3f::unit_y(void);

2229 6 unit_z 0 4 3478 18 LVecBase3f::unit_z 0 1 345 35
/**
 * Returns a unit Z vector.
 */
57
static inline LVecBase3f const &LVecBase3f::unit_z(void);

2230 10 __reduce__ 0 4 3478 22 LVecBase3f::__reduce__ 0 1 346 0
62
inline PyObject *LVecBase3f::__reduce__(PyObject *self) const;

2231 11 __getattr__ 0 4 3478 23 LVecBase3f::__getattr__ 0 1 347 0
93
inline PyObject *LVecBase3f::__getattr__(PyObject *self, std::string const &attr_name) const;

2232 11 __setattr__ 0 4 3478 23 LVecBase3f::__setattr__ 0 1 348 0
99
inline int LVecBase3f::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2233 11 operator [] 0 4 3478 23 LVecBase3f::operator [] 0 2 349 350 10
/**
 *
 */
96
inline float LVecBase3f::operator [](int i) const;
inline float &LVecBase3f::operator [](int i);

2234 4 size 0 4 3478 16 LVecBase3f::size 0 1 351 0
44
static constexpr int LVecBase3f::size(void);

2235 6 is_nan 0 4 3478 18 LVecBase3f::is_nan 0 1 352 91
/**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */
43
inline bool LVecBase3f::is_nan(void) const;

2236 8 get_cell 0 4 3478 20 LVecBase3f::get_cell 0 1 353 10
/**
 *
 */
47
inline float LVecBase3f::get_cell(int i) const;

2237 5 get_x 0 4 3478 17 LVecBase3f::get_x 0 1 354 10
/**
 *
 */
43
inline float LVecBase3f::get_x(void) const;

2238 5 get_y 0 4 3478 17 LVecBase3f::get_y 0 1 355 10
/**
 *
 */
43
inline float LVecBase3f::get_y(void) const;

2239 5 get_z 0 4 3478 17 LVecBase3f::get_z 0 1 356 10
/**
 *
 */
43
inline float LVecBase3f::get_z(void) const;

2240 8 set_cell 0 4 3478 20 LVecBase3f::set_cell 0 1 357 10
/**
 *
 */
53
inline void LVecBase3f::set_cell(int i, float value);

2241 5 set_x 0 4 3478 17 LVecBase3f::set_x 0 1 358 10
/**
 *
 */
43
inline void LVecBase3f::set_x(float value);

2242 5 set_y 0 4 3478 17 LVecBase3f::set_y 0 1 359 10
/**
 *
 */
43
inline void LVecBase3f::set_y(float value);

2243 5 set_z 0 4 3478 17 LVecBase3f::set_z 0 1 360 10
/**
 *
 */
43
inline void LVecBase3f::set_z(float value);

2244 6 get_xy 0 4 3478 18 LVecBase3f::get_xy 0 1 361 100
/**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */
49
inline LVecBase2f LVecBase3f::get_xy(void) const;

2245 6 get_xz 0 4 3478 18 LVecBase3f::get_xz 0 1 362 105
/**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */
49
inline LVecBase2f LVecBase3f::get_xz(void) const;

2246 6 get_yz 0 4 3478 18 LVecBase3f::get_yz 0 1 363 99
/**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */
49
inline LVecBase2f LVecBase3f::get_yz(void) const;

2247 11 add_to_cell 0 4 3478 23 LVecBase3f::add_to_cell 0 1 364 164
// These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages:

/**
 *
 */
56
inline void LVecBase3f::add_to_cell(int i, float value);

2248 5 add_x 0 4 3478 17 LVecBase3f::add_x 0 1 365 10
/**
 *
 */
43
inline void LVecBase3f::add_x(float value);

2249 5 add_y 0 4 3478 17 LVecBase3f::add_y 0 1 366 10
/**
 *
 */
43
inline void LVecBase3f::add_y(float value);

2250 5 add_z 0 4 3478 17 LVecBase3f::add_z 0 1 367 10
/**
 *
 */
43
inline void LVecBase3f::add_z(float value);

2251 8 get_data 0 4 3478 20 LVecBase3f::get_data 0 1 368 162
/**
 * Returns the address of the first of the three data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */
53
inline float const *LVecBase3f::get_data(void) const;

2252 18 get_num_components 0 4 3478 30 LVecBase3f::get_num_components 0 1 369 0
58
static constexpr int LVecBase3f::get_num_components(void);

2253 4 fill 0 4 3478 16 LVecBase3f::fill 0 1 370 129
/**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */
47
inline void LVecBase3f::fill(float fill_value);

2254 3 set 0 4 3478 15 LVecBase3f::set 0 1 371 10
/**
 *
 */
55
inline void LVecBase3f::set(float x, float y, float z);

2255 3 dot 0 4 3478 15 LVecBase3f::dot 0 1 372 10
/**
 *
 */
60
inline float LVecBase3f::dot(LVecBase3f const &other) const;

2256 14 length_squared 0 4 3478 26 LVecBase3f::length_squared 0 1 373 69
/**
 * Returns the square of the vector's length, cheap and easy.
 */
52
inline float LVecBase3f::length_squared(void) const;

2257 6 length 0 4 3478 18 LVecBase3f::length 0 1 374 72
/**
 * Returns the length of the vector, by the Pythagorean theorem.
 */
44
inline float LVecBase3f::length(void) const;

2258 9 normalize 0 4 3478 21 LVecBase3f::normalize 0 1 375 127
/**
 * Normalizes the vector in place.  Returns true if the vector was normalized,
 * false if it was a zero-length vector.
 */
40
inline bool LVecBase3f::normalize(void);

2259 10 normalized 0 4 3478 22 LVecBase3f::normalized 0 1 376 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
53
inline LVecBase3f LVecBase3f::normalized(void) const;

2260 7 project 0 4 3478 19 LVecBase3f::project 0 1 377 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
68
inline LVecBase3f LVecBase3f::project(LVecBase3f const &onto) const;

2261 5 cross 0 4 3478 17 LVecBase3f::cross 0 1 378 10
/**
 *
 */
67
inline LVecBase3f LVecBase3f::cross(LVecBase3f const &other) const;

2262 10 operator < 0 4 3478 22 LVecBase3f::operator < 0 1 379 0
66
inline bool LVecBase3f::operator <(LVecBase3f const &other) const;

2263 11 operator == 0 4 3478 23 LVecBase3f::operator == 0 1 380 0
67
inline bool LVecBase3f::operator ==(LVecBase3f const &other) const;

2264 11 operator != 0 4 3478 23 LVecBase3f::operator != 0 1 381 0
67
inline bool LVecBase3f::operator !=(LVecBase3f const &other) const;

2265 20 get_standardized_hpr 0 4 3478 32 LVecBase3f::get_standardized_hpr 0 1 382 623
/**
 * Try to un-spin the hpr to a standard form.  Like all standards, someone
 * decides between many arbitrary possible standards.  This function assumes
 * that 0 and 360 are the same, as is 720 and -360.  Also 180 and -180 are the
 * same.  Another example is -90 and 270. Each element will be in the range
 * -180.0 to 179.99999. The original usage of this function is for human
 * readable output.
 *
 * It doesn't work so well for asserting that foo_hpr is roughly equal to
 * bar_hpr.  Try using LQuaternionf::is_same_direction() for that.  See Also:
 * get_standardized_rotation, LQuaternion::is_same_direction
 */
63
inline LVecBase3f LVecBase3f::get_standardized_hpr(void) const;

2266 10 compare_to 0 4 3478 22 LVecBase3f::compare_to 0 2 383 384 332
/**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */

/**
 * Sorts vectors lexicographically, componentwise.  Returns a number less than
 * 0 if this vector sorts before the other one, greater than zero if it sorts
 * after, 0 if they are equivalent (within the indicated tolerance).
 */
148
inline int LVecBase3f::compare_to(LVecBase3f const &other) const;
inline int LVecBase3f::compare_to(LVecBase3f const &other, float threshold) const;

2267 8 get_hash 0 4 3478 20 LVecBase3f::get_hash 0 2 385 386 100
/**
 * Returns a suitable hash for phash_map.
 */

/**
 * Returns a suitable hash for phash_map.
 */
116
inline std::size_t LVecBase3f::get_hash(void) const;
inline std::size_t LVecBase3f::get_hash(float threshold) const;

2268 8 add_hash 0 4 3478 20 LVecBase3f::add_hash 0 2 387 388 100
/**
 * Adds the vector into the running hash.
 */

/**
 * Adds the vector into the running hash.
 */
146
inline std::size_t LVecBase3f::add_hash(std::size_t hash) const;
inline std::size_t LVecBase3f::add_hash(std::size_t hash, float threshold) const;

2269 13 generate_hash 0 4 3478 25 LVecBase3f::generate_hash 0 2 389 390 120
/**
 * Adds the vector to the indicated hash generator.
 */

/**
 * Adds the vector to the indicated hash generator.
 */
170
inline void LVecBase3f::generate_hash(ChecksumHashGenerator &hashgen) const;
inline void LVecBase3f::generate_hash(ChecksumHashGenerator &hashgen, float threshold) const;

2270 10 operator - 0 68 3478 22 LVecBase3f::operator - 0 1 391 0
53
inline LVecBase3f LVecBase3f::operator -(void) const;

2271 10 operator + 0 4 3478 22 LVecBase3f::operator + 0 1 392 0
72
inline LVecBase3f LVecBase3f::operator +(LVecBase3f const &other) const;

2272 10 operator - 0 4 3478 22 LVecBase3f::operator - 0 1 393 0
72
inline LVecBase3f LVecBase3f::operator -(LVecBase3f const &other) const;

2273 10 operator * 0 4 3478 22 LVecBase3f::operator * 0 1 394 0
61
inline LVecBase3f LVecBase3f::operator *(float scalar) const;

2274 10 operator / 0 4 3478 22 LVecBase3f::operator / 0 1 395 0
61
inline LVecBase3f LVecBase3f::operator /(float scalar) const;

2275 11 operator += 0 4 3478 23 LVecBase3f::operator += 0 1 396 0
61
inline void LVecBase3f::operator +=(LVecBase3f const &other);

2276 11 operator -= 0 4 3478 23 LVecBase3f::operator -= 0 1 397 0
61
inline void LVecBase3f::operator -=(LVecBase3f const &other);

2277 11 operator *= 0 4 3478 23 LVecBase3f::operator *= 0 1 398 0
50
inline void LVecBase3f::operator *=(float scalar);

2278 11 operator /= 0 4 3478 23 LVecBase3f::operator /= 0 1 399 0
50
inline void LVecBase3f::operator /=(float scalar);

2279 18 componentwise_mult 0 4 3478 30 LVecBase3f::componentwise_mult 0 1 400 10
/**
 *
 */
68
inline void LVecBase3f::componentwise_mult(LVecBase3f const &other);

2280 7 __pow__ 0 4 3478 19 LVecBase3f::__pow__ 0 1 401 0
60
inline LVecBase3f LVecBase3f::__pow__(float exponent) const;

2281 8 __ipow__ 0 4 3478 20 LVecBase3f::__ipow__ 0 1 402 0
70
inline PyObject *LVecBase3f::__ipow__(PyObject *self, float exponent);

2282 4 fmax 0 4 3478 16 LVecBase3f::fmax 0 1 403 10
/**
 *
 */
66
inline LVecBase3f LVecBase3f::fmax(LVecBase3f const &other) const;

2283 4 fmin 0 4 3478 16 LVecBase3f::fmin 0 1 404 10
/**
 *
 */
66
inline LVecBase3f LVecBase3f::fmin(LVecBase3f const &other) const;

2284 10 cross_into 0 4 3478 22 LVecBase3f::cross_into 0 1 405 10
/**
 *
 */
60
inline void LVecBase3f::cross_into(LVecBase3f const &other);

2285 12 almost_equal 0 4 3478 24 LVecBase3f::almost_equal 0 2 406 407 210
/**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */

/**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */
154
inline bool LVecBase3f::almost_equal(LVecBase3f const &other, float threshold) const;
inline bool LVecBase3f::almost_equal(LVecBase3f const &other) const;

2286 6 output 0 4 3478 18 LVecBase3f::output 0 1 408 10
/**
 *
 */
51
inline void LVecBase3f::output(ostream &out) const;

2287 8 __repr__ 0 4 3478 20 LVecBase3f::__repr__ 0 1 409 0
52
inline std::string LVecBase3f::__repr__(void) const;

2288 20 write_datagram_fixed 0 4 3478 32 LVecBase3f::write_datagram_fixed 0 1 410 332
/**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */
74
inline void LVecBase3f::write_datagram_fixed(Datagram &destination) const;

2289 19 read_datagram_fixed 0 4 3478 31 LVecBase3f::read_datagram_fixed 0 1 411 114
/**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */
70
inline void LVecBase3f::read_datagram_fixed(DatagramIterator &source);

2290 14 write_datagram 0 4 3478 26 LVecBase3f::write_datagram 0 1 412 205
/**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */
68
inline void LVecBase3f::write_datagram(Datagram &destination) const;

2291 13 read_datagram 0 4 3478 25 LVecBase3f::read_datagram 0 1 413 67
/**
 * Reads the vector from the Datagram using get_stdfloat().
 */
64
inline void LVecBase3f::read_datagram(DatagramIterator &source);

2292 14 get_class_type 0 4 3478 26 LVecBase3f::get_class_type 0 1 414 0
51
static TypeHandle LVecBase3f::get_class_type(void);

2293 11 ~LVecBase3f 0 4 3478 23 LVecBase3f::~LVecBase3f 0 0 0
30
LVecBase3f::~LVecBase3f(void);

2294 10 LVecBase3d 0 4 3480 22 LVecBase3d::LVecBase3d 0 5 415 416 417 418 419 34
/**
 *
 */

/**
 *
 */

/**
 *
 */
283
inline LVecBase3d::LVecBase3d(void) = default;
inline LVecBase3d::LVecBase3d(double fill_value);
inline LVecBase3d::LVecBase3d(double x, double y, double z);
inline LVecBase3d::LVecBase3d(LVecBase2d const &copy, double z);
inline LVecBase3d::LVecBase3d(LVecBase3d const &) = default;

2295 12 operator new 0 4 3480 24 LVecBase3d::operator new 0 1 420 0
124
inline void *LVecBase3d::operator new(std::size_t size);
inline void *LVecBase3d::operator new(std::size_t size, void *ptr);

2296 15 operator delete 0 4 3480 27 LVecBase3d::operator delete 0 0 0
108
inline void LVecBase3d::operator delete(void *ptr);
inline void LVecBase3d::operator delete(void *, void *);

2297 12 validate_ptr 0 4 3480 24 LVecBase3d::validate_ptr 0 0 0
61
static inline bool LVecBase3d::validate_ptr(void const *ptr);

2298 10 operator = 0 4 3480 22 LVecBase3d::operator = 0 2 421 422 0
134
LVecBase3d &LVecBase3d::operator =(LVecBase3d const &copy) = default;
LVecBase3d &LVecBase3d::operator =(double fill_value) = default;

2299 4 zero 0 4 3480 16 LVecBase3d::zero 0 1 423 40
/**
 * Returns a zero-length vector.
 */
55
static inline LVecBase3d const &LVecBase3d::zero(void);

2300 6 unit_x 0 4 3480 18 LVecBase3d::unit_x 0 1 424 35
/**
 * Returns a unit X vector.
 */
57
static inline LVecBase3d const &LVecBase3d::unit_x(void);

2301 6 unit_y 0 4 3480 18 LVecBase3d::unit_y 0 1 425 35
/**
 * Returns a unit Y vector.
 */
57
static inline LVecBase3d const &LVecBase3d::unit_y(void);

2302 6 unit_z 0 4 3480 18 LVecBase3d::unit_z 0 1 426 35
/**
 * Returns a unit Z vector.
 */
57
static inline LVecBase3d const &LVecBase3d::unit_z(void);

2303 10 __reduce__ 0 4 3480 22 LVecBase3d::__reduce__ 0 1 427 0
62
inline PyObject *LVecBase3d::__reduce__(PyObject *self) const;

2304 11 __getattr__ 0 4 3480 23 LVecBase3d::__getattr__ 0 1 428 0
93
inline PyObject *LVecBase3d::__getattr__(PyObject *self, std::string const &attr_name) const;

2305 11 __setattr__ 0 4 3480 23 LVecBase3d::__setattr__ 0 1 429 0
99
inline int LVecBase3d::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2306 11 operator [] 0 4 3480 23 LVecBase3d::operator [] 0 2 430 431 10
/**
 *
 */
98
inline double LVecBase3d::operator [](int i) const;
inline double &LVecBase3d::operator [](int i);

2307 4 size 0 4 3480 16 LVecBase3d::size 0 1 432 0
44
static constexpr int LVecBase3d::size(void);

2308 6 is_nan 0 4 3480 18 LVecBase3d::is_nan 0 1 433 91
/**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */
43
inline bool LVecBase3d::is_nan(void) const;

2309 8 get_cell 0 4 3480 20 LVecBase3d::get_cell 0 1 434 10
/**
 *
 */
48
inline double LVecBase3d::get_cell(int i) const;

2310 5 get_x 0 4 3480 17 LVecBase3d::get_x 0 1 435 10
/**
 *
 */
44
inline double LVecBase3d::get_x(void) const;

2311 5 get_y 0 4 3480 17 LVecBase3d::get_y 0 1 436 10
/**
 *
 */
44
inline double LVecBase3d::get_y(void) const;

2312 5 get_z 0 4 3480 17 LVecBase3d::get_z 0 1 437 10
/**
 *
 */
44
inline double LVecBase3d::get_z(void) const;

2313 8 set_cell 0 4 3480 20 LVecBase3d::set_cell 0 1 438 10
/**
 *
 */
54
inline void LVecBase3d::set_cell(int i, double value);

2314 5 set_x 0 4 3480 17 LVecBase3d::set_x 0 1 439 10
/**
 *
 */
44
inline void LVecBase3d::set_x(double value);

2315 5 set_y 0 4 3480 17 LVecBase3d::set_y 0 1 440 10
/**
 *
 */
44
inline void LVecBase3d::set_y(double value);

2316 5 set_z 0 4 3480 17 LVecBase3d::set_z 0 1 441 10
/**
 *
 */
44
inline void LVecBase3d::set_z(double value);

2317 6 get_xy 0 4 3480 18 LVecBase3d::get_xy 0 1 442 100
/**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */
49
inline LVecBase2d LVecBase3d::get_xy(void) const;

2318 6 get_xz 0 4 3480 18 LVecBase3d::get_xz 0 1 443 105
/**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */
49
inline LVecBase2d LVecBase3d::get_xz(void) const;

2319 6 get_yz 0 4 3480 18 LVecBase3d::get_yz 0 1 444 99
/**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */
49
inline LVecBase2d LVecBase3d::get_yz(void) const;

2320 11 add_to_cell 0 4 3480 23 LVecBase3d::add_to_cell 0 1 445 164
// These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages:

/**
 *
 */
57
inline void LVecBase3d::add_to_cell(int i, double value);

2321 5 add_x 0 4 3480 17 LVecBase3d::add_x 0 1 446 10
/**
 *
 */
44
inline void LVecBase3d::add_x(double value);

2322 5 add_y 0 4 3480 17 LVecBase3d::add_y 0 1 447 10
/**
 *
 */
44
inline void LVecBase3d::add_y(double value);

2323 5 add_z 0 4 3480 17 LVecBase3d::add_z 0 1 448 10
/**
 *
 */
44
inline void LVecBase3d::add_z(double value);

2324 8 get_data 0 4 3480 20 LVecBase3d::get_data 0 1 449 162
/**
 * Returns the address of the first of the three data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */
54
inline double const *LVecBase3d::get_data(void) const;

2325 18 get_num_components 0 4 3480 30 LVecBase3d::get_num_components 0 1 450 0
58
static constexpr int LVecBase3d::get_num_components(void);

2326 4 fill 0 4 3480 16 LVecBase3d::fill 0 1 451 129
/**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */
48
inline void LVecBase3d::fill(double fill_value);

2327 3 set 0 4 3480 15 LVecBase3d::set 0 1 452 10
/**
 *
 */
58
inline void LVecBase3d::set(double x, double y, double z);

2328 3 dot 0 4 3480 15 LVecBase3d::dot 0 1 453 10
/**
 *
 */
61
inline double LVecBase3d::dot(LVecBase3d const &other) const;

2329 14 length_squared 0 4 3480 26 LVecBase3d::length_squared 0 1 454 69
/**
 * Returns the square of the vector's length, cheap and easy.
 */
53
inline double LVecBase3d::length_squared(void) const;

2330 6 length 0 4 3480 18 LVecBase3d::length 0 1 455 72
/**
 * Returns the length of the vector, by the Pythagorean theorem.
 */
45
inline double LVecBase3d::length(void) const;

2331 9 normalize 0 4 3480 21 LVecBase3d::normalize 0 1 456 127
/**
 * Normalizes the vector in place.  Returns true if the vector was normalized,
 * false if it was a zero-length vector.
 */
40
inline bool LVecBase3d::normalize(void);

2332 10 normalized 0 4 3480 22 LVecBase3d::normalized 0 1 457 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
53
inline LVecBase3d LVecBase3d::normalized(void) const;

2333 7 project 0 4 3480 19 LVecBase3d::project 0 1 458 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
68
inline LVecBase3d LVecBase3d::project(LVecBase3d const &onto) const;

2334 5 cross 0 4 3480 17 LVecBase3d::cross 0 1 459 10
/**
 *
 */
67
inline LVecBase3d LVecBase3d::cross(LVecBase3d const &other) const;

2335 10 operator < 0 4 3480 22 LVecBase3d::operator < 0 1 460 0
66
inline bool LVecBase3d::operator <(LVecBase3d const &other) const;

2336 11 operator == 0 4 3480 23 LVecBase3d::operator == 0 1 461 0
67
inline bool LVecBase3d::operator ==(LVecBase3d const &other) const;

2337 11 operator != 0 4 3480 23 LVecBase3d::operator != 0 1 462 0
67
inline bool LVecBase3d::operator !=(LVecBase3d const &other) const;

2338 20 get_standardized_hpr 0 4 3480 32 LVecBase3d::get_standardized_hpr 0 1 463 623
/**
 * Try to un-spin the hpr to a standard form.  Like all standards, someone
 * decides between many arbitrary possible standards.  This function assumes
 * that 0 and 360 are the same, as is 720 and -360.  Also 180 and -180 are the
 * same.  Another example is -90 and 270. Each element will be in the range
 * -180.0 to 179.99999. The original usage of this function is for human
 * readable output.
 *
 * It doesn't work so well for asserting that foo_hpr is roughly equal to
 * bar_hpr.  Try using LQuaternionf::is_same_direction() for that.  See Also:
 * get_standardized_rotation, LQuaternion::is_same_direction
 */
63
inline LVecBase3d LVecBase3d::get_standardized_hpr(void) const;

2339 10 compare_to 0 4 3480 22 LVecBase3d::compare_to 0 2 464 465 332
/**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */

/**
 * Sorts vectors lexicographically, componentwise.  Returns a number less than
 * 0 if this vector sorts before the other one, greater than zero if it sorts
 * after, 0 if they are equivalent (within the indicated tolerance).
 */
149
inline int LVecBase3d::compare_to(LVecBase3d const &other) const;
inline int LVecBase3d::compare_to(LVecBase3d const &other, double threshold) const;

2340 8 get_hash 0 4 3480 20 LVecBase3d::get_hash 0 2 466 467 100
/**
 * Returns a suitable hash for phash_map.
 */

/**
 * Returns a suitable hash for phash_map.
 */
117
inline std::size_t LVecBase3d::get_hash(void) const;
inline std::size_t LVecBase3d::get_hash(double threshold) const;

2341 8 add_hash 0 4 3480 20 LVecBase3d::add_hash 0 2 468 469 100
/**
 * Adds the vector into the running hash.
 */

/**
 * Adds the vector into the running hash.
 */
147
inline std::size_t LVecBase3d::add_hash(std::size_t hash) const;
inline std::size_t LVecBase3d::add_hash(std::size_t hash, double threshold) const;

2342 13 generate_hash 0 4 3480 25 LVecBase3d::generate_hash 0 2 470 471 120
/**
 * Adds the vector to the indicated hash generator.
 */

/**
 * Adds the vector to the indicated hash generator.
 */
171
inline void LVecBase3d::generate_hash(ChecksumHashGenerator &hashgen) const;
inline void LVecBase3d::generate_hash(ChecksumHashGenerator &hashgen, double threshold) const;

2343 10 operator - 0 68 3480 22 LVecBase3d::operator - 0 1 472 0
53
inline LVecBase3d LVecBase3d::operator -(void) const;

2344 10 operator + 0 4 3480 22 LVecBase3d::operator + 0 1 473 0
72
inline LVecBase3d LVecBase3d::operator +(LVecBase3d const &other) const;

2345 10 operator - 0 4 3480 22 LVecBase3d::operator - 0 1 474 0
72
inline LVecBase3d LVecBase3d::operator -(LVecBase3d const &other) const;

2346 10 operator * 0 4 3480 22 LVecBase3d::operator * 0 1 475 0
62
inline LVecBase3d LVecBase3d::operator *(double scalar) const;

2347 10 operator / 0 4 3480 22 LVecBase3d::operator / 0 1 476 0
62
inline LVecBase3d LVecBase3d::operator /(double scalar) const;

2348 11 operator += 0 4 3480 23 LVecBase3d::operator += 0 1 477 0
61
inline void LVecBase3d::operator +=(LVecBase3d const &other);

2349 11 operator -= 0 4 3480 23 LVecBase3d::operator -= 0 1 478 0
61
inline void LVecBase3d::operator -=(LVecBase3d const &other);

2350 11 operator *= 0 4 3480 23 LVecBase3d::operator *= 0 1 479 0
51
inline void LVecBase3d::operator *=(double scalar);

2351 11 operator /= 0 4 3480 23 LVecBase3d::operator /= 0 1 480 0
51
inline void LVecBase3d::operator /=(double scalar);

2352 18 componentwise_mult 0 4 3480 30 LVecBase3d::componentwise_mult 0 1 481 10
/**
 *
 */
68
inline void LVecBase3d::componentwise_mult(LVecBase3d const &other);

2353 7 __pow__ 0 4 3480 19 LVecBase3d::__pow__ 0 1 482 0
61
inline LVecBase3d LVecBase3d::__pow__(double exponent) const;

2354 8 __ipow__ 0 4 3480 20 LVecBase3d::__ipow__ 0 1 483 0
71
inline PyObject *LVecBase3d::__ipow__(PyObject *self, double exponent);

2355 4 fmax 0 4 3480 16 LVecBase3d::fmax 0 1 484 10
/**
 *
 */
66
inline LVecBase3d LVecBase3d::fmax(LVecBase3d const &other) const;

2356 4 fmin 0 4 3480 16 LVecBase3d::fmin 0 1 485 10
/**
 *
 */
66
inline LVecBase3d LVecBase3d::fmin(LVecBase3d const &other) const;

2357 10 cross_into 0 4 3480 22 LVecBase3d::cross_into 0 1 486 10
/**
 *
 */
60
inline void LVecBase3d::cross_into(LVecBase3d const &other);

2358 12 almost_equal 0 4 3480 24 LVecBase3d::almost_equal 0 2 487 488 210
/**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */

/**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */
155
inline bool LVecBase3d::almost_equal(LVecBase3d const &other, double threshold) const;
inline bool LVecBase3d::almost_equal(LVecBase3d const &other) const;

2359 6 output 0 4 3480 18 LVecBase3d::output 0 1 489 10
/**
 *
 */
51
inline void LVecBase3d::output(ostream &out) const;

2360 8 __repr__ 0 4 3480 20 LVecBase3d::__repr__ 0 1 490 0
52
inline std::string LVecBase3d::__repr__(void) const;

2361 20 write_datagram_fixed 0 4 3480 32 LVecBase3d::write_datagram_fixed 0 1 491 332
/**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */
74
inline void LVecBase3d::write_datagram_fixed(Datagram &destination) const;

2362 19 read_datagram_fixed 0 4 3480 31 LVecBase3d::read_datagram_fixed 0 1 492 114
/**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */
70
inline void LVecBase3d::read_datagram_fixed(DatagramIterator &source);

2363 14 write_datagram 0 4 3480 26 LVecBase3d::write_datagram 0 1 493 205
/**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */
68
inline void LVecBase3d::write_datagram(Datagram &destination) const;

2364 13 read_datagram 0 4 3480 25 LVecBase3d::read_datagram 0 1 494 67
/**
 * Reads the vector from the Datagram using get_stdfloat().
 */
64
inline void LVecBase3d::read_datagram(DatagramIterator &source);

2365 14 get_class_type 0 4 3480 26 LVecBase3d::get_class_type 0 1 495 0
51
static TypeHandle LVecBase3d::get_class_type(void);

2366 11 ~LVecBase3d 0 4 3480 23 LVecBase3d::~LVecBase3d 0 0 0
30
LVecBase3d::~LVecBase3d(void);

2367 10 LVecBase3i 0 4 3482 22 LVecBase3i::LVecBase3i 0 5 496 497 498 499 500 34
/**
 *
 */

/**
 *
 */

/**
 *
 */
268
inline LVecBase3i::LVecBase3i(void) = default;
inline LVecBase3i::LVecBase3i(int fill_value);
inline LVecBase3i::LVecBase3i(int x, int y, int z);
inline LVecBase3i::LVecBase3i(LVecBase2i const &copy, int z);
inline LVecBase3i::LVecBase3i(LVecBase3i const &) = default;

2368 12 operator new 0 4 3482 24 LVecBase3i::operator new 0 1 501 0
124
inline void *LVecBase3i::operator new(std::size_t size);
inline void *LVecBase3i::operator new(std::size_t size, void *ptr);

2369 15 operator delete 0 4 3482 27 LVecBase3i::operator delete 0 0 0
108
inline void LVecBase3i::operator delete(void *ptr);
inline void LVecBase3i::operator delete(void *, void *);

2370 12 validate_ptr 0 4 3482 24 LVecBase3i::validate_ptr 0 0 0
61
static inline bool LVecBase3i::validate_ptr(void const *ptr);

2371 10 operator = 0 4 3482 22 LVecBase3i::operator = 0 2 502 503 0
131
LVecBase3i &LVecBase3i::operator =(LVecBase3i const &copy) = default;
LVecBase3i &LVecBase3i::operator =(int fill_value) = default;

2372 4 zero 0 4 3482 16 LVecBase3i::zero 0 1 504 40
/**
 * Returns a zero-length vector.
 */
55
static inline LVecBase3i const &LVecBase3i::zero(void);

2373 6 unit_x 0 4 3482 18 LVecBase3i::unit_x 0 1 505 35
/**
 * Returns a unit X vector.
 */
57
static inline LVecBase3i const &LVecBase3i::unit_x(void);

2374 6 unit_y 0 4 3482 18 LVecBase3i::unit_y 0 1 506 35
/**
 * Returns a unit Y vector.
 */
57
static inline LVecBase3i const &LVecBase3i::unit_y(void);

2375 6 unit_z 0 4 3482 18 LVecBase3i::unit_z 0 1 507 35
/**
 * Returns a unit Z vector.
 */
57
static inline LVecBase3i const &LVecBase3i::unit_z(void);

2376 10 __reduce__ 0 4 3482 22 LVecBase3i::__reduce__ 0 1 508 0
62
inline PyObject *LVecBase3i::__reduce__(PyObject *self) const;

2377 11 __getattr__ 0 4 3482 23 LVecBase3i::__getattr__ 0 1 509 0
93
inline PyObject *LVecBase3i::__getattr__(PyObject *self, std::string const &attr_name) const;

2378 11 __setattr__ 0 4 3482 23 LVecBase3i::__setattr__ 0 1 510 0
99
inline int LVecBase3i::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2379 11 operator [] 0 4 3482 23 LVecBase3i::operator [] 0 2 511 512 10
/**
 *
 */
92
inline int LVecBase3i::operator [](int i) const;
inline int &LVecBase3i::operator [](int i);

2380 4 size 0 4 3482 16 LVecBase3i::size 0 1 513 0
44
static constexpr int LVecBase3i::size(void);

2381 6 is_nan 0 4 3482 18 LVecBase3i::is_nan 0 1 514 91
/**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */
43
inline bool LVecBase3i::is_nan(void) const;

2382 8 get_cell 0 4 3482 20 LVecBase3i::get_cell 0 1 515 10
/**
 *
 */
45
inline int LVecBase3i::get_cell(int i) const;

2383 5 get_x 0 4 3482 17 LVecBase3i::get_x 0 1 516 10
/**
 *
 */
41
inline int LVecBase3i::get_x(void) const;

2384 5 get_y 0 4 3482 17 LVecBase3i::get_y 0 1 517 10
/**
 *
 */
41
inline int LVecBase3i::get_y(void) const;

2385 5 get_z 0 4 3482 17 LVecBase3i::get_z 0 1 518 10
/**
 *
 */
41
inline int LVecBase3i::get_z(void) const;

2386 8 set_cell 0 4 3482 20 LVecBase3i::set_cell 0 1 519 10
/**
 *
 */
51
inline void LVecBase3i::set_cell(int i, int value);

2387 5 set_x 0 4 3482 17 LVecBase3i::set_x 0 1 520 10
/**
 *
 */
41
inline void LVecBase3i::set_x(int value);

2388 5 set_y 0 4 3482 17 LVecBase3i::set_y 0 1 521 10
/**
 *
 */
41
inline void LVecBase3i::set_y(int value);

2389 5 set_z 0 4 3482 17 LVecBase3i::set_z 0 1 522 10
/**
 *
 */
41
inline void LVecBase3i::set_z(int value);

2390 6 get_xy 0 4 3482 18 LVecBase3i::get_xy 0 1 523 100
/**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */
49
inline LVecBase2i LVecBase3i::get_xy(void) const;

2391 6 get_xz 0 4 3482 18 LVecBase3i::get_xz 0 1 524 105
/**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */
49
inline LVecBase2i LVecBase3i::get_xz(void) const;

2392 6 get_yz 0 4 3482 18 LVecBase3i::get_yz 0 1 525 99
/**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */
49
inline LVecBase2i LVecBase3i::get_yz(void) const;

2393 11 add_to_cell 0 4 3482 23 LVecBase3i::add_to_cell 0 1 526 164
// These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages:

/**
 *
 */
54
inline void LVecBase3i::add_to_cell(int i, int value);

2394 5 add_x 0 4 3482 17 LVecBase3i::add_x 0 1 527 10
/**
 *
 */
41
inline void LVecBase3i::add_x(int value);

2395 5 add_y 0 4 3482 17 LVecBase3i::add_y 0 1 528 10
/**
 *
 */
41
inline void LVecBase3i::add_y(int value);

2396 5 add_z 0 4 3482 17 LVecBase3i::add_z 0 1 529 10
/**
 *
 */
41
inline void LVecBase3i::add_z(int value);

2397 8 get_data 0 4 3482 20 LVecBase3i::get_data 0 1 530 162
/**
 * Returns the address of the first of the three data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */
51
inline int const *LVecBase3i::get_data(void) const;

2398 18 get_num_components 0 4 3482 30 LVecBase3i::get_num_components 0 1 531 0
58
static constexpr int LVecBase3i::get_num_components(void);

2399 4 fill 0 4 3482 16 LVecBase3i::fill 0 1 532 129
/**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */
45
inline void LVecBase3i::fill(int fill_value);

2400 3 set 0 4 3482 15 LVecBase3i::set 0 1 533 10
/**
 *
 */
49
inline void LVecBase3i::set(int x, int y, int z);

2401 3 dot 0 4 3482 15 LVecBase3i::dot 0 1 534 10
/**
 *
 */
58
inline int LVecBase3i::dot(LVecBase3i const &other) const;

2402 14 length_squared 0 4 3482 26 LVecBase3i::length_squared 0 1 535 69
/**
 * Returns the square of the vector's length, cheap and easy.
 */
50
inline int LVecBase3i::length_squared(void) const;

2403 5 cross 0 4 3482 17 LVecBase3i::cross 0 1 536 10
/**
 *
 */
67
inline LVecBase3i LVecBase3i::cross(LVecBase3i const &other) const;

2404 10 operator < 0 4 3482 22 LVecBase3i::operator < 0 1 537 0
66
inline bool LVecBase3i::operator <(LVecBase3i const &other) const;

2405 11 operator == 0 4 3482 23 LVecBase3i::operator == 0 1 538 0
67
inline bool LVecBase3i::operator ==(LVecBase3i const &other) const;

2406 11 operator != 0 4 3482 23 LVecBase3i::operator != 0 1 539 0
67
inline bool LVecBase3i::operator !=(LVecBase3i const &other) const;

2407 10 compare_to 0 4 3482 22 LVecBase3i::compare_to 0 1 540 97
/**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */
65
inline int LVecBase3i::compare_to(LVecBase3i const &other) const;

2408 8 get_hash 0 4 3482 20 LVecBase3i::get_hash 0 1 541 49
/**
 * Returns a suitable hash for phash_map.
 */
52
inline std::size_t LVecBase3i::get_hash(void) const;

2409 8 add_hash 0 4 3482 20 LVecBase3i::add_hash 0 1 542 49
/**
 * Adds the vector into the running hash.
 */
64
inline std::size_t LVecBase3i::add_hash(std::size_t hash) const;

2410 13 generate_hash 0 4 3482 25 LVecBase3i::generate_hash 0 1 543 59
/**
 * Adds the vector to the indicated hash generator.
 */
76
inline void LVecBase3i::generate_hash(ChecksumHashGenerator &hashgen) const;

2411 10 operator - 0 68 3482 22 LVecBase3i::operator - 0 1 544 0
53
inline LVecBase3i LVecBase3i::operator -(void) const;

2412 10 operator + 0 4 3482 22 LVecBase3i::operator + 0 1 545 0
72
inline LVecBase3i LVecBase3i::operator +(LVecBase3i const &other) const;

2413 10 operator - 0 4 3482 22 LVecBase3i::operator - 0 1 546 0
72
inline LVecBase3i LVecBase3i::operator -(LVecBase3i const &other) const;

2414 10 operator * 0 4 3482 22 LVecBase3i::operator * 0 1 547 0
59
inline LVecBase3i LVecBase3i::operator *(int scalar) const;

2415 10 operator / 0 4 3482 22 LVecBase3i::operator / 0 1 548 0
59
inline LVecBase3i LVecBase3i::operator /(int scalar) const;

2416 11 operator += 0 4 3482 23 LVecBase3i::operator += 0 1 549 0
61
inline void LVecBase3i::operator +=(LVecBase3i const &other);

2417 11 operator -= 0 4 3482 23 LVecBase3i::operator -= 0 1 550 0
61
inline void LVecBase3i::operator -=(LVecBase3i const &other);

2418 11 operator *= 0 4 3482 23 LVecBase3i::operator *= 0 1 551 0
48
inline void LVecBase3i::operator *=(int scalar);

2419 11 operator /= 0 4 3482 23 LVecBase3i::operator /= 0 1 552 0
48
inline void LVecBase3i::operator /=(int scalar);

2420 18 componentwise_mult 0 4 3482 30 LVecBase3i::componentwise_mult 0 1 553 10
/**
 *
 */
68
inline void LVecBase3i::componentwise_mult(LVecBase3i const &other);

2421 7 __pow__ 0 4 3482 19 LVecBase3i::__pow__ 0 1 554 0
58
inline LVecBase3i LVecBase3i::__pow__(int exponent) const;

2422 8 __ipow__ 0 4 3482 20 LVecBase3i::__ipow__ 0 1 555 0
68
inline PyObject *LVecBase3i::__ipow__(PyObject *self, int exponent);

2423 4 fmax 0 4 3482 16 LVecBase3i::fmax 0 1 556 10
/**
 *
 */
66
inline LVecBase3i LVecBase3i::fmax(LVecBase3i const &other) const;

2424 4 fmin 0 4 3482 16 LVecBase3i::fmin 0 1 557 10
/**
 *
 */
66
inline LVecBase3i LVecBase3i::fmin(LVecBase3i const &other) const;

2425 10 cross_into 0 4 3482 22 LVecBase3i::cross_into 0 1 558 10
/**
 *
 */
60
inline void LVecBase3i::cross_into(LVecBase3i const &other);

2426 12 almost_equal 0 4 3482 24 LVecBase3i::almost_equal 0 2 559 560 210
/**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */

/**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */
152
inline bool LVecBase3i::almost_equal(LVecBase3i const &other, int threshold) const;
inline bool LVecBase3i::almost_equal(LVecBase3i const &other) const;

2427 6 output 0 4 3482 18 LVecBase3i::output 0 1 561 10
/**
 *
 */
51
inline void LVecBase3i::output(ostream &out) const;

2428 8 __repr__ 0 4 3482 20 LVecBase3i::__repr__ 0 1 562 0
52
inline std::string LVecBase3i::__repr__(void) const;

2429 20 write_datagram_fixed 0 4 3482 32 LVecBase3i::write_datagram_fixed 0 1 563 332
/**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */
74
inline void LVecBase3i::write_datagram_fixed(Datagram &destination) const;

2430 19 read_datagram_fixed 0 4 3482 31 LVecBase3i::read_datagram_fixed 0 1 564 114
/**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */
70
inline void LVecBase3i::read_datagram_fixed(DatagramIterator &source);

2431 14 write_datagram 0 4 3482 26 LVecBase3i::write_datagram 0 1 565 205
/**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */
68
inline void LVecBase3i::write_datagram(Datagram &destination) const;

2432 13 read_datagram 0 4 3482 25 LVecBase3i::read_datagram 0 1 566 67
/**
 * Reads the vector from the Datagram using get_stdfloat().
 */
64
inline void LVecBase3i::read_datagram(DatagramIterator &source);

2433 14 get_class_type 0 4 3482 26 LVecBase3i::get_class_type 0 1 567 0
51
static TypeHandle LVecBase3i::get_class_type(void);

2434 11 ~LVecBase3i 0 4 3482 23 LVecBase3i::~LVecBase3i 0 0 0
30
LVecBase3i::~LVecBase3i(void);

2435 29 get_default_coordinate_system 0 1 0 29 get_default_coordinate_system 0 1 1850 0
53
CoordinateSystem get_default_coordinate_system(void);

2436 30 parse_coordinate_system_string 0 1 0 30 parse_coordinate_system_string 0 1 1851 0
72
CoordinateSystem parse_coordinate_system_string(std::string const &str);

2437 24 format_coordinate_system 0 1 0 24 format_coordinate_system 0 1 1852 0
58
std::string format_coordinate_system(CoordinateSystem cs);

2438 15 is_right_handed 0 1 0 15 is_right_handed 0 1 1853 0
57
bool is_right_handed(CoordinateSystem cs = ::CS_default);

2439 9 LVector3f 0 4 3485 20 LVector3f::LVector3f 0 6 568 569 570 571 572 573 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
320
inline LVector3f::LVector3f(void) = default;
inline LVector3f::LVector3f(LVecBase3f const &copy);
inline LVector3f::LVector3f(float fill_value);
inline LVector3f::LVector3f(float x, float y, float z);
inline LVector3f::LVector3f(LVecBase2f const &copy, float z);
inline LVector3f::LVector3f(LVector3f const &) = default;

2440 11 __getattr__ 0 4 3485 22 LVector3f::__getattr__ 0 1 574 0
92
inline PyObject *LVector3f::__getattr__(PyObject *self, std::string const &attr_name) const;

2441 11 __setattr__ 0 4 3485 22 LVector3f::__setattr__ 0 1 575 0
98
inline int LVector3f::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2442 4 zero 0 4 3485 15 LVector3f::zero 0 1 576 40
/**
 * Returns a zero-length vector.
 */
53
static inline LVector3f const &LVector3f::zero(void);

2443 6 unit_x 0 4 3485 17 LVector3f::unit_x 0 1 577 35
/**
 * Returns a unit X vector.
 */
55
static inline LVector3f const &LVector3f::unit_x(void);

2444 6 unit_y 0 4 3485 17 LVector3f::unit_y 0 1 578 35
/**
 * Returns a unit Y vector.
 */
55
static inline LVector3f const &LVector3f::unit_y(void);

2445 6 unit_z 0 4 3485 17 LVector3f::unit_z 0 1 579 35
/**
 * Returns a unit Z vector.
 */
55
static inline LVector3f const &LVector3f::unit_z(void);

2446 6 get_xy 0 4 3485 17 LVector3f::get_xy 0 1 580 100
/**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */
47
inline LVector2f LVector3f::get_xy(void) const;

2447 6 get_xz 0 4 3485 17 LVector3f::get_xz 0 1 581 105
/**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */
47
inline LVector2f LVector3f::get_xz(void) const;

2448 6 get_yz 0 4 3485 17 LVector3f::get_yz 0 1 582 99
/**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */
47
inline LVector2f LVector3f::get_yz(void) const;

2449 10 operator - 0 68 3485 21 LVector3f::operator - 0 1 583 0
51
inline LVector3f LVector3f::operator -(void) const;

2450 10 operator + 0 4 3485 21 LVector3f::operator + 0 2 584 585 0
141
inline LVecBase3f LVector3f::operator +(LVecBase3f const &other) const;
inline LVector3f LVector3f::operator +(LVector3f const &other) const;

2451 10 operator - 0 4 3485 21 LVector3f::operator - 0 2 586 587 0
141
inline LVecBase3f LVector3f::operator -(LVecBase3f const &other) const;
inline LVector3f LVector3f::operator -(LVector3f const &other) const;

2452 5 cross 0 4 3485 16 LVector3f::cross 0 1 588 10
/**
 *
 */
65
inline LVector3f LVector3f::cross(LVecBase3f const &other) const;

2453 10 normalized 0 4 3485 21 LVector3f::normalized 0 1 589 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
51
inline LVector3f LVector3f::normalized(void) const;

2454 7 project 0 4 3485 18 LVector3f::project 0 1 590 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
66
inline LVector3f LVector3f::project(LVecBase3f const &onto) const;

2455 9 angle_rad 0 4 3485 20 LVector3f::angle_rad 0 1 591 147
/**
 * Returns the unsigned angle between this vector and the other one, expressed
 * in radians.  Both vectors should be initially normalized.
 */
64
inline float LVector3f::angle_rad(LVector3f const &other) const;

2456 9 angle_deg 0 4 3485 20 LVector3f::angle_deg 0 1 592 138
/**
 * Returns the angle between this vector and the other one, expressed in
 * degrees.  Both vectors should be initially normalized.
 */
64
inline float LVector3f::angle_deg(LVector3f const &other) const;

2457 16 signed_angle_rad 0 4 3485 27 LVector3f::signed_angle_rad 0 1 593 259
/**
 * returns the signed angle between two vectors.  The angle is positive if the
 * rotation from this vector to other is clockwise when looking in the
 * direction of the ref vector.
 *
 * Vectors (except the ref vector) should be initially normalized.
 */
93
inline float LVector3f::signed_angle_rad(LVector3f const &other, LVector3f const &ref) const;

2458 16 signed_angle_deg 0 4 3485 27 LVector3f::signed_angle_deg 0 1 594 259
/**
 * Returns the signed angle between two vectors.  The angle is positive if the
 * rotation from this vector to other is clockwise when looking in the
 * direction of the ref vector.
 *
 * Vectors (except the ref vector) should be initially normalized.
 */
93
inline float LVector3f::signed_angle_deg(LVector3f const &other, LVector3f const &ref) const;

2459 18 relative_angle_rad 0 4 3485 29 LVector3f::relative_angle_rad 0 1 595 50
/**
 * This method is deprecated.  Do not use.
 */
73
inline float LVector3f::relative_angle_rad(LVector3f const &other) const;

2460 18 relative_angle_deg 0 4 3485 29 LVector3f::relative_angle_deg 0 1 596 50
/**
 * This method is deprecated.  Do not use.
 */
73
inline float LVector3f::relative_angle_deg(LVector3f const &other) const;

2461 10 operator * 0 4 3485 21 LVector3f::operator * 0 1 597 0
59
inline LVector3f LVector3f::operator *(float scalar) const;

2462 10 operator / 0 4 3485 21 LVector3f::operator / 0 1 598 0
59
inline LVector3f LVector3f::operator /(float scalar) const;

2463 2 up 0 4 3485 13 LVector3f::up 0 1 599 65
/**
 * Returns the up vector for the given coordinate system.
 */
74
static inline LVector3f LVector3f::up(CoordinateSystem cs = ::CS_default);

2464 5 right 0 4 3485 16 LVector3f::right 0 1 600 68
/**
 * Returns the right vector for the given coordinate system.
 */
77
static inline LVector3f LVector3f::right(CoordinateSystem cs = ::CS_default);

2465 7 forward 0 4 3485 18 LVector3f::forward 0 1 601 70
/**
 * Returns the forward vector for the given coordinate system.
 */
79
static inline LVector3f LVector3f::forward(CoordinateSystem cs = ::CS_default);

2466 4 down 0 4 3485 15 LVector3f::down 0 1 602 67
/**
 * Returns the down vector for the given coordinate system.
 */
76
static inline LVector3f LVector3f::down(CoordinateSystem cs = ::CS_default);

2467 4 left 0 4 3485 15 LVector3f::left 0 1 603 67
/**
 * Returns the left vector for the given coordinate system.
 */
76
static inline LVector3f LVector3f::left(CoordinateSystem cs = ::CS_default);

2468 4 back 0 4 3485 15 LVector3f::back 0 1 604 67
/**
 * Returns the back vector for the given coordinate system.
 */
76
static inline LVector3f LVector3f::back(CoordinateSystem cs = ::CS_default);

2469 3 rfu 0 4 3485 14 LVector3f::rfu 0 1 605 221
// INLINE_LINMATH static FLOATNAME(LVector3) & rfu(FLOATTYPE right,

/**
 * Returns a vector that is described by its right, forward, and up
 * components, in whatever way the coordinate system represents that vector.
 */
109
static inline LVector3f LVector3f::rfu(float right, float fwd, float up, CoordinateSystem cs = ::CS_default);

2470 8 __repr__ 0 4 3485 19 LVector3f::__repr__ 0 1 606 0
51
inline std::string LVector3f::__repr__(void) const;

2471 14 get_class_type 0 4 3485 25 LVector3f::get_class_type 0 1 607 0
50
static TypeHandle LVector3f::get_class_type(void);

2472 10 ~LVector3f 0 4 3485 21 LVector3f::~LVector3f 0 0 0
28
LVector3f::~LVector3f(void);

2473 9 LVector3d 0 4 3486 20 LVector3d::LVector3d 0 6 608 609 610 611 612 613 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
325
inline LVector3d::LVector3d(void) = default;
inline LVector3d::LVector3d(LVecBase3d const &copy);
inline LVector3d::LVector3d(double fill_value);
inline LVector3d::LVector3d(double x, double y, double z);
inline LVector3d::LVector3d(LVecBase2d const &copy, double z);
inline LVector3d::LVector3d(LVector3d const &) = default;

2474 11 __getattr__ 0 4 3486 22 LVector3d::__getattr__ 0 1 614 0
92
inline PyObject *LVector3d::__getattr__(PyObject *self, std::string const &attr_name) const;

2475 11 __setattr__ 0 4 3486 22 LVector3d::__setattr__ 0 1 615 0
98
inline int LVector3d::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2476 4 zero 0 4 3486 15 LVector3d::zero 0 1 616 40
/**
 * Returns a zero-length vector.
 */
53
static inline LVector3d const &LVector3d::zero(void);

2477 6 unit_x 0 4 3486 17 LVector3d::unit_x 0 1 617 35
/**
 * Returns a unit X vector.
 */
55
static inline LVector3d const &LVector3d::unit_x(void);

2478 6 unit_y 0 4 3486 17 LVector3d::unit_y 0 1 618 35
/**
 * Returns a unit Y vector.
 */
55
static inline LVector3d const &LVector3d::unit_y(void);

2479 6 unit_z 0 4 3486 17 LVector3d::unit_z 0 1 619 35
/**
 * Returns a unit Z vector.
 */
55
static inline LVector3d const &LVector3d::unit_z(void);

2480 6 get_xy 0 4 3486 17 LVector3d::get_xy 0 1 620 100
/**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */
47
inline LVector2d LVector3d::get_xy(void) const;

2481 6 get_xz 0 4 3486 17 LVector3d::get_xz 0 1 621 105
/**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */
47
inline LVector2d LVector3d::get_xz(void) const;

2482 6 get_yz 0 4 3486 17 LVector3d::get_yz 0 1 622 99
/**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */
47
inline LVector2d LVector3d::get_yz(void) const;

2483 10 operator - 0 68 3486 21 LVector3d::operator - 0 1 623 0
51
inline LVector3d LVector3d::operator -(void) const;

2484 10 operator + 0 4 3486 21 LVector3d::operator + 0 2 624 625 0
141
inline LVecBase3d LVector3d::operator +(LVecBase3d const &other) const;
inline LVector3d LVector3d::operator +(LVector3d const &other) const;

2485 10 operator - 0 4 3486 21 LVector3d::operator - 0 2 626 627 0
141
inline LVecBase3d LVector3d::operator -(LVecBase3d const &other) const;
inline LVector3d LVector3d::operator -(LVector3d const &other) const;

2486 5 cross 0 4 3486 16 LVector3d::cross 0 1 628 10
/**
 *
 */
65
inline LVector3d LVector3d::cross(LVecBase3d const &other) const;

2487 10 normalized 0 4 3486 21 LVector3d::normalized 0 1 629 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
51
inline LVector3d LVector3d::normalized(void) const;

2488 7 project 0 4 3486 18 LVector3d::project 0 1 630 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
66
inline LVector3d LVector3d::project(LVecBase3d const &onto) const;

2489 9 angle_rad 0 4 3486 20 LVector3d::angle_rad 0 1 631 147
/**
 * Returns the unsigned angle between this vector and the other one, expressed
 * in radians.  Both vectors should be initially normalized.
 */
65
inline double LVector3d::angle_rad(LVector3d const &other) const;

2490 9 angle_deg 0 4 3486 20 LVector3d::angle_deg 0 1 632 138
/**
 * Returns the angle between this vector and the other one, expressed in
 * degrees.  Both vectors should be initially normalized.
 */
65
inline double LVector3d::angle_deg(LVector3d const &other) const;

2491 16 signed_angle_rad 0 4 3486 27 LVector3d::signed_angle_rad 0 1 633 259
/**
 * returns the signed angle between two vectors.  The angle is positive if the
 * rotation from this vector to other is clockwise when looking in the
 * direction of the ref vector.
 *
 * Vectors (except the ref vector) should be initially normalized.
 */
94
inline double LVector3d::signed_angle_rad(LVector3d const &other, LVector3d const &ref) const;

2492 16 signed_angle_deg 0 4 3486 27 LVector3d::signed_angle_deg 0 1 634 259
/**
 * Returns the signed angle between two vectors.  The angle is positive if the
 * rotation from this vector to other is clockwise when looking in the
 * direction of the ref vector.
 *
 * Vectors (except the ref vector) should be initially normalized.
 */
94
inline double LVector3d::signed_angle_deg(LVector3d const &other, LVector3d const &ref) const;

2493 18 relative_angle_rad 0 4 3486 29 LVector3d::relative_angle_rad 0 1 635 50
/**
 * This method is deprecated.  Do not use.
 */
74
inline double LVector3d::relative_angle_rad(LVector3d const &other) const;

2494 18 relative_angle_deg 0 4 3486 29 LVector3d::relative_angle_deg 0 1 636 50
/**
 * This method is deprecated.  Do not use.
 */
74
inline double LVector3d::relative_angle_deg(LVector3d const &other) const;

2495 10 operator * 0 4 3486 21 LVector3d::operator * 0 1 637 0
60
inline LVector3d LVector3d::operator *(double scalar) const;

2496 10 operator / 0 4 3486 21 LVector3d::operator / 0 1 638 0
60
inline LVector3d LVector3d::operator /(double scalar) const;

2497 2 up 0 4 3486 13 LVector3d::up 0 1 639 65
/**
 * Returns the up vector for the given coordinate system.
 */
74
static inline LVector3d LVector3d::up(CoordinateSystem cs = ::CS_default);

2498 5 right 0 4 3486 16 LVector3d::right 0 1 640 68
/**
 * Returns the right vector for the given coordinate system.
 */
77
static inline LVector3d LVector3d::right(CoordinateSystem cs = ::CS_default);

2499 7 forward 0 4 3486 18 LVector3d::forward 0 1 641 70
/**
 * Returns the forward vector for the given coordinate system.
 */
79
static inline LVector3d LVector3d::forward(CoordinateSystem cs = ::CS_default);

2500 4 down 0 4 3486 15 LVector3d::down 0 1 642 67
/**
 * Returns the down vector for the given coordinate system.
 */
76
static inline LVector3d LVector3d::down(CoordinateSystem cs = ::CS_default);

2501 4 left 0 4 3486 15 LVector3d::left 0 1 643 67
/**
 * Returns the left vector for the given coordinate system.
 */
76
static inline LVector3d LVector3d::left(CoordinateSystem cs = ::CS_default);

2502 4 back 0 4 3486 15 LVector3d::back 0 1 644 67
/**
 * Returns the back vector for the given coordinate system.
 */
76
static inline LVector3d LVector3d::back(CoordinateSystem cs = ::CS_default);

2503 3 rfu 0 4 3486 14 LVector3d::rfu 0 1 645 221
// INLINE_LINMATH static FLOATNAME(LVector3) & rfu(FLOATTYPE right,

/**
 * Returns a vector that is described by its right, forward, and up
 * components, in whatever way the coordinate system represents that vector.
 */
112
static inline LVector3d LVector3d::rfu(double right, double fwd, double up, CoordinateSystem cs = ::CS_default);

2504 8 __repr__ 0 4 3486 19 LVector3d::__repr__ 0 1 646 0
51
inline std::string LVector3d::__repr__(void) const;

2505 14 get_class_type 0 4 3486 25 LVector3d::get_class_type 0 1 647 0
50
static TypeHandle LVector3d::get_class_type(void);

2506 10 ~LVector3d 0 4 3486 21 LVector3d::~LVector3d 0 0 0
28
LVector3d::~LVector3d(void);

2507 9 LVector3i 0 4 3487 20 LVector3i::LVector3i 0 6 648 649 650 651 652 653 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
310
inline LVector3i::LVector3i(void) = default;
inline LVector3i::LVector3i(LVecBase3i const &copy);
inline LVector3i::LVector3i(int fill_value);
inline LVector3i::LVector3i(int x, int y, int z);
inline LVector3i::LVector3i(LVecBase2i const &copy, int z);
inline LVector3i::LVector3i(LVector3i const &) = default;

2508 11 __getattr__ 0 4 3487 22 LVector3i::__getattr__ 0 1 654 0
92
inline PyObject *LVector3i::__getattr__(PyObject *self, std::string const &attr_name) const;

2509 11 __setattr__ 0 4 3487 22 LVector3i::__setattr__ 0 1 655 0
98
inline int LVector3i::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2510 4 zero 0 4 3487 15 LVector3i::zero 0 1 656 40
/**
 * Returns a zero-length vector.
 */
53
static inline LVector3i const &LVector3i::zero(void);

2511 6 unit_x 0 4 3487 17 LVector3i::unit_x 0 1 657 35
/**
 * Returns a unit X vector.
 */
55
static inline LVector3i const &LVector3i::unit_x(void);

2512 6 unit_y 0 4 3487 17 LVector3i::unit_y 0 1 658 35
/**
 * Returns a unit Y vector.
 */
55
static inline LVector3i const &LVector3i::unit_y(void);

2513 6 unit_z 0 4 3487 17 LVector3i::unit_z 0 1 659 35
/**
 * Returns a unit Z vector.
 */
55
static inline LVector3i const &LVector3i::unit_z(void);

2514 6 get_xy 0 4 3487 17 LVector3i::get_xy 0 1 660 100
/**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */
47
inline LVector2i LVector3i::get_xy(void) const;

2515 6 get_xz 0 4 3487 17 LVector3i::get_xz 0 1 661 105
/**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */
47
inline LVector2i LVector3i::get_xz(void) const;

2516 6 get_yz 0 4 3487 17 LVector3i::get_yz 0 1 662 99
/**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */
47
inline LVector2i LVector3i::get_yz(void) const;

2517 10 operator - 0 68 3487 21 LVector3i::operator - 0 1 663 0
51
inline LVector3i LVector3i::operator -(void) const;

2518 10 operator + 0 4 3487 21 LVector3i::operator + 0 2 664 665 0
141
inline LVecBase3i LVector3i::operator +(LVecBase3i const &other) const;
inline LVector3i LVector3i::operator +(LVector3i const &other) const;

2519 10 operator - 0 4 3487 21 LVector3i::operator - 0 2 666 667 0
141
inline LVecBase3i LVector3i::operator -(LVecBase3i const &other) const;
inline LVector3i LVector3i::operator -(LVector3i const &other) const;

2520 5 cross 0 4 3487 16 LVector3i::cross 0 1 668 10
/**
 *
 */
65
inline LVector3i LVector3i::cross(LVecBase3i const &other) const;

2521 10 operator * 0 4 3487 21 LVector3i::operator * 0 1 669 0
57
inline LVector3i LVector3i::operator *(int scalar) const;

2522 10 operator / 0 4 3487 21 LVector3i::operator / 0 1 670 0
57
inline LVector3i LVector3i::operator /(int scalar) const;

2523 2 up 0 4 3487 13 LVector3i::up 0 1 671 65
/**
 * Returns the up vector for the given coordinate system.
 */
74
static inline LVector3i LVector3i::up(CoordinateSystem cs = ::CS_default);

2524 5 right 0 4 3487 16 LVector3i::right 0 1 672 68
/**
 * Returns the right vector for the given coordinate system.
 */
77
static inline LVector3i LVector3i::right(CoordinateSystem cs = ::CS_default);

2525 7 forward 0 4 3487 18 LVector3i::forward 0 1 673 70
/**
 * Returns the forward vector for the given coordinate system.
 */
79
static inline LVector3i LVector3i::forward(CoordinateSystem cs = ::CS_default);

2526 4 down 0 4 3487 15 LVector3i::down 0 1 674 67
/**
 * Returns the down vector for the given coordinate system.
 */
76
static inline LVector3i LVector3i::down(CoordinateSystem cs = ::CS_default);

2527 4 left 0 4 3487 15 LVector3i::left 0 1 675 67
/**
 * Returns the left vector for the given coordinate system.
 */
76
static inline LVector3i LVector3i::left(CoordinateSystem cs = ::CS_default);

2528 4 back 0 4 3487 15 LVector3i::back 0 1 676 67
/**
 * Returns the back vector for the given coordinate system.
 */
76
static inline LVector3i LVector3i::back(CoordinateSystem cs = ::CS_default);

2529 3 rfu 0 4 3487 14 LVector3i::rfu 0 1 677 221
// INLINE_LINMATH static FLOATNAME(LVector3) & rfu(FLOATTYPE right,

/**
 * Returns a vector that is described by its right, forward, and up
 * components, in whatever way the coordinate system represents that vector.
 */
103
static inline LVector3i LVector3i::rfu(int right, int fwd, int up, CoordinateSystem cs = ::CS_default);

2530 8 __repr__ 0 4 3487 19 LVector3i::__repr__ 0 1 678 0
51
inline std::string LVector3i::__repr__(void) const;

2531 14 get_class_type 0 4 3487 25 LVector3i::get_class_type 0 1 679 0
50
static TypeHandle LVector3i::get_class_type(void);

2532 10 ~LVector3i 0 4 3487 21 LVector3i::~LVector3i 0 0 0
28
LVector3i::~LVector3i(void);

2533 8 LPoint3f 0 4 3488 18 LPoint3f::LPoint3f 0 6 680 681 682 683 684 685 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
307
inline LPoint3f::LPoint3f(void) = default;
inline LPoint3f::LPoint3f(LVecBase3f const &copy);
inline LPoint3f::LPoint3f(float fill_value);
inline LPoint3f::LPoint3f(float x, float y, float z);
inline LPoint3f::LPoint3f(LVecBase2f const &copy, float z);
inline LPoint3f::LPoint3f(LPoint3f const &) = default;

2534 11 __getattr__ 0 4 3488 21 LPoint3f::__getattr__ 0 1 686 0
91
inline PyObject *LPoint3f::__getattr__(PyObject *self, std::string const &attr_name) const;

2535 11 __setattr__ 0 4 3488 21 LPoint3f::__setattr__ 0 1 687 0
97
inline int LPoint3f::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2536 4 zero 0 4 3488 14 LPoint3f::zero 0 1 688 39
/**
 * Returns a zero-length point.
 */
51
static inline LPoint3f const &LPoint3f::zero(void);

2537 6 unit_x 0 4 3488 16 LPoint3f::unit_x 0 1 689 34
/**
 * Returns a unit X point.
 */
53
static inline LPoint3f const &LPoint3f::unit_x(void);

2538 6 unit_y 0 4 3488 16 LPoint3f::unit_y 0 1 690 34
/**
 * Returns a unit Y point.
 */
53
static inline LPoint3f const &LPoint3f::unit_y(void);

2539 6 unit_z 0 4 3488 16 LPoint3f::unit_z 0 1 691 34
/**
 * Returns a unit Z point.
 */
53
static inline LPoint3f const &LPoint3f::unit_z(void);

2540 6 get_xy 0 4 3488 16 LPoint3f::get_xy 0 1 692 100
/**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */
45
inline LPoint2f LPoint3f::get_xy(void) const;

2541 6 get_xz 0 4 3488 16 LPoint3f::get_xz 0 1 693 105
/**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */
45
inline LPoint2f LPoint3f::get_xz(void) const;

2542 6 get_yz 0 4 3488 16 LPoint3f::get_yz 0 1 694 99
/**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */
45
inline LPoint2f LPoint3f::get_yz(void) const;

2543 10 operator - 0 68 3488 20 LPoint3f::operator - 0 1 695 0
49
inline LPoint3f LPoint3f::operator -(void) const;

2544 10 operator + 0 4 3488 20 LPoint3f::operator + 0 2 696 697 0
138
inline LVecBase3f LPoint3f::operator +(LVecBase3f const &other) const;
inline LPoint3f LPoint3f::operator +(LVector3f const &other) const;

2545 10 operator - 0 4 3488 20 LPoint3f::operator - 0 3 698 699 700 0
206
inline LVecBase3f LPoint3f::operator -(LVecBase3f const &other) const;
inline LVector3f LPoint3f::operator -(LPoint3f const &other) const;
inline LPoint3f LPoint3f::operator -(LVector3f const &other) const;

2546 5 cross 0 4 3488 15 LPoint3f::cross 0 1 701 10
/**
 *
 */
63
inline LPoint3f LPoint3f::cross(LVecBase3f const &other) const;

2547 10 normalized 0 4 3488 20 LPoint3f::normalized 0 1 702 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
49
inline LPoint3f LPoint3f::normalized(void) const;

2548 7 project 0 4 3488 17 LPoint3f::project 0 1 703 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
64
inline LPoint3f LPoint3f::project(LVecBase3f const &onto) const;

2549 10 operator * 0 4 3488 20 LPoint3f::operator * 0 1 704 0
57
inline LPoint3f LPoint3f::operator *(float scalar) const;

2550 10 operator / 0 4 3488 20 LPoint3f::operator / 0 1 705 0
57
inline LPoint3f LPoint3f::operator /(float scalar) const;

2551 6 origin 0 4 3488 16 LPoint3f::origin 0 1 706 186
/**
 * Returns the origin of the indicated coordinate system.  This is always 0,
 * 0, 0 with all of our existing coordinate systems; it's hard to imagine it
 * ever being different.
 */
83
static inline LPoint3f const &LPoint3f::origin(CoordinateSystem cs = ::CS_default);

2552 3 rfu 0 4 3488 13 LPoint3f::rfu 0 1 707 146
/**
 * Returns a point described by right, forward, up displacements from the
 * origin, wherever that maps to in the given coordinate system.
 */
107
static inline LPoint3f LPoint3f::rfu(float right, float fwd, float up, CoordinateSystem cs = ::CS_default);

2553 8 __repr__ 0 4 3488 18 LPoint3f::__repr__ 0 1 708 0
50
inline std::string LPoint3f::__repr__(void) const;

2554 14 get_class_type 0 4 3488 24 LPoint3f::get_class_type 0 1 709 0
49
static TypeHandle LPoint3f::get_class_type(void);

2555 9 ~LPoint3f 0 4 3488 19 LPoint3f::~LPoint3f 0 0 0
26
LPoint3f::~LPoint3f(void);

2556 8 LPoint3d 0 4 3489 18 LPoint3d::LPoint3d 0 6 710 711 712 713 714 715 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
312
inline LPoint3d::LPoint3d(void) = default;
inline LPoint3d::LPoint3d(LVecBase3d const &copy);
inline LPoint3d::LPoint3d(double fill_value);
inline LPoint3d::LPoint3d(double x, double y, double z);
inline LPoint3d::LPoint3d(LVecBase2d const &copy, double z);
inline LPoint3d::LPoint3d(LPoint3d const &) = default;

2557 11 __getattr__ 0 4 3489 21 LPoint3d::__getattr__ 0 1 716 0
91
inline PyObject *LPoint3d::__getattr__(PyObject *self, std::string const &attr_name) const;

2558 11 __setattr__ 0 4 3489 21 LPoint3d::__setattr__ 0 1 717 0
97
inline int LPoint3d::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2559 4 zero 0 4 3489 14 LPoint3d::zero 0 1 718 39
/**
 * Returns a zero-length point.
 */
51
static inline LPoint3d const &LPoint3d::zero(void);

2560 6 unit_x 0 4 3489 16 LPoint3d::unit_x 0 1 719 34
/**
 * Returns a unit X point.
 */
53
static inline LPoint3d const &LPoint3d::unit_x(void);

2561 6 unit_y 0 4 3489 16 LPoint3d::unit_y 0 1 720 34
/**
 * Returns a unit Y point.
 */
53
static inline LPoint3d const &LPoint3d::unit_y(void);

2562 6 unit_z 0 4 3489 16 LPoint3d::unit_z 0 1 721 34
/**
 * Returns a unit Z point.
 */
53
static inline LPoint3d const &LPoint3d::unit_z(void);

2563 6 get_xy 0 4 3489 16 LPoint3d::get_xy 0 1 722 100
/**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */
45
inline LPoint2d LPoint3d::get_xy(void) const;

2564 6 get_xz 0 4 3489 16 LPoint3d::get_xz 0 1 723 105
/**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */
45
inline LPoint2d LPoint3d::get_xz(void) const;

2565 6 get_yz 0 4 3489 16 LPoint3d::get_yz 0 1 724 99
/**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */
45
inline LPoint2d LPoint3d::get_yz(void) const;

2566 10 operator - 0 68 3489 20 LPoint3d::operator - 0 1 725 0
49
inline LPoint3d LPoint3d::operator -(void) const;

2567 10 operator + 0 4 3489 20 LPoint3d::operator + 0 2 726 727 0
138
inline LVecBase3d LPoint3d::operator +(LVecBase3d const &other) const;
inline LPoint3d LPoint3d::operator +(LVector3d const &other) const;

2568 10 operator - 0 4 3489 20 LPoint3d::operator - 0 3 728 729 730 0
206
inline LVecBase3d LPoint3d::operator -(LVecBase3d const &other) const;
inline LVector3d LPoint3d::operator -(LPoint3d const &other) const;
inline LPoint3d LPoint3d::operator -(LVector3d const &other) const;

2569 5 cross 0 4 3489 15 LPoint3d::cross 0 1 731 10
/**
 *
 */
63
inline LPoint3d LPoint3d::cross(LVecBase3d const &other) const;

2570 10 normalized 0 4 3489 20 LPoint3d::normalized 0 1 732 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
49
inline LPoint3d LPoint3d::normalized(void) const;

2571 7 project 0 4 3489 17 LPoint3d::project 0 1 733 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
64
inline LPoint3d LPoint3d::project(LVecBase3d const &onto) const;

2572 10 operator * 0 4 3489 20 LPoint3d::operator * 0 1 734 0
58
inline LPoint3d LPoint3d::operator *(double scalar) const;

2573 10 operator / 0 4 3489 20 LPoint3d::operator / 0 1 735 0
58
inline LPoint3d LPoint3d::operator /(double scalar) const;

2574 6 origin 0 4 3489 16 LPoint3d::origin 0 1 736 186
/**
 * Returns the origin of the indicated coordinate system.  This is always 0,
 * 0, 0 with all of our existing coordinate systems; it's hard to imagine it
 * ever being different.
 */
83
static inline LPoint3d const &LPoint3d::origin(CoordinateSystem cs = ::CS_default);

2575 3 rfu 0 4 3489 13 LPoint3d::rfu 0 1 737 146
/**
 * Returns a point described by right, forward, up displacements from the
 * origin, wherever that maps to in the given coordinate system.
 */
110
static inline LPoint3d LPoint3d::rfu(double right, double fwd, double up, CoordinateSystem cs = ::CS_default);

2576 8 __repr__ 0 4 3489 18 LPoint3d::__repr__ 0 1 738 0
50
inline std::string LPoint3d::__repr__(void) const;

2577 14 get_class_type 0 4 3489 24 LPoint3d::get_class_type 0 1 739 0
49
static TypeHandle LPoint3d::get_class_type(void);

2578 9 ~LPoint3d 0 4 3489 19 LPoint3d::~LPoint3d 0 0 0
26
LPoint3d::~LPoint3d(void);

2579 8 LPoint3i 0 4 3490 18 LPoint3i::LPoint3i 0 6 740 741 742 743 744 745 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
297
inline LPoint3i::LPoint3i(void) = default;
inline LPoint3i::LPoint3i(LVecBase3i const &copy);
inline LPoint3i::LPoint3i(int fill_value);
inline LPoint3i::LPoint3i(int x, int y, int z);
inline LPoint3i::LPoint3i(LVecBase2i const &copy, int z);
inline LPoint3i::LPoint3i(LPoint3i const &) = default;

2580 11 __getattr__ 0 4 3490 21 LPoint3i::__getattr__ 0 1 746 0
91
inline PyObject *LPoint3i::__getattr__(PyObject *self, std::string const &attr_name) const;

2581 11 __setattr__ 0 4 3490 21 LPoint3i::__setattr__ 0 1 747 0
97
inline int LPoint3i::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2582 4 zero 0 4 3490 14 LPoint3i::zero 0 1 748 39
/**
 * Returns a zero-length point.
 */
51
static inline LPoint3i const &LPoint3i::zero(void);

2583 6 unit_x 0 4 3490 16 LPoint3i::unit_x 0 1 749 34
/**
 * Returns a unit X point.
 */
53
static inline LPoint3i const &LPoint3i::unit_x(void);

2584 6 unit_y 0 4 3490 16 LPoint3i::unit_y 0 1 750 34
/**
 * Returns a unit Y point.
 */
53
static inline LPoint3i const &LPoint3i::unit_y(void);

2585 6 unit_z 0 4 3490 16 LPoint3i::unit_z 0 1 751 34
/**
 * Returns a unit Z point.
 */
53
static inline LPoint3i const &LPoint3i::unit_z(void);

2586 6 get_xy 0 4 3490 16 LPoint3i::get_xy 0 1 752 100
/**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */
45
inline LPoint2i LPoint3i::get_xy(void) const;

2587 6 get_xz 0 4 3490 16 LPoint3i::get_xz 0 1 753 105
/**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */
45
inline LPoint2i LPoint3i::get_xz(void) const;

2588 6 get_yz 0 4 3490 16 LPoint3i::get_yz 0 1 754 99
/**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */
45
inline LPoint2i LPoint3i::get_yz(void) const;

2589 10 operator - 0 68 3490 20 LPoint3i::operator - 0 1 755 0
49
inline LPoint3i LPoint3i::operator -(void) const;

2590 10 operator + 0 4 3490 20 LPoint3i::operator + 0 2 756 757 0
138
inline LVecBase3i LPoint3i::operator +(LVecBase3i const &other) const;
inline LPoint3i LPoint3i::operator +(LVector3i const &other) const;

2591 10 operator - 0 4 3490 20 LPoint3i::operator - 0 3 758 759 760 0
206
inline LVecBase3i LPoint3i::operator -(LVecBase3i const &other) const;
inline LVector3i LPoint3i::operator -(LPoint3i const &other) const;
inline LPoint3i LPoint3i::operator -(LVector3i const &other) const;

2592 5 cross 0 4 3490 15 LPoint3i::cross 0 1 761 10
/**
 *
 */
63
inline LPoint3i LPoint3i::cross(LVecBase3i const &other) const;

2593 10 operator * 0 4 3490 20 LPoint3i::operator * 0 1 762 0
55
inline LPoint3i LPoint3i::operator *(int scalar) const;

2594 10 operator / 0 4 3490 20 LPoint3i::operator / 0 1 763 0
55
inline LPoint3i LPoint3i::operator /(int scalar) const;

2595 6 origin 0 4 3490 16 LPoint3i::origin 0 1 764 186
/**
 * Returns the origin of the indicated coordinate system.  This is always 0,
 * 0, 0 with all of our existing coordinate systems; it's hard to imagine it
 * ever being different.
 */
83
static inline LPoint3i const &LPoint3i::origin(CoordinateSystem cs = ::CS_default);

2596 3 rfu 0 4 3490 13 LPoint3i::rfu 0 1 765 146
/**
 * Returns a point described by right, forward, up displacements from the
 * origin, wherever that maps to in the given coordinate system.
 */
101
static inline LPoint3i LPoint3i::rfu(int right, int fwd, int up, CoordinateSystem cs = ::CS_default);

2597 8 __repr__ 0 4 3490 18 LPoint3i::__repr__ 0 1 766 0
50
inline std::string LPoint3i::__repr__(void) const;

2598 14 get_class_type 0 4 3490 24 LPoint3i::get_class_type 0 1 767 0
49
static TypeHandle LPoint3i::get_class_type(void);

2599 9 ~LPoint3i 0 4 3490 19 LPoint3i::~LPoint3i 0 0 0
26
LPoint3i::~LPoint3i(void);

2600 10 LVecBase4f 0 4 3491 22 LVecBase4f::LVecBase4f 0 8 768 769 770 771 772 773 774 775 219
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 * Constructs an LVecBase4 from an LPoint3.  The w coordinate is set to 1.0.
 */

/**
 * Constructs an LVecBase4 from an LVector3.  The w coordinate is set to 0.0.
 */
461
inline LVecBase4f::LVecBase4f(void) = default;
inline LVecBase4f::LVecBase4f(float fill_value);
inline LVecBase4f::LVecBase4f(float x, float y, float z, float w);
inline LVecBase4f::LVecBase4f(UnalignedLVecBase4f const &copy);
inline LVecBase4f::LVecBase4f(LVecBase3f const &copy, float w);
inline LVecBase4f::LVecBase4f(LPoint3f const &point);
inline LVecBase4f::LVecBase4f(LVector3f const &vector);
inline LVecBase4f::LVecBase4f(LVecBase4f const &) = default;

2601 12 operator new 0 4 3491 24 LVecBase4f::operator new 0 1 776 0
124
inline void *LVecBase4f::operator new(std::size_t size);
inline void *LVecBase4f::operator new(std::size_t size, void *ptr);

2602 15 operator delete 0 4 3491 27 LVecBase4f::operator delete 0 0 0
108
inline void LVecBase4f::operator delete(void *ptr);
inline void LVecBase4f::operator delete(void *, void *);

2603 12 validate_ptr 0 4 3491 24 LVecBase4f::validate_ptr 0 0 0
61
static inline bool LVecBase4f::validate_ptr(void const *ptr);

2604 10 operator = 0 4 3491 22 LVecBase4f::operator = 0 2 777 778 0
133
LVecBase4f &LVecBase4f::operator =(LVecBase4f const &copy) = default;
LVecBase4f &LVecBase4f::operator =(float fill_value) = default;

2605 4 zero 0 4 3491 16 LVecBase4f::zero 0 1 779 40
/**
 * Returns a zero-length vector.
 */
55
static inline LVecBase4f const &LVecBase4f::zero(void);

2606 6 unit_x 0 4 3491 18 LVecBase4f::unit_x 0 1 780 35
/**
 * Returns a unit X vector.
 */
57
static inline LVecBase4f const &LVecBase4f::unit_x(void);

2607 6 unit_y 0 4 3491 18 LVecBase4f::unit_y 0 1 781 35
/**
 * Returns a unit Y vector.
 */
57
static inline LVecBase4f const &LVecBase4f::unit_y(void);

2608 6 unit_z 0 4 3491 18 LVecBase4f::unit_z 0 1 782 35
/**
 * Returns a unit Z vector.
 */
57
static inline LVecBase4f const &LVecBase4f::unit_z(void);

2609 6 unit_w 0 4 3491 18 LVecBase4f::unit_w 0 1 783 35
/**
 * Returns a unit W vector.
 */
57
static inline LVecBase4f const &LVecBase4f::unit_w(void);

2610 10 __reduce__ 0 4 3491 22 LVecBase4f::__reduce__ 0 1 784 0
62
inline PyObject *LVecBase4f::__reduce__(PyObject *self) const;

2611 11 __getattr__ 0 4 3491 23 LVecBase4f::__getattr__ 0 1 785 0
93
inline PyObject *LVecBase4f::__getattr__(PyObject *self, std::string const &attr_name) const;

2612 11 __setattr__ 0 4 3491 23 LVecBase4f::__setattr__ 0 1 786 0
99
inline int LVecBase4f::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2613 11 operator [] 0 4 3491 23 LVecBase4f::operator [] 0 2 787 788 10
/**
 *
 */
96
inline float LVecBase4f::operator [](int i) const;
inline float &LVecBase4f::operator [](int i);

2614 4 size 0 4 3491 16 LVecBase4f::size 0 1 789 0
44
static constexpr int LVecBase4f::size(void);

2615 6 is_nan 0 4 3491 18 LVecBase4f::is_nan 0 1 790 91
/**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */
43
inline bool LVecBase4f::is_nan(void) const;

2616 8 get_cell 0 4 3491 20 LVecBase4f::get_cell 0 1 791 10
/**
 *
 */
47
inline float LVecBase4f::get_cell(int i) const;

2617 8 set_cell 0 4 3491 20 LVecBase4f::set_cell 0 1 792 10
/**
 *
 */
53
inline void LVecBase4f::set_cell(int i, float value);

2618 5 get_x 0 4 3491 17 LVecBase4f::get_x 0 1 793 10
/**
 *
 */
43
inline float LVecBase4f::get_x(void) const;

2619 5 get_y 0 4 3491 17 LVecBase4f::get_y 0 1 794 10
/**
 *
 */
43
inline float LVecBase4f::get_y(void) const;

2620 5 get_z 0 4 3491 17 LVecBase4f::get_z 0 1 795 10
/**
 *
 */
43
inline float LVecBase4f::get_z(void) const;

2621 5 get_w 0 4 3491 17 LVecBase4f::get_w 0 1 796 10
/**
 *
 */
43
inline float LVecBase4f::get_w(void) const;

2622 7 get_xyz 0 4 3491 19 LVecBase4f::get_xyz 0 1 797 58
/**
 * Returns the x, y and z component of this vector
 */
50
inline LVecBase3f LVecBase4f::get_xyz(void) const;

2623 6 get_xy 0 4 3491 18 LVecBase4f::get_xy 0 1 798 55
/**
 * Returns the x and y component of this vector
 */
49
inline LVecBase2f LVecBase4f::get_xy(void) const;

2624 5 set_x 0 4 3491 17 LVecBase4f::set_x 0 1 799 10
/**
 *
 */
43
inline void LVecBase4f::set_x(float value);

2625 5 set_y 0 4 3491 17 LVecBase4f::set_y 0 1 800 10
/**
 *
 */
43
inline void LVecBase4f::set_y(float value);

2626 5 set_z 0 4 3491 17 LVecBase4f::set_z 0 1 801 10
/**
 *
 */
43
inline void LVecBase4f::set_z(float value);

2627 5 set_w 0 4 3491 17 LVecBase4f::set_w 0 1 802 10
/**
 *
 */
43
inline void LVecBase4f::set_w(float value);

2628 11 add_to_cell 0 4 3491 23 LVecBase4f::add_to_cell 0 1 803 164
// These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages:

/**
 *
 */
56
inline void LVecBase4f::add_to_cell(int i, float value);

2629 5 add_x 0 4 3491 17 LVecBase4f::add_x 0 1 804 10
/**
 *
 */
43
inline void LVecBase4f::add_x(float value);

2630 5 add_y 0 4 3491 17 LVecBase4f::add_y 0 1 805 10
/**
 *
 */
43
inline void LVecBase4f::add_y(float value);

2631 5 add_z 0 4 3491 17 LVecBase4f::add_z 0 1 806 10
/**
 *
 */
43
inline void LVecBase4f::add_z(float value);

2632 5 add_w 0 4 3491 17 LVecBase4f::add_w 0 1 807 10
/**
 *
 */
43
inline void LVecBase4f::add_w(float value);

2633 8 get_data 0 4 3491 20 LVecBase4f::get_data 0 1 808 161
/**
 * Returns the address of the first of the four data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */
53
inline float const *LVecBase4f::get_data(void) const;

2634 18 get_num_components 0 4 3491 30 LVecBase4f::get_num_components 0 1 809 0
58
static constexpr int LVecBase4f::get_num_components(void);

2635 12 extract_data 0 4 3491 24 LVecBase4f::extract_data 0 0 0
46
inline void LVecBase4f::extract_data(float *);

2636 4 fill 0 4 3491 16 LVecBase4f::fill 0 1 810 129
/**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */
47
inline void LVecBase4f::fill(float fill_value);

2637 3 set 0 4 3491 15 LVecBase4f::set 0 1 811 10
/**
 *
 */
64
inline void LVecBase4f::set(float x, float y, float z, float w);

2638 3 dot 0 4 3491 15 LVecBase4f::dot 0 1 812 10
/**
 *
 */
60
inline float LVecBase4f::dot(LVecBase4f const &other) const;

2639 14 length_squared 0 4 3491 26 LVecBase4f::length_squared 0 1 813 69
/**
 * Returns the square of the vector's length, cheap and easy.
 */
52
inline float LVecBase4f::length_squared(void) const;

2640 6 length 0 4 3491 18 LVecBase4f::length 0 1 814 72
/**
 * Returns the length of the vector, by the Pythagorean theorem.
 */
44
inline float LVecBase4f::length(void) const;

2641 9 normalize 0 4 3491 21 LVecBase4f::normalize 0 1 815 127
/**
 * Normalizes the vector in place.  Returns true if the vector was normalized,
 * false if it was a zero-length vector.
 */
40
inline bool LVecBase4f::normalize(void);

2642 10 normalized 0 4 3491 22 LVecBase4f::normalized 0 1 816 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
53
inline LVecBase4f LVecBase4f::normalized(void) const;

2643 7 project 0 4 3491 19 LVecBase4f::project 0 1 817 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
68
inline LVecBase4f LVecBase4f::project(LVecBase4f const &onto) const;

2644 10 operator < 0 4 3491 22 LVecBase4f::operator < 0 1 818 0
66
inline bool LVecBase4f::operator <(LVecBase4f const &other) const;

2645 11 operator == 0 4 3491 23 LVecBase4f::operator == 0 1 819 0
67
inline bool LVecBase4f::operator ==(LVecBase4f const &other) const;

2646 11 operator != 0 4 3491 23 LVecBase4f::operator != 0 1 820 0
67
inline bool LVecBase4f::operator !=(LVecBase4f const &other) const;

2647 10 compare_to 0 4 3491 22 LVecBase4f::compare_to 0 2 821 822 332
/**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */

/**
 * Sorts vectors lexicographically, componentwise.  Returns a number less than
 * 0 if this vector sorts before the other one, greater than zero if it sorts
 * after, 0 if they are equivalent (within the indicated tolerance).
 */
148
inline int LVecBase4f::compare_to(LVecBase4f const &other) const;
inline int LVecBase4f::compare_to(LVecBase4f const &other, float threshold) const;

2648 8 get_hash 0 4 3491 20 LVecBase4f::get_hash 0 2 823 824 100
/**
 * Returns a suitable hash for phash_map.
 */

/**
 * Returns a suitable hash for phash_map.
 */
116
inline std::size_t LVecBase4f::get_hash(void) const;
inline std::size_t LVecBase4f::get_hash(float threshold) const;

2649 8 add_hash 0 4 3491 20 LVecBase4f::add_hash 0 2 825 826 100
/**
 * Adds the vector into the running hash.
 */

/**
 * Adds the vector into the running hash.
 */
146
inline std::size_t LVecBase4f::add_hash(std::size_t hash) const;
inline std::size_t LVecBase4f::add_hash(std::size_t hash, float threshold) const;

2650 13 generate_hash 0 4 3491 25 LVecBase4f::generate_hash 0 2 827 828 120
/**
 * Adds the vector to the indicated hash generator.
 */

/**
 * Adds the vector to the indicated hash generator.
 */
170
inline void LVecBase4f::generate_hash(ChecksumHashGenerator &hashgen) const;
inline void LVecBase4f::generate_hash(ChecksumHashGenerator &hashgen, float threshold) const;

2651 10 operator - 0 68 3491 22 LVecBase4f::operator - 0 1 829 0
53
inline LVecBase4f LVecBase4f::operator -(void) const;

2652 10 operator + 0 4 3491 22 LVecBase4f::operator + 0 1 830 0
72
inline LVecBase4f LVecBase4f::operator +(LVecBase4f const &other) const;

2653 10 operator - 0 4 3491 22 LVecBase4f::operator - 0 1 831 0
72
inline LVecBase4f LVecBase4f::operator -(LVecBase4f const &other) const;

2654 10 operator * 0 4 3491 22 LVecBase4f::operator * 0 1 832 0
61
inline LVecBase4f LVecBase4f::operator *(float scalar) const;

2655 10 operator / 0 4 3491 22 LVecBase4f::operator / 0 1 833 0
61
inline LVecBase4f LVecBase4f::operator /(float scalar) const;

2656 11 operator += 0 4 3491 23 LVecBase4f::operator += 0 1 834 0
61
inline void LVecBase4f::operator +=(LVecBase4f const &other);

2657 11 operator -= 0 4 3491 23 LVecBase4f::operator -= 0 1 835 0
61
inline void LVecBase4f::operator -=(LVecBase4f const &other);

2658 11 operator *= 0 4 3491 23 LVecBase4f::operator *= 0 1 836 0
50
inline void LVecBase4f::operator *=(float scalar);

2659 11 operator /= 0 4 3491 23 LVecBase4f::operator /= 0 1 837 0
50
inline void LVecBase4f::operator /=(float scalar);

2660 18 componentwise_mult 0 4 3491 30 LVecBase4f::componentwise_mult 0 1 838 10
/**
 *
 */
68
inline void LVecBase4f::componentwise_mult(LVecBase4f const &other);

2661 7 __pow__ 0 4 3491 19 LVecBase4f::__pow__ 0 1 839 0
60
inline LVecBase4f LVecBase4f::__pow__(float exponent) const;

2662 8 __ipow__ 0 4 3491 20 LVecBase4f::__ipow__ 0 1 840 0
70
inline PyObject *LVecBase4f::__ipow__(PyObject *self, float exponent);

2663 4 fmax 0 4 3491 16 LVecBase4f::fmax 0 1 841 10
/**
 *
 */
66
inline LVecBase4f LVecBase4f::fmax(LVecBase4f const &other) const;

2664 4 fmin 0 4 3491 16 LVecBase4f::fmin 0 1 842 10
/**
 *
 */
66
inline LVecBase4f LVecBase4f::fmin(LVecBase4f const &other) const;

2665 12 almost_equal 0 4 3491 24 LVecBase4f::almost_equal 0 2 843 844 210
/**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */

/**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */
154
inline bool LVecBase4f::almost_equal(LVecBase4f const &other, float threshold) const;
inline bool LVecBase4f::almost_equal(LVecBase4f const &other) const;

2666 6 output 0 4 3491 18 LVecBase4f::output 0 1 845 10
/**
 *
 */
51
inline void LVecBase4f::output(ostream &out) const;

2667 8 __repr__ 0 4 3491 20 LVecBase4f::__repr__ 0 1 846 0
52
inline std::string LVecBase4f::__repr__(void) const;

2668 20 write_datagram_fixed 0 4 3491 32 LVecBase4f::write_datagram_fixed 0 1 847 332
/**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */
74
inline void LVecBase4f::write_datagram_fixed(Datagram &destination) const;

2669 19 read_datagram_fixed 0 4 3491 31 LVecBase4f::read_datagram_fixed 0 1 848 114
/**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */
70
inline void LVecBase4f::read_datagram_fixed(DatagramIterator &source);

2670 14 write_datagram 0 4 3491 26 LVecBase4f::write_datagram 0 1 849 205
/**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */
68
inline void LVecBase4f::write_datagram(Datagram &destination) const;

2671 13 read_datagram 0 4 3491 25 LVecBase4f::read_datagram 0 1 850 67
/**
 * Reads the vector from the Datagram using get_stdfloat().
 */
64
inline void LVecBase4f::read_datagram(DatagramIterator &source);

2672 14 get_class_type 0 4 3491 26 LVecBase4f::get_class_type 0 1 851 0
51
static TypeHandle LVecBase4f::get_class_type(void);

2673 11 ~LVecBase4f 0 4 3491 23 LVecBase4f::~LVecBase4f 0 0 0
30
LVecBase4f::~LVecBase4f(void);

2674 19 UnalignedLVecBase4f 0 4 3493 40 UnalignedLVecBase4f::UnalignedLVecBase4f 0 4 852 853 854 855 22
/**
 *
 */

/**
 *
 */
310
inline UnalignedLVecBase4f::UnalignedLVecBase4f(void) = default;
inline UnalignedLVecBase4f::UnalignedLVecBase4f(LVecBase4f const &copy);
inline UnalignedLVecBase4f::UnalignedLVecBase4f(float x, float y, float z, float w);
inline UnalignedLVecBase4f::UnalignedLVecBase4f(UnalignedLVecBase4f const &) = default;

2675 3 set 0 4 3493 24 UnalignedLVecBase4f::set 0 1 856 10
/**
 *
 */
73
inline void UnalignedLVecBase4f::set(float x, float y, float z, float w);

2676 11 operator [] 0 4 3493 32 UnalignedLVecBase4f::operator [] 0 2 857 858 10
/**
 *
 */
114
inline float UnalignedLVecBase4f::operator [](int i) const;
inline float &UnalignedLVecBase4f::operator [](int i);

2677 4 size 0 4 3493 25 UnalignedLVecBase4f::size 0 1 859 0
53
static constexpr int UnalignedLVecBase4f::size(void);

2678 8 get_data 0 4 3493 29 UnalignedLVecBase4f::get_data 0 1 860 162
/**
 * Returns the address of the first of the three data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */
62
inline float const *UnalignedLVecBase4f::get_data(void) const;

2679 18 get_num_components 0 4 3493 39 UnalignedLVecBase4f::get_num_components 0 1 861 0
67
static constexpr int UnalignedLVecBase4f::get_num_components(void);

2680 14 get_class_type 0 4 3493 35 UnalignedLVecBase4f::get_class_type 0 1 862 0
60
static TypeHandle UnalignedLVecBase4f::get_class_type(void);

2681 20 ~UnalignedLVecBase4f 0 4 3493 41 UnalignedLVecBase4f::~UnalignedLVecBase4f 0 0 0
48
UnalignedLVecBase4f::~UnalignedLVecBase4f(void);

2682 10 LVecBase4d 0 4 3495 22 LVecBase4d::LVecBase4d 0 8 863 864 865 866 867 868 869 870 219
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 * Constructs an LVecBase4 from an LPoint3.  The w coordinate is set to 1.0.
 */

/**
 * Constructs an LVecBase4 from an LVector3.  The w coordinate is set to 0.0.
 */
467
inline LVecBase4d::LVecBase4d(void) = default;
inline LVecBase4d::LVecBase4d(double fill_value);
inline LVecBase4d::LVecBase4d(double x, double y, double z, double w);
inline LVecBase4d::LVecBase4d(UnalignedLVecBase4d const &copy);
inline LVecBase4d::LVecBase4d(LVecBase3d const &copy, double w);
inline LVecBase4d::LVecBase4d(LPoint3d const &point);
inline LVecBase4d::LVecBase4d(LVector3d const &vector);
inline LVecBase4d::LVecBase4d(LVecBase4d const &) = default;

2683 12 operator new 0 4 3495 24 LVecBase4d::operator new 0 1 871 0
124
inline void *LVecBase4d::operator new(std::size_t size);
inline void *LVecBase4d::operator new(std::size_t size, void *ptr);

2684 15 operator delete 0 4 3495 27 LVecBase4d::operator delete 0 0 0
108
inline void LVecBase4d::operator delete(void *ptr);
inline void LVecBase4d::operator delete(void *, void *);

2685 12 validate_ptr 0 4 3495 24 LVecBase4d::validate_ptr 0 0 0
61
static inline bool LVecBase4d::validate_ptr(void const *ptr);

2686 10 operator = 0 4 3495 22 LVecBase4d::operator = 0 2 872 873 0
134
LVecBase4d &LVecBase4d::operator =(LVecBase4d const &copy) = default;
LVecBase4d &LVecBase4d::operator =(double fill_value) = default;

2687 4 zero 0 4 3495 16 LVecBase4d::zero 0 1 874 40
/**
 * Returns a zero-length vector.
 */
55
static inline LVecBase4d const &LVecBase4d::zero(void);

2688 6 unit_x 0 4 3495 18 LVecBase4d::unit_x 0 1 875 35
/**
 * Returns a unit X vector.
 */
57
static inline LVecBase4d const &LVecBase4d::unit_x(void);

2689 6 unit_y 0 4 3495 18 LVecBase4d::unit_y 0 1 876 35
/**
 * Returns a unit Y vector.
 */
57
static inline LVecBase4d const &LVecBase4d::unit_y(void);

2690 6 unit_z 0 4 3495 18 LVecBase4d::unit_z 0 1 877 35
/**
 * Returns a unit Z vector.
 */
57
static inline LVecBase4d const &LVecBase4d::unit_z(void);

2691 6 unit_w 0 4 3495 18 LVecBase4d::unit_w 0 1 878 35
/**
 * Returns a unit W vector.
 */
57
static inline LVecBase4d const &LVecBase4d::unit_w(void);

2692 10 __reduce__ 0 4 3495 22 LVecBase4d::__reduce__ 0 1 879 0
62
inline PyObject *LVecBase4d::__reduce__(PyObject *self) const;

2693 11 __getattr__ 0 4 3495 23 LVecBase4d::__getattr__ 0 1 880 0
93
inline PyObject *LVecBase4d::__getattr__(PyObject *self, std::string const &attr_name) const;

2694 11 __setattr__ 0 4 3495 23 LVecBase4d::__setattr__ 0 1 881 0
99
inline int LVecBase4d::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2695 11 operator [] 0 4 3495 23 LVecBase4d::operator [] 0 2 882 883 10
/**
 *
 */
98
inline double LVecBase4d::operator [](int i) const;
inline double &LVecBase4d::operator [](int i);

2696 4 size 0 4 3495 16 LVecBase4d::size 0 1 884 0
44
static constexpr int LVecBase4d::size(void);

2697 6 is_nan 0 4 3495 18 LVecBase4d::is_nan 0 1 885 91
/**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */
43
inline bool LVecBase4d::is_nan(void) const;

2698 8 get_cell 0 4 3495 20 LVecBase4d::get_cell 0 1 886 10
/**
 *
 */
48
inline double LVecBase4d::get_cell(int i) const;

2699 8 set_cell 0 4 3495 20 LVecBase4d::set_cell 0 1 887 10
/**
 *
 */
54
inline void LVecBase4d::set_cell(int i, double value);

2700 5 get_x 0 4 3495 17 LVecBase4d::get_x 0 1 888 10
/**
 *
 */
44
inline double LVecBase4d::get_x(void) const;

2701 5 get_y 0 4 3495 17 LVecBase4d::get_y 0 1 889 10
/**
 *
 */
44
inline double LVecBase4d::get_y(void) const;

2702 5 get_z 0 4 3495 17 LVecBase4d::get_z 0 1 890 10
/**
 *
 */
44
inline double LVecBase4d::get_z(void) const;

2703 5 get_w 0 4 3495 17 LVecBase4d::get_w 0 1 891 10
/**
 *
 */
44
inline double LVecBase4d::get_w(void) const;

2704 7 get_xyz 0 4 3495 19 LVecBase4d::get_xyz 0 1 892 58
/**
 * Returns the x, y and z component of this vector
 */
50
inline LVecBase3d LVecBase4d::get_xyz(void) const;

2705 6 get_xy 0 4 3495 18 LVecBase4d::get_xy 0 1 893 55
/**
 * Returns the x and y component of this vector
 */
49
inline LVecBase2d LVecBase4d::get_xy(void) const;

2706 5 set_x 0 4 3495 17 LVecBase4d::set_x 0 1 894 10
/**
 *
 */
44
inline void LVecBase4d::set_x(double value);

2707 5 set_y 0 4 3495 17 LVecBase4d::set_y 0 1 895 10
/**
 *
 */
44
inline void LVecBase4d::set_y(double value);

2708 5 set_z 0 4 3495 17 LVecBase4d::set_z 0 1 896 10
/**
 *
 */
44
inline void LVecBase4d::set_z(double value);

2709 5 set_w 0 4 3495 17 LVecBase4d::set_w 0 1 897 10
/**
 *
 */
44
inline void LVecBase4d::set_w(double value);

2710 11 add_to_cell 0 4 3495 23 LVecBase4d::add_to_cell 0 1 898 164
// These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages:

/**
 *
 */
57
inline void LVecBase4d::add_to_cell(int i, double value);

2711 5 add_x 0 4 3495 17 LVecBase4d::add_x 0 1 899 10
/**
 *
 */
44
inline void LVecBase4d::add_x(double value);

2712 5 add_y 0 4 3495 17 LVecBase4d::add_y 0 1 900 10
/**
 *
 */
44
inline void LVecBase4d::add_y(double value);

2713 5 add_z 0 4 3495 17 LVecBase4d::add_z 0 1 901 10
/**
 *
 */
44
inline void LVecBase4d::add_z(double value);

2714 5 add_w 0 4 3495 17 LVecBase4d::add_w 0 1 902 10
/**
 *
 */
44
inline void LVecBase4d::add_w(double value);

2715 8 get_data 0 4 3495 20 LVecBase4d::get_data 0 1 903 161
/**
 * Returns the address of the first of the four data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */
54
inline double const *LVecBase4d::get_data(void) const;

2716 18 get_num_components 0 4 3495 30 LVecBase4d::get_num_components 0 1 904 0
58
static constexpr int LVecBase4d::get_num_components(void);

2717 12 extract_data 0 4 3495 24 LVecBase4d::extract_data 0 0 0
46
inline void LVecBase4d::extract_data(float *);

2718 4 fill 0 4 3495 16 LVecBase4d::fill 0 1 905 129
/**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */
48
inline void LVecBase4d::fill(double fill_value);

2719 3 set 0 4 3495 15 LVecBase4d::set 0 1 906 10
/**
 *
 */
68
inline void LVecBase4d::set(double x, double y, double z, double w);

2720 3 dot 0 4 3495 15 LVecBase4d::dot 0 1 907 10
/**
 *
 */
61
inline double LVecBase4d::dot(LVecBase4d const &other) const;

2721 14 length_squared 0 4 3495 26 LVecBase4d::length_squared 0 1 908 69
/**
 * Returns the square of the vector's length, cheap and easy.
 */
53
inline double LVecBase4d::length_squared(void) const;

2722 6 length 0 4 3495 18 LVecBase4d::length 0 1 909 72
/**
 * Returns the length of the vector, by the Pythagorean theorem.
 */
45
inline double LVecBase4d::length(void) const;

2723 9 normalize 0 4 3495 21 LVecBase4d::normalize 0 1 910 127
/**
 * Normalizes the vector in place.  Returns true if the vector was normalized,
 * false if it was a zero-length vector.
 */
40
inline bool LVecBase4d::normalize(void);

2724 10 normalized 0 4 3495 22 LVecBase4d::normalized 0 1 911 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
53
inline LVecBase4d LVecBase4d::normalized(void) const;

2725 7 project 0 4 3495 19 LVecBase4d::project 0 1 912 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
68
inline LVecBase4d LVecBase4d::project(LVecBase4d const &onto) const;

2726 10 operator < 0 4 3495 22 LVecBase4d::operator < 0 1 913 0
66
inline bool LVecBase4d::operator <(LVecBase4d const &other) const;

2727 11 operator == 0 4 3495 23 LVecBase4d::operator == 0 1 914 0
67
inline bool LVecBase4d::operator ==(LVecBase4d const &other) const;

2728 11 operator != 0 4 3495 23 LVecBase4d::operator != 0 1 915 0
67
inline bool LVecBase4d::operator !=(LVecBase4d const &other) const;

2729 10 compare_to 0 4 3495 22 LVecBase4d::compare_to 0 2 916 917 332
/**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */

/**
 * Sorts vectors lexicographically, componentwise.  Returns a number less than
 * 0 if this vector sorts before the other one, greater than zero if it sorts
 * after, 0 if they are equivalent (within the indicated tolerance).
 */
149
inline int LVecBase4d::compare_to(LVecBase4d const &other) const;
inline int LVecBase4d::compare_to(LVecBase4d const &other, double threshold) const;

2730 8 get_hash 0 4 3495 20 LVecBase4d::get_hash 0 2 918 919 100
/**
 * Returns a suitable hash for phash_map.
 */

/**
 * Returns a suitable hash for phash_map.
 */
117
inline std::size_t LVecBase4d::get_hash(void) const;
inline std::size_t LVecBase4d::get_hash(double threshold) const;

2731 8 add_hash 0 4 3495 20 LVecBase4d::add_hash 0 2 920 921 100
/**
 * Adds the vector into the running hash.
 */

/**
 * Adds the vector into the running hash.
 */
147
inline std::size_t LVecBase4d::add_hash(std::size_t hash) const;
inline std::size_t LVecBase4d::add_hash(std::size_t hash, double threshold) const;

2732 13 generate_hash 0 4 3495 25 LVecBase4d::generate_hash 0 2 922 923 120
/**
 * Adds the vector to the indicated hash generator.
 */

/**
 * Adds the vector to the indicated hash generator.
 */
171
inline void LVecBase4d::generate_hash(ChecksumHashGenerator &hashgen) const;
inline void LVecBase4d::generate_hash(ChecksumHashGenerator &hashgen, double threshold) const;

2733 10 operator - 0 68 3495 22 LVecBase4d::operator - 0 1 924 0
53
inline LVecBase4d LVecBase4d::operator -(void) const;

2734 10 operator + 0 4 3495 22 LVecBase4d::operator + 0 1 925 0
72
inline LVecBase4d LVecBase4d::operator +(LVecBase4d const &other) const;

2735 10 operator - 0 4 3495 22 LVecBase4d::operator - 0 1 926 0
72
inline LVecBase4d LVecBase4d::operator -(LVecBase4d const &other) const;

2736 10 operator * 0 4 3495 22 LVecBase4d::operator * 0 1 927 0
62
inline LVecBase4d LVecBase4d::operator *(double scalar) const;

2737 10 operator / 0 4 3495 22 LVecBase4d::operator / 0 1 928 0
62
inline LVecBase4d LVecBase4d::operator /(double scalar) const;

2738 11 operator += 0 4 3495 23 LVecBase4d::operator += 0 1 929 0
61
inline void LVecBase4d::operator +=(LVecBase4d const &other);

2739 11 operator -= 0 4 3495 23 LVecBase4d::operator -= 0 1 930 0
61
inline void LVecBase4d::operator -=(LVecBase4d const &other);

2740 11 operator *= 0 4 3495 23 LVecBase4d::operator *= 0 1 931 0
51
inline void LVecBase4d::operator *=(double scalar);

2741 11 operator /= 0 4 3495 23 LVecBase4d::operator /= 0 1 932 0
51
inline void LVecBase4d::operator /=(double scalar);

2742 18 componentwise_mult 0 4 3495 30 LVecBase4d::componentwise_mult 0 1 933 10
/**
 *
 */
68
inline void LVecBase4d::componentwise_mult(LVecBase4d const &other);

2743 7 __pow__ 0 4 3495 19 LVecBase4d::__pow__ 0 1 934 0
61
inline LVecBase4d LVecBase4d::__pow__(double exponent) const;

2744 8 __ipow__ 0 4 3495 20 LVecBase4d::__ipow__ 0 1 935 0
71
inline PyObject *LVecBase4d::__ipow__(PyObject *self, double exponent);

2745 4 fmax 0 4 3495 16 LVecBase4d::fmax 0 1 936 10
/**
 *
 */
66
inline LVecBase4d LVecBase4d::fmax(LVecBase4d const &other) const;

2746 4 fmin 0 4 3495 16 LVecBase4d::fmin 0 1 937 10
/**
 *
 */
66
inline LVecBase4d LVecBase4d::fmin(LVecBase4d const &other) const;

2747 12 almost_equal 0 4 3495 24 LVecBase4d::almost_equal 0 2 938 939 210
/**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */

/**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */
155
inline bool LVecBase4d::almost_equal(LVecBase4d const &other, double threshold) const;
inline bool LVecBase4d::almost_equal(LVecBase4d const &other) const;

2748 6 output 0 4 3495 18 LVecBase4d::output 0 1 940 10
/**
 *
 */
51
inline void LVecBase4d::output(ostream &out) const;

2749 8 __repr__ 0 4 3495 20 LVecBase4d::__repr__ 0 1 941 0
52
inline std::string LVecBase4d::__repr__(void) const;

2750 20 write_datagram_fixed 0 4 3495 32 LVecBase4d::write_datagram_fixed 0 1 942 332
/**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */
74
inline void LVecBase4d::write_datagram_fixed(Datagram &destination) const;

2751 19 read_datagram_fixed 0 4 3495 31 LVecBase4d::read_datagram_fixed 0 1 943 114
/**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */
70
inline void LVecBase4d::read_datagram_fixed(DatagramIterator &source);

2752 14 write_datagram 0 4 3495 26 LVecBase4d::write_datagram 0 1 944 205
/**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */
68
inline void LVecBase4d::write_datagram(Datagram &destination) const;

2753 13 read_datagram 0 4 3495 25 LVecBase4d::read_datagram 0 1 945 67
/**
 * Reads the vector from the Datagram using get_stdfloat().
 */
64
inline void LVecBase4d::read_datagram(DatagramIterator &source);

2754 14 get_class_type 0 4 3495 26 LVecBase4d::get_class_type 0 1 946 0
51
static TypeHandle LVecBase4d::get_class_type(void);

2755 11 ~LVecBase4d 0 4 3495 23 LVecBase4d::~LVecBase4d 0 0 0
30
LVecBase4d::~LVecBase4d(void);

2756 19 UnalignedLVecBase4d 0 4 3497 40 UnalignedLVecBase4d::UnalignedLVecBase4d 0 4 947 948 949 950 22
/**
 *
 */

/**
 *
 */
314
inline UnalignedLVecBase4d::UnalignedLVecBase4d(void) = default;
inline UnalignedLVecBase4d::UnalignedLVecBase4d(LVecBase4d const &copy);
inline UnalignedLVecBase4d::UnalignedLVecBase4d(double x, double y, double z, double w);
inline UnalignedLVecBase4d::UnalignedLVecBase4d(UnalignedLVecBase4d const &) = default;

2757 3 set 0 4 3497 24 UnalignedLVecBase4d::set 0 1 951 10
/**
 *
 */
77
inline void UnalignedLVecBase4d::set(double x, double y, double z, double w);

2758 11 operator [] 0 4 3497 32 UnalignedLVecBase4d::operator [] 0 2 952 953 10
/**
 *
 */
116
inline double UnalignedLVecBase4d::operator [](int i) const;
inline double &UnalignedLVecBase4d::operator [](int i);

2759 4 size 0 4 3497 25 UnalignedLVecBase4d::size 0 1 954 0
53
static constexpr int UnalignedLVecBase4d::size(void);

2760 8 get_data 0 4 3497 29 UnalignedLVecBase4d::get_data 0 1 955 162
/**
 * Returns the address of the first of the three data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */
63
inline double const *UnalignedLVecBase4d::get_data(void) const;

2761 18 get_num_components 0 4 3497 39 UnalignedLVecBase4d::get_num_components 0 1 956 0
67
static constexpr int UnalignedLVecBase4d::get_num_components(void);

2762 14 get_class_type 0 4 3497 35 UnalignedLVecBase4d::get_class_type 0 1 957 0
60
static TypeHandle UnalignedLVecBase4d::get_class_type(void);

2763 20 ~UnalignedLVecBase4d 0 4 3497 41 UnalignedLVecBase4d::~UnalignedLVecBase4d 0 0 0
48
UnalignedLVecBase4d::~UnalignedLVecBase4d(void);

2764 10 LVecBase4i 0 4 3499 22 LVecBase4i::LVecBase4i 0 8 958 959 960 961 962 963 964 965 219
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 * Constructs an LVecBase4 from an LPoint3.  The w coordinate is set to 1.0.
 */

/**
 * Constructs an LVecBase4 from an LVector3.  The w coordinate is set to 0.0.
 */
449
inline LVecBase4i::LVecBase4i(void) = default;
inline LVecBase4i::LVecBase4i(int fill_value);
inline LVecBase4i::LVecBase4i(int x, int y, int z, int w);
inline LVecBase4i::LVecBase4i(UnalignedLVecBase4i const &copy);
inline LVecBase4i::LVecBase4i(LVecBase3i const &copy, int w);
inline LVecBase4i::LVecBase4i(LPoint3i const &point);
inline LVecBase4i::LVecBase4i(LVector3i const &vector);
inline LVecBase4i::LVecBase4i(LVecBase4i const &) = default;

2765 12 operator new 0 4 3499 24 LVecBase4i::operator new 0 1 966 0
124
inline void *LVecBase4i::operator new(std::size_t size);
inline void *LVecBase4i::operator new(std::size_t size, void *ptr);

2766 15 operator delete 0 4 3499 27 LVecBase4i::operator delete 0 0 0
108
inline void LVecBase4i::operator delete(void *ptr);
inline void LVecBase4i::operator delete(void *, void *);

2767 12 validate_ptr 0 4 3499 24 LVecBase4i::validate_ptr 0 0 0
61
static inline bool LVecBase4i::validate_ptr(void const *ptr);

2768 10 operator = 0 4 3499 22 LVecBase4i::operator = 0 2 967 968 0
131
LVecBase4i &LVecBase4i::operator =(LVecBase4i const &copy) = default;
LVecBase4i &LVecBase4i::operator =(int fill_value) = default;

2769 4 zero 0 4 3499 16 LVecBase4i::zero 0 1 969 40
/**
 * Returns a zero-length vector.
 */
55
static inline LVecBase4i const &LVecBase4i::zero(void);

2770 6 unit_x 0 4 3499 18 LVecBase4i::unit_x 0 1 970 35
/**
 * Returns a unit X vector.
 */
57
static inline LVecBase4i const &LVecBase4i::unit_x(void);

2771 6 unit_y 0 4 3499 18 LVecBase4i::unit_y 0 1 971 35
/**
 * Returns a unit Y vector.
 */
57
static inline LVecBase4i const &LVecBase4i::unit_y(void);

2772 6 unit_z 0 4 3499 18 LVecBase4i::unit_z 0 1 972 35
/**
 * Returns a unit Z vector.
 */
57
static inline LVecBase4i const &LVecBase4i::unit_z(void);

2773 6 unit_w 0 4 3499 18 LVecBase4i::unit_w 0 1 973 35
/**
 * Returns a unit W vector.
 */
57
static inline LVecBase4i const &LVecBase4i::unit_w(void);

2774 10 __reduce__ 0 4 3499 22 LVecBase4i::__reduce__ 0 1 974 0
62
inline PyObject *LVecBase4i::__reduce__(PyObject *self) const;

2775 11 __getattr__ 0 4 3499 23 LVecBase4i::__getattr__ 0 1 975 0
93
inline PyObject *LVecBase4i::__getattr__(PyObject *self, std::string const &attr_name) const;

2776 11 __setattr__ 0 4 3499 23 LVecBase4i::__setattr__ 0 1 976 0
99
inline int LVecBase4i::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2777 11 operator [] 0 4 3499 23 LVecBase4i::operator [] 0 2 977 978 10
/**
 *
 */
92
inline int LVecBase4i::operator [](int i) const;
inline int &LVecBase4i::operator [](int i);

2778 4 size 0 4 3499 16 LVecBase4i::size 0 1 979 0
44
static constexpr int LVecBase4i::size(void);

2779 6 is_nan 0 4 3499 18 LVecBase4i::is_nan 0 1 980 91
/**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */
43
inline bool LVecBase4i::is_nan(void) const;

2780 8 get_cell 0 4 3499 20 LVecBase4i::get_cell 0 1 981 10
/**
 *
 */
45
inline int LVecBase4i::get_cell(int i) const;

2781 8 set_cell 0 4 3499 20 LVecBase4i::set_cell 0 1 982 10
/**
 *
 */
51
inline void LVecBase4i::set_cell(int i, int value);

2782 5 get_x 0 4 3499 17 LVecBase4i::get_x 0 1 983 10
/**
 *
 */
41
inline int LVecBase4i::get_x(void) const;

2783 5 get_y 0 4 3499 17 LVecBase4i::get_y 0 1 984 10
/**
 *
 */
41
inline int LVecBase4i::get_y(void) const;

2784 5 get_z 0 4 3499 17 LVecBase4i::get_z 0 1 985 10
/**
 *
 */
41
inline int LVecBase4i::get_z(void) const;

2785 5 get_w 0 4 3499 17 LVecBase4i::get_w 0 1 986 10
/**
 *
 */
41
inline int LVecBase4i::get_w(void) const;

2786 7 get_xyz 0 4 3499 19 LVecBase4i::get_xyz 0 1 987 58
/**
 * Returns the x, y and z component of this vector
 */
50
inline LVecBase3i LVecBase4i::get_xyz(void) const;

2787 6 get_xy 0 4 3499 18 LVecBase4i::get_xy 0 1 988 55
/**
 * Returns the x and y component of this vector
 */
49
inline LVecBase2i LVecBase4i::get_xy(void) const;

2788 5 set_x 0 4 3499 17 LVecBase4i::set_x 0 1 989 10
/**
 *
 */
41
inline void LVecBase4i::set_x(int value);

2789 5 set_y 0 4 3499 17 LVecBase4i::set_y 0 1 990 10
/**
 *
 */
41
inline void LVecBase4i::set_y(int value);

2790 5 set_z 0 4 3499 17 LVecBase4i::set_z 0 1 991 10
/**
 *
 */
41
inline void LVecBase4i::set_z(int value);

2791 5 set_w 0 4 3499 17 LVecBase4i::set_w 0 1 992 10
/**
 *
 */
41
inline void LVecBase4i::set_w(int value);

2792 11 add_to_cell 0 4 3499 23 LVecBase4i::add_to_cell 0 1 993 164
// These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages:

/**
 *
 */
54
inline void LVecBase4i::add_to_cell(int i, int value);

2793 5 add_x 0 4 3499 17 LVecBase4i::add_x 0 1 994 10
/**
 *
 */
41
inline void LVecBase4i::add_x(int value);

2794 5 add_y 0 4 3499 17 LVecBase4i::add_y 0 1 995 10
/**
 *
 */
41
inline void LVecBase4i::add_y(int value);

2795 5 add_z 0 4 3499 17 LVecBase4i::add_z 0 1 996 10
/**
 *
 */
41
inline void LVecBase4i::add_z(int value);

2796 5 add_w 0 4 3499 17 LVecBase4i::add_w 0 1 997 10
/**
 *
 */
41
inline void LVecBase4i::add_w(int value);

2797 8 get_data 0 4 3499 20 LVecBase4i::get_data 0 1 998 161
/**
 * Returns the address of the first of the four data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */
51
inline int const *LVecBase4i::get_data(void) const;

2798 18 get_num_components 0 4 3499 30 LVecBase4i::get_num_components 0 1 999 0
58
static constexpr int LVecBase4i::get_num_components(void);

2799 12 extract_data 0 4 3499 24 LVecBase4i::extract_data 0 0 0
46
inline void LVecBase4i::extract_data(float *);

2800 4 fill 0 4 3499 16 LVecBase4i::fill 0 1 1000 129
/**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */
45
inline void LVecBase4i::fill(int fill_value);

2801 3 set 0 4 3499 15 LVecBase4i::set 0 1 1001 10
/**
 *
 */
56
inline void LVecBase4i::set(int x, int y, int z, int w);

2802 3 dot 0 4 3499 15 LVecBase4i::dot 0 1 1002 10
/**
 *
 */
58
inline int LVecBase4i::dot(LVecBase4i const &other) const;

2803 14 length_squared 0 4 3499 26 LVecBase4i::length_squared 0 1 1003 69
/**
 * Returns the square of the vector's length, cheap and easy.
 */
50
inline int LVecBase4i::length_squared(void) const;

2804 10 operator < 0 4 3499 22 LVecBase4i::operator < 0 1 1004 0
66
inline bool LVecBase4i::operator <(LVecBase4i const &other) const;

2805 11 operator == 0 4 3499 23 LVecBase4i::operator == 0 1 1005 0
67
inline bool LVecBase4i::operator ==(LVecBase4i const &other) const;

2806 11 operator != 0 4 3499 23 LVecBase4i::operator != 0 1 1006 0
67
inline bool LVecBase4i::operator !=(LVecBase4i const &other) const;

2807 10 compare_to 0 4 3499 22 LVecBase4i::compare_to 0 1 1007 97
/**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */
65
inline int LVecBase4i::compare_to(LVecBase4i const &other) const;

2808 8 get_hash 0 4 3499 20 LVecBase4i::get_hash 0 1 1008 49
/**
 * Returns a suitable hash for phash_map.
 */
52
inline std::size_t LVecBase4i::get_hash(void) const;

2809 8 add_hash 0 4 3499 20 LVecBase4i::add_hash 0 1 1009 49
/**
 * Adds the vector into the running hash.
 */
64
inline std::size_t LVecBase4i::add_hash(std::size_t hash) const;

2810 13 generate_hash 0 4 3499 25 LVecBase4i::generate_hash 0 1 1010 59
/**
 * Adds the vector to the indicated hash generator.
 */
76
inline void LVecBase4i::generate_hash(ChecksumHashGenerator &hashgen) const;

2811 10 operator - 0 68 3499 22 LVecBase4i::operator - 0 1 1011 0
53
inline LVecBase4i LVecBase4i::operator -(void) const;

2812 10 operator + 0 4 3499 22 LVecBase4i::operator + 0 1 1012 0
72
inline LVecBase4i LVecBase4i::operator +(LVecBase4i const &other) const;

2813 10 operator - 0 4 3499 22 LVecBase4i::operator - 0 1 1013 0
72
inline LVecBase4i LVecBase4i::operator -(LVecBase4i const &other) const;

2814 10 operator * 0 4 3499 22 LVecBase4i::operator * 0 1 1014 0
59
inline LVecBase4i LVecBase4i::operator *(int scalar) const;

2815 10 operator / 0 4 3499 22 LVecBase4i::operator / 0 1 1015 0
59
inline LVecBase4i LVecBase4i::operator /(int scalar) const;

2816 11 operator += 0 4 3499 23 LVecBase4i::operator += 0 1 1016 0
61
inline void LVecBase4i::operator +=(LVecBase4i const &other);

2817 11 operator -= 0 4 3499 23 LVecBase4i::operator -= 0 1 1017 0
61
inline void LVecBase4i::operator -=(LVecBase4i const &other);

2818 11 operator *= 0 4 3499 23 LVecBase4i::operator *= 0 1 1018 0
48
inline void LVecBase4i::operator *=(int scalar);

2819 11 operator /= 0 4 3499 23 LVecBase4i::operator /= 0 1 1019 0
48
inline void LVecBase4i::operator /=(int scalar);

2820 18 componentwise_mult 0 4 3499 30 LVecBase4i::componentwise_mult 0 1 1020 10
/**
 *
 */
68
inline void LVecBase4i::componentwise_mult(LVecBase4i const &other);

2821 7 __pow__ 0 4 3499 19 LVecBase4i::__pow__ 0 1 1021 0
58
inline LVecBase4i LVecBase4i::__pow__(int exponent) const;

2822 8 __ipow__ 0 4 3499 20 LVecBase4i::__ipow__ 0 1 1022 0
68
inline PyObject *LVecBase4i::__ipow__(PyObject *self, int exponent);

2823 4 fmax 0 4 3499 16 LVecBase4i::fmax 0 1 1023 10
/**
 *
 */
66
inline LVecBase4i LVecBase4i::fmax(LVecBase4i const &other) const;

2824 4 fmin 0 4 3499 16 LVecBase4i::fmin 0 1 1024 10
/**
 *
 */
66
inline LVecBase4i LVecBase4i::fmin(LVecBase4i const &other) const;

2825 12 almost_equal 0 4 3499 24 LVecBase4i::almost_equal 0 2 1025 1026 210
/**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */

/**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */
152
inline bool LVecBase4i::almost_equal(LVecBase4i const &other, int threshold) const;
inline bool LVecBase4i::almost_equal(LVecBase4i const &other) const;

2826 6 output 0 4 3499 18 LVecBase4i::output 0 1 1027 10
/**
 *
 */
51
inline void LVecBase4i::output(ostream &out) const;

2827 8 __repr__ 0 4 3499 20 LVecBase4i::__repr__ 0 1 1028 0
52
inline std::string LVecBase4i::__repr__(void) const;

2828 20 write_datagram_fixed 0 4 3499 32 LVecBase4i::write_datagram_fixed 0 1 1029 332
/**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */
74
inline void LVecBase4i::write_datagram_fixed(Datagram &destination) const;

2829 19 read_datagram_fixed 0 4 3499 31 LVecBase4i::read_datagram_fixed 0 1 1030 114
/**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */
70
inline void LVecBase4i::read_datagram_fixed(DatagramIterator &source);

2830 14 write_datagram 0 4 3499 26 LVecBase4i::write_datagram 0 1 1031 205
/**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */
68
inline void LVecBase4i::write_datagram(Datagram &destination) const;

2831 13 read_datagram 0 4 3499 25 LVecBase4i::read_datagram 0 1 1032 67
/**
 * Reads the vector from the Datagram using get_stdfloat().
 */
64
inline void LVecBase4i::read_datagram(DatagramIterator &source);

2832 14 get_class_type 0 4 3499 26 LVecBase4i::get_class_type 0 1 1033 0
51
static TypeHandle LVecBase4i::get_class_type(void);

2833 11 ~LVecBase4i 0 4 3499 23 LVecBase4i::~LVecBase4i 0 0 0
30
LVecBase4i::~LVecBase4i(void);

2834 19 UnalignedLVecBase4i 0 4 3501 40 UnalignedLVecBase4i::UnalignedLVecBase4i 0 4 1034 1035 1036 1037 22
/**
 *
 */

/**
 *
 */
302
inline UnalignedLVecBase4i::UnalignedLVecBase4i(void) = default;
inline UnalignedLVecBase4i::UnalignedLVecBase4i(LVecBase4i const &copy);
inline UnalignedLVecBase4i::UnalignedLVecBase4i(int x, int y, int z, int w);
inline UnalignedLVecBase4i::UnalignedLVecBase4i(UnalignedLVecBase4i const &) = default;

2835 3 set 0 4 3501 24 UnalignedLVecBase4i::set 0 1 1038 10
/**
 *
 */
65
inline void UnalignedLVecBase4i::set(int x, int y, int z, int w);

2836 11 operator [] 0 4 3501 32 UnalignedLVecBase4i::operator [] 0 2 1039 1040 10
/**
 *
 */
110
inline int UnalignedLVecBase4i::operator [](int i) const;
inline int &UnalignedLVecBase4i::operator [](int i);

2837 4 size 0 4 3501 25 UnalignedLVecBase4i::size 0 1 1041 0
53
static constexpr int UnalignedLVecBase4i::size(void);

2838 8 get_data 0 4 3501 29 UnalignedLVecBase4i::get_data 0 1 1042 162
/**
 * Returns the address of the first of the three data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */
60
inline int const *UnalignedLVecBase4i::get_data(void) const;

2839 18 get_num_components 0 4 3501 39 UnalignedLVecBase4i::get_num_components 0 1 1043 0
67
static constexpr int UnalignedLVecBase4i::get_num_components(void);

2840 14 get_class_type 0 4 3501 35 UnalignedLVecBase4i::get_class_type 0 1 1044 0
60
static TypeHandle UnalignedLVecBase4i::get_class_type(void);

2841 20 ~UnalignedLVecBase4i 0 4 3501 41 UnalignedLVecBase4i::~UnalignedLVecBase4i 0 0 0
48
UnalignedLVecBase4i::~UnalignedLVecBase4i(void);

2842 9 LVector4f 0 4 3503 20 LVector4f::LVector4f 0 6 1045 1046 1047 1048 1049 1050 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
329
inline LVector4f::LVector4f(void) = default;
inline LVector4f::LVector4f(LVecBase4f const &copy);
inline LVector4f::LVector4f(float fill_value);
inline LVector4f::LVector4f(float x, float y, float z, float w);
inline LVector4f::LVector4f(LVecBase3f const &copy, float w);
inline LVector4f::LVector4f(LVector4f const &) = default;

2843 11 __getattr__ 0 4 3503 22 LVector4f::__getattr__ 0 1 1051 0
92
inline PyObject *LVector4f::__getattr__(PyObject *self, std::string const &attr_name) const;

2844 11 __setattr__ 0 4 3503 22 LVector4f::__setattr__ 0 1 1052 0
98
inline int LVector4f::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2845 4 zero 0 4 3503 15 LVector4f::zero 0 1 1053 40
/**
 * Returns a zero-length vector.
 */
53
static inline LVector4f const &LVector4f::zero(void);

2846 6 unit_x 0 4 3503 17 LVector4f::unit_x 0 1 1054 35
/**
 * Returns a unit X vector.
 */
55
static inline LVector4f const &LVector4f::unit_x(void);

2847 6 unit_y 0 4 3503 17 LVector4f::unit_y 0 1 1055 35
/**
 * Returns a unit Y vector.
 */
55
static inline LVector4f const &LVector4f::unit_y(void);

2848 6 unit_z 0 4 3503 17 LVector4f::unit_z 0 1 1056 35
/**
 * Returns a unit Z vector.
 */
55
static inline LVector4f const &LVector4f::unit_z(void);

2849 6 unit_w 0 4 3503 17 LVector4f::unit_w 0 1 1057 35
/**
 * Returns a unit W vector.
 */
55
static inline LVector4f const &LVector4f::unit_w(void);

2850 7 get_xyz 0 4 3503 18 LVector4f::get_xyz 0 1 1058 58
/**
 * Returns the x, y and z component of this vector
 */
48
inline LVector3f LVector4f::get_xyz(void) const;

2851 6 get_xy 0 4 3503 17 LVector4f::get_xy 0 1 1059 55
/**
 * Returns the x and y component of this vector
 */
47
inline LVector2f LVector4f::get_xy(void) const;

2852 10 operator - 0 68 3503 21 LVector4f::operator - 0 1 1060 0
51
inline LVector4f LVector4f::operator -(void) const;

2853 10 operator + 0 4 3503 21 LVector4f::operator + 0 2 1061 1062 0
141
inline LVecBase4f LVector4f::operator +(LVecBase4f const &other) const;
inline LVector4f LVector4f::operator +(LVector4f const &other) const;

2854 10 operator - 0 4 3503 21 LVector4f::operator - 0 2 1063 1064 0
141
inline LVecBase4f LVector4f::operator -(LVecBase4f const &other) const;
inline LVector4f LVector4f::operator -(LVector4f const &other) const;

2855 10 operator * 0 4 3503 21 LVector4f::operator * 0 1 1065 0
59
inline LVector4f LVector4f::operator *(float scalar) const;

2856 10 operator / 0 4 3503 21 LVector4f::operator / 0 1 1066 0
59
inline LVector4f LVector4f::operator /(float scalar) const;

2857 10 normalized 0 4 3503 21 LVector4f::normalized 0 1 1067 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
51
inline LVector4f LVector4f::normalized(void) const;

2858 7 project 0 4 3503 18 LVector4f::project 0 1 1068 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
66
inline LVector4f LVector4f::project(LVecBase4f const &onto) const;

2859 8 __repr__ 0 4 3503 19 LVector4f::__repr__ 0 1 1069 0
51
inline std::string LVector4f::__repr__(void) const;

2860 14 get_class_type 0 4 3503 25 LVector4f::get_class_type 0 1 1070 0
50
static TypeHandle LVector4f::get_class_type(void);

2861 10 ~LVector4f 0 4 3503 21 LVector4f::~LVector4f 0 0 0
28
LVector4f::~LVector4f(void);

2862 9 LVector4d 0 4 3504 20 LVector4d::LVector4d 0 6 1071 1072 1073 1074 1075 1076 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
335
inline LVector4d::LVector4d(void) = default;
inline LVector4d::LVector4d(LVecBase4d const &copy);
inline LVector4d::LVector4d(double fill_value);
inline LVector4d::LVector4d(double x, double y, double z, double w);
inline LVector4d::LVector4d(LVecBase3d const &copy, double w);
inline LVector4d::LVector4d(LVector4d const &) = default;

2863 11 __getattr__ 0 4 3504 22 LVector4d::__getattr__ 0 1 1077 0
92
inline PyObject *LVector4d::__getattr__(PyObject *self, std::string const &attr_name) const;

2864 11 __setattr__ 0 4 3504 22 LVector4d::__setattr__ 0 1 1078 0
98
inline int LVector4d::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2865 4 zero 0 4 3504 15 LVector4d::zero 0 1 1079 40
/**
 * Returns a zero-length vector.
 */
53
static inline LVector4d const &LVector4d::zero(void);

2866 6 unit_x 0 4 3504 17 LVector4d::unit_x 0 1 1080 35
/**
 * Returns a unit X vector.
 */
55
static inline LVector4d const &LVector4d::unit_x(void);

2867 6 unit_y 0 4 3504 17 LVector4d::unit_y 0 1 1081 35
/**
 * Returns a unit Y vector.
 */
55
static inline LVector4d const &LVector4d::unit_y(void);

2868 6 unit_z 0 4 3504 17 LVector4d::unit_z 0 1 1082 35
/**
 * Returns a unit Z vector.
 */
55
static inline LVector4d const &LVector4d::unit_z(void);

2869 6 unit_w 0 4 3504 17 LVector4d::unit_w 0 1 1083 35
/**
 * Returns a unit W vector.
 */
55
static inline LVector4d const &LVector4d::unit_w(void);

2870 7 get_xyz 0 4 3504 18 LVector4d::get_xyz 0 1 1084 58
/**
 * Returns the x, y and z component of this vector
 */
48
inline LVector3d LVector4d::get_xyz(void) const;

2871 6 get_xy 0 4 3504 17 LVector4d::get_xy 0 1 1085 55
/**
 * Returns the x and y component of this vector
 */
47
inline LVector2d LVector4d::get_xy(void) const;

2872 10 operator - 0 68 3504 21 LVector4d::operator - 0 1 1086 0
51
inline LVector4d LVector4d::operator -(void) const;

2873 10 operator + 0 4 3504 21 LVector4d::operator + 0 2 1087 1088 0
141
inline LVecBase4d LVector4d::operator +(LVecBase4d const &other) const;
inline LVector4d LVector4d::operator +(LVector4d const &other) const;

2874 10 operator - 0 4 3504 21 LVector4d::operator - 0 2 1089 1090 0
141
inline LVecBase4d LVector4d::operator -(LVecBase4d const &other) const;
inline LVector4d LVector4d::operator -(LVector4d const &other) const;

2875 10 operator * 0 4 3504 21 LVector4d::operator * 0 1 1091 0
60
inline LVector4d LVector4d::operator *(double scalar) const;

2876 10 operator / 0 4 3504 21 LVector4d::operator / 0 1 1092 0
60
inline LVector4d LVector4d::operator /(double scalar) const;

2877 10 normalized 0 4 3504 21 LVector4d::normalized 0 1 1093 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
51
inline LVector4d LVector4d::normalized(void) const;

2878 7 project 0 4 3504 18 LVector4d::project 0 1 1094 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
66
inline LVector4d LVector4d::project(LVecBase4d const &onto) const;

2879 8 __repr__ 0 4 3504 19 LVector4d::__repr__ 0 1 1095 0
51
inline std::string LVector4d::__repr__(void) const;

2880 14 get_class_type 0 4 3504 25 LVector4d::get_class_type 0 1 1096 0
50
static TypeHandle LVector4d::get_class_type(void);

2881 10 ~LVector4d 0 4 3504 21 LVector4d::~LVector4d 0 0 0
28
LVector4d::~LVector4d(void);

2882 9 LVector4i 0 4 3505 20 LVector4i::LVector4i 0 6 1097 1098 1099 1100 1101 1102 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
317
inline LVector4i::LVector4i(void) = default;
inline LVector4i::LVector4i(LVecBase4i const &copy);
inline LVector4i::LVector4i(int fill_value);
inline LVector4i::LVector4i(int x, int y, int z, int w);
inline LVector4i::LVector4i(LVecBase3i const &copy, int w);
inline LVector4i::LVector4i(LVector4i const &) = default;

2883 11 __getattr__ 0 4 3505 22 LVector4i::__getattr__ 0 1 1103 0
92
inline PyObject *LVector4i::__getattr__(PyObject *self, std::string const &attr_name) const;

2884 11 __setattr__ 0 4 3505 22 LVector4i::__setattr__ 0 1 1104 0
98
inline int LVector4i::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2885 4 zero 0 4 3505 15 LVector4i::zero 0 1 1105 40
/**
 * Returns a zero-length vector.
 */
53
static inline LVector4i const &LVector4i::zero(void);

2886 6 unit_x 0 4 3505 17 LVector4i::unit_x 0 1 1106 35
/**
 * Returns a unit X vector.
 */
55
static inline LVector4i const &LVector4i::unit_x(void);

2887 6 unit_y 0 4 3505 17 LVector4i::unit_y 0 1 1107 35
/**
 * Returns a unit Y vector.
 */
55
static inline LVector4i const &LVector4i::unit_y(void);

2888 6 unit_z 0 4 3505 17 LVector4i::unit_z 0 1 1108 35
/**
 * Returns a unit Z vector.
 */
55
static inline LVector4i const &LVector4i::unit_z(void);

2889 6 unit_w 0 4 3505 17 LVector4i::unit_w 0 1 1109 35
/**
 * Returns a unit W vector.
 */
55
static inline LVector4i const &LVector4i::unit_w(void);

2890 7 get_xyz 0 4 3505 18 LVector4i::get_xyz 0 1 1110 58
/**
 * Returns the x, y and z component of this vector
 */
48
inline LVector3i LVector4i::get_xyz(void) const;

2891 6 get_xy 0 4 3505 17 LVector4i::get_xy 0 1 1111 55
/**
 * Returns the x and y component of this vector
 */
47
inline LVector2i LVector4i::get_xy(void) const;

2892 10 operator - 0 68 3505 21 LVector4i::operator - 0 1 1112 0
51
inline LVector4i LVector4i::operator -(void) const;

2893 10 operator + 0 4 3505 21 LVector4i::operator + 0 2 1113 1114 0
141
inline LVecBase4i LVector4i::operator +(LVecBase4i const &other) const;
inline LVector4i LVector4i::operator +(LVector4i const &other) const;

2894 10 operator - 0 4 3505 21 LVector4i::operator - 0 2 1115 1116 0
141
inline LVecBase4i LVector4i::operator -(LVecBase4i const &other) const;
inline LVector4i LVector4i::operator -(LVector4i const &other) const;

2895 10 operator * 0 4 3505 21 LVector4i::operator * 0 1 1117 0
57
inline LVector4i LVector4i::operator *(int scalar) const;

2896 10 operator / 0 4 3505 21 LVector4i::operator / 0 1 1118 0
57
inline LVector4i LVector4i::operator /(int scalar) const;

2897 8 __repr__ 0 4 3505 19 LVector4i::__repr__ 0 1 1119 0
51
inline std::string LVector4i::__repr__(void) const;

2898 14 get_class_type 0 4 3505 25 LVector4i::get_class_type 0 1 1120 0
50
static TypeHandle LVector4i::get_class_type(void);

2899 10 ~LVector4i 0 4 3505 21 LVector4i::~LVector4i 0 0 0
28
LVector4i::~LVector4i(void);

2900 8 LPoint4f 0 4 3506 18 LPoint4f::LPoint4f 0 6 1121 1122 1123 1124 1125 1126 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
316
inline LPoint4f::LPoint4f(void) = default;
inline LPoint4f::LPoint4f(LVecBase4f const &copy);
inline LPoint4f::LPoint4f(float fill_value);
inline LPoint4f::LPoint4f(float x, float y, float z, float w);
inline LPoint4f::LPoint4f(LVecBase3f const &copy, float w);
inline LPoint4f::LPoint4f(LPoint4f const &) = default;

2901 11 __getattr__ 0 4 3506 21 LPoint4f::__getattr__ 0 1 1127 0
91
inline PyObject *LPoint4f::__getattr__(PyObject *self, std::string const &attr_name) const;

2902 11 __setattr__ 0 4 3506 21 LPoint4f::__setattr__ 0 1 1128 0
97
inline int LPoint4f::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2903 4 zero 0 4 3506 14 LPoint4f::zero 0 1 1129 39
/**
 * Returns a zero-length point.
 */
51
static inline LPoint4f const &LPoint4f::zero(void);

2904 6 unit_x 0 4 3506 16 LPoint4f::unit_x 0 1 1130 34
/**
 * Returns a unit X point.
 */
53
static inline LPoint4f const &LPoint4f::unit_x(void);

2905 6 unit_y 0 4 3506 16 LPoint4f::unit_y 0 1 1131 34
/**
 * Returns a unit Y point.
 */
53
static inline LPoint4f const &LPoint4f::unit_y(void);

2906 6 unit_z 0 4 3506 16 LPoint4f::unit_z 0 1 1132 34
/**
 * Returns a unit Z point.
 */
53
static inline LPoint4f const &LPoint4f::unit_z(void);

2907 6 unit_w 0 4 3506 16 LPoint4f::unit_w 0 1 1133 34
/**
 * Returns a unit W point.
 */
53
static inline LPoint4f const &LPoint4f::unit_w(void);

2908 7 get_xyz 0 4 3506 17 LPoint4f::get_xyz 0 1 1134 58
/**
 * Returns the x, y and z component of this vector
 */
46
inline LPoint3f LPoint4f::get_xyz(void) const;

2909 6 get_xy 0 4 3506 16 LPoint4f::get_xy 0 1 1135 55
/**
 * Returns the x and y component of this vector
 */
45
inline LPoint2f LPoint4f::get_xy(void) const;

2910 10 operator - 0 68 3506 20 LPoint4f::operator - 0 1 1136 0
49
inline LPoint4f LPoint4f::operator -(void) const;

2911 10 operator + 0 4 3506 20 LPoint4f::operator + 0 2 1137 1138 0
138
inline LVecBase4f LPoint4f::operator +(LVecBase4f const &other) const;
inline LPoint4f LPoint4f::operator +(LVector4f const &other) const;

2912 10 operator - 0 4 3506 20 LPoint4f::operator - 0 3 1139 1140 1141 0
206
inline LVecBase4f LPoint4f::operator -(LVecBase4f const &other) const;
inline LVector4f LPoint4f::operator -(LPoint4f const &other) const;
inline LPoint4f LPoint4f::operator -(LVector4f const &other) const;

2913 10 operator * 0 4 3506 20 LPoint4f::operator * 0 1 1142 0
57
inline LPoint4f LPoint4f::operator *(float scalar) const;

2914 10 operator / 0 4 3506 20 LPoint4f::operator / 0 1 1143 0
57
inline LPoint4f LPoint4f::operator /(float scalar) const;

2915 10 normalized 0 4 3506 20 LPoint4f::normalized 0 1 1144 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
49
inline LPoint4f LPoint4f::normalized(void) const;

2916 7 project 0 4 3506 17 LPoint4f::project 0 1 1145 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
64
inline LPoint4f LPoint4f::project(LVecBase4f const &onto) const;

2917 8 __repr__ 0 4 3506 18 LPoint4f::__repr__ 0 1 1146 0
50
inline std::string LPoint4f::__repr__(void) const;

2918 14 get_class_type 0 4 3506 24 LPoint4f::get_class_type 0 1 1147 0
49
static TypeHandle LPoint4f::get_class_type(void);

2919 9 ~LPoint4f 0 4 3506 19 LPoint4f::~LPoint4f 0 0 0
26
LPoint4f::~LPoint4f(void);

2920 8 LPoint4d 0 4 3507 18 LPoint4d::LPoint4d 0 6 1148 1149 1150 1151 1152 1153 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
322
inline LPoint4d::LPoint4d(void) = default;
inline LPoint4d::LPoint4d(LVecBase4d const &copy);
inline LPoint4d::LPoint4d(double fill_value);
inline LPoint4d::LPoint4d(double x, double y, double z, double w);
inline LPoint4d::LPoint4d(LVecBase3d const &copy, double w);
inline LPoint4d::LPoint4d(LPoint4d const &) = default;

2921 11 __getattr__ 0 4 3507 21 LPoint4d::__getattr__ 0 1 1154 0
91
inline PyObject *LPoint4d::__getattr__(PyObject *self, std::string const &attr_name) const;

2922 11 __setattr__ 0 4 3507 21 LPoint4d::__setattr__ 0 1 1155 0
97
inline int LPoint4d::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2923 4 zero 0 4 3507 14 LPoint4d::zero 0 1 1156 39
/**
 * Returns a zero-length point.
 */
51
static inline LPoint4d const &LPoint4d::zero(void);

2924 6 unit_x 0 4 3507 16 LPoint4d::unit_x 0 1 1157 34
/**
 * Returns a unit X point.
 */
53
static inline LPoint4d const &LPoint4d::unit_x(void);

2925 6 unit_y 0 4 3507 16 LPoint4d::unit_y 0 1 1158 34
/**
 * Returns a unit Y point.
 */
53
static inline LPoint4d const &LPoint4d::unit_y(void);

2926 6 unit_z 0 4 3507 16 LPoint4d::unit_z 0 1 1159 34
/**
 * Returns a unit Z point.
 */
53
static inline LPoint4d const &LPoint4d::unit_z(void);

2927 6 unit_w 0 4 3507 16 LPoint4d::unit_w 0 1 1160 34
/**
 * Returns a unit W point.
 */
53
static inline LPoint4d const &LPoint4d::unit_w(void);

2928 7 get_xyz 0 4 3507 17 LPoint4d::get_xyz 0 1 1161 58
/**
 * Returns the x, y and z component of this vector
 */
46
inline LPoint3d LPoint4d::get_xyz(void) const;

2929 6 get_xy 0 4 3507 16 LPoint4d::get_xy 0 1 1162 55
/**
 * Returns the x and y component of this vector
 */
45
inline LPoint2d LPoint4d::get_xy(void) const;

2930 10 operator - 0 68 3507 20 LPoint4d::operator - 0 1 1163 0
49
inline LPoint4d LPoint4d::operator -(void) const;

2931 10 operator + 0 4 3507 20 LPoint4d::operator + 0 2 1164 1165 0
138
inline LVecBase4d LPoint4d::operator +(LVecBase4d const &other) const;
inline LPoint4d LPoint4d::operator +(LVector4d const &other) const;

2932 10 operator - 0 4 3507 20 LPoint4d::operator - 0 3 1166 1167 1168 0
206
inline LVecBase4d LPoint4d::operator -(LVecBase4d const &other) const;
inline LVector4d LPoint4d::operator -(LPoint4d const &other) const;
inline LPoint4d LPoint4d::operator -(LVector4d const &other) const;

2933 10 operator * 0 4 3507 20 LPoint4d::operator * 0 1 1169 0
58
inline LPoint4d LPoint4d::operator *(double scalar) const;

2934 10 operator / 0 4 3507 20 LPoint4d::operator / 0 1 1170 0
58
inline LPoint4d LPoint4d::operator /(double scalar) const;

2935 10 normalized 0 4 3507 20 LPoint4d::normalized 0 1 1171 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
49
inline LPoint4d LPoint4d::normalized(void) const;

2936 7 project 0 4 3507 17 LPoint4d::project 0 1 1172 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
64
inline LPoint4d LPoint4d::project(LVecBase4d const &onto) const;

2937 8 __repr__ 0 4 3507 18 LPoint4d::__repr__ 0 1 1173 0
50
inline std::string LPoint4d::__repr__(void) const;

2938 14 get_class_type 0 4 3507 24 LPoint4d::get_class_type 0 1 1174 0
49
static TypeHandle LPoint4d::get_class_type(void);

2939 9 ~LPoint4d 0 4 3507 19 LPoint4d::~LPoint4d 0 0 0
26
LPoint4d::~LPoint4d(void);

2940 8 LPoint4i 0 4 3508 18 LPoint4i::LPoint4i 0 6 1175 1176 1177 1178 1179 1180 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
304
inline LPoint4i::LPoint4i(void) = default;
inline LPoint4i::LPoint4i(LVecBase4i const &copy);
inline LPoint4i::LPoint4i(int fill_value);
inline LPoint4i::LPoint4i(int x, int y, int z, int w);
inline LPoint4i::LPoint4i(LVecBase3i const &copy, int w);
inline LPoint4i::LPoint4i(LPoint4i const &) = default;

2941 11 __getattr__ 0 4 3508 21 LPoint4i::__getattr__ 0 1 1181 0
91
inline PyObject *LPoint4i::__getattr__(PyObject *self, std::string const &attr_name) const;

2942 11 __setattr__ 0 4 3508 21 LPoint4i::__setattr__ 0 1 1182 0
97
inline int LPoint4i::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2943 4 zero 0 4 3508 14 LPoint4i::zero 0 1 1183 39
/**
 * Returns a zero-length point.
 */
51
static inline LPoint4i const &LPoint4i::zero(void);

2944 6 unit_x 0 4 3508 16 LPoint4i::unit_x 0 1 1184 34
/**
 * Returns a unit X point.
 */
53
static inline LPoint4i const &LPoint4i::unit_x(void);

2945 6 unit_y 0 4 3508 16 LPoint4i::unit_y 0 1 1185 34
/**
 * Returns a unit Y point.
 */
53
static inline LPoint4i const &LPoint4i::unit_y(void);

2946 6 unit_z 0 4 3508 16 LPoint4i::unit_z 0 1 1186 34
/**
 * Returns a unit Z point.
 */
53
static inline LPoint4i const &LPoint4i::unit_z(void);

2947 6 unit_w 0 4 3508 16 LPoint4i::unit_w 0 1 1187 34
/**
 * Returns a unit W point.
 */
53
static inline LPoint4i const &LPoint4i::unit_w(void);

2948 7 get_xyz 0 4 3508 17 LPoint4i::get_xyz 0 1 1188 58
/**
 * Returns the x, y and z component of this vector
 */
46
inline LPoint3i LPoint4i::get_xyz(void) const;

2949 6 get_xy 0 4 3508 16 LPoint4i::get_xy 0 1 1189 55
/**
 * Returns the x and y component of this vector
 */
45
inline LPoint2i LPoint4i::get_xy(void) const;

2950 10 operator - 0 68 3508 20 LPoint4i::operator - 0 1 1190 0
49
inline LPoint4i LPoint4i::operator -(void) const;

2951 10 operator + 0 4 3508 20 LPoint4i::operator + 0 2 1191 1192 0
138
inline LVecBase4i LPoint4i::operator +(LVecBase4i const &other) const;
inline LPoint4i LPoint4i::operator +(LVector4i const &other) const;

2952 10 operator - 0 4 3508 20 LPoint4i::operator - 0 3 1193 1194 1195 0
206
inline LVecBase4i LPoint4i::operator -(LVecBase4i const &other) const;
inline LVector4i LPoint4i::operator -(LPoint4i const &other) const;
inline LPoint4i LPoint4i::operator -(LVector4i const &other) const;

2953 10 operator * 0 4 3508 20 LPoint4i::operator * 0 1 1196 0
55
inline LPoint4i LPoint4i::operator *(int scalar) const;

2954 10 operator / 0 4 3508 20 LPoint4i::operator / 0 1 1197 0
55
inline LPoint4i LPoint4i::operator /(int scalar) const;

2955 8 __repr__ 0 4 3508 18 LPoint4i::__repr__ 0 1 1198 0
50
inline std::string LPoint4i::__repr__(void) const;

2956 14 get_class_type 0 4 3508 24 LPoint4i::get_class_type 0 1 1199 0
49
static TypeHandle LPoint4i::get_class_type(void);

2957 9 ~LPoint4i 0 4 3508 19 LPoint4i::~LPoint4i 0 0 0
26
LPoint4i::~LPoint4i(void);

2958 11 operator [] 0 4 3511 27 LMatrix3f::Row::operator [] 0 2 1301 1302 10
/**
 *
 */
104
inline float LMatrix3f::Row::operator [](int i) const;
inline float &LMatrix3f::Row::operator [](int i);

2959 4 size 0 4 3511 20 LMatrix3f::Row::size 0 1 1303 58
/**
 * Returns 3: the number of columns of a LMatrix3.
 */
45
static inline int LMatrix3f::Row::size(void);

2960 3 Row 0 4 3511 19 LMatrix3f::Row::Row 0 1 1300 60
/**
 * Defines a row-level index accessor to the matrix.
 */
61
inline LMatrix3f::Row::Row(LMatrix3f::Row const &) = default;

2961 4 ~Row 0 4 3511 20 LMatrix3f::Row::~Row 0 0 0
27
LMatrix3f::Row::~Row(void);

2962 11 operator [] 0 4 3512 28 LMatrix3f::CRow::operator [] 0 1 1305 0
55
inline float LMatrix3f::CRow::operator [](int i) const;

2963 4 size 0 4 3512 21 LMatrix3f::CRow::size 0 1 1306 58
/**
 * Returns 3: the number of columns of a LMatrix3.
 */
46
static inline int LMatrix3f::CRow::size(void);

2964 4 CRow 0 4 3512 21 LMatrix3f::CRow::CRow 0 1 1304 63
/**
 * Defines a row-level constant accessor to the matrix.
 */
64
inline LMatrix3f::CRow::CRow(LMatrix3f::CRow const &) = default;

2965 5 ~CRow 0 4 3512 22 LMatrix3f::CRow::~CRow 0 0 0
29
LMatrix3f::CRow::~CRow(void);

2966 9 LMatrix3f 0 4 3509 20 LMatrix3f::LMatrix3f 0 3 1200 1201 1202 34
/**
 *
 */

/**
 *
 */

/**
 *
 */
215
inline LMatrix3f::LMatrix3f(void);
inline LMatrix3f::LMatrix3f(LMatrix3f const &other);
inline LMatrix3f::LMatrix3f(float e00, float e01, float e02, float e10, float e11, float e12, float e20, float e21, float e22);

2967 10 operator = 0 4 3509 21 LMatrix3f::operator = 0 2 1203 1204 22
/**
 *
 */

/**
 *
 */
123
inline LMatrix3f &LMatrix3f::operator =(LMatrix3f const &other);
inline LMatrix3f &LMatrix3f::operator =(float fill_value);

2968 12 operator new 0 4 3509 23 LMatrix3f::operator new 0 1 1205 0
122
inline void *LMatrix3f::operator new(std::size_t size);
inline void *LMatrix3f::operator new(std::size_t size, void *ptr);

2969 15 operator delete 0 4 3509 26 LMatrix3f::operator delete 0 0 0
106
inline void LMatrix3f::operator delete(void *ptr);
inline void LMatrix3f::operator delete(void *, void *);

2970 12 validate_ptr 0 4 3509 23 LMatrix3f::validate_ptr 0 0 0
60
static inline bool LMatrix3f::validate_ptr(void const *ptr);

2971 10 __reduce__ 0 4 3509 21 LMatrix3f::__reduce__ 0 1 1206 0
61
inline PyObject *LMatrix3f::__reduce__(PyObject *self) const;

2972 4 fill 0 4 3509 15 LMatrix3f::fill 0 1 1207 157
/**
 * Sets each element of the matrix to the indicated fill_value.  This is of
 * questionable value, but is sometimes useful when initializing to zero.
 */
39
void LMatrix3f::fill(float fill_value);

2973 3 set 0 4 3509 14 LMatrix3f::set 0 1 1208 10
/**
 *
 */
126
inline void LMatrix3f::set(float e00, float e01, float e02, float e10, float e11, float e12, float e20, float e21, float e22);

2974 11 operator [] 0 4 3509 22 LMatrix3f::operator [] 0 2 1209 1210 0
112
inline LMatrix3f::CRow LMatrix3f::operator [](int i) const;
inline LMatrix3f::Row LMatrix3f::operator [](int i);

2975 4 size 0 4 3509 15 LMatrix3f::size 0 1 1211 55
/**
 * Returns 3: the number of rows of a LMatrix3.
 */
40
static inline int LMatrix3f::size(void);

2976 7 set_row 0 4 3509 18 LMatrix3f::set_row 0 2 1212 1213 193
/**
 * Replaces the indicated row of the matrix from a three-component vector.
 */

/**
 * Replaces the indicated row of the matrix from a two-component vector,
 * ignoring the last column.
 */
123
inline void LMatrix3f::set_row(int row, LVecBase3f const &v);
inline void LMatrix3f::set_row(int row, LVecBase2f const &v);

2977 7 set_col 0 4 3509 18 LMatrix3f::set_col 0 2 1214 1215 196
/**
 * Replaces the indicated column of the matrix from a three-component vector.
 */

/**
 * Replaces the indicated column of the matrix from a two-component vector,
 * ignoring the last row.
 */
123
inline void LMatrix3f::set_col(int col, LVecBase3f const &v);
inline void LMatrix3f::set_col(int col, LVecBase2f const &v);

2978 7 get_row 0 4 3509 18 LMatrix3f::get_row 0 2 1216 1217 192
// these versions inline better

/**
 * Returns the indicated row of the matrix as a three-component vector.
 */

/**
 * Stores the indicated row of the matrix as a three-component vector.
 */
123
inline LVecBase3f LMatrix3f::get_row(int row) const;
inline void LMatrix3f::get_row(LVecBase3f &result_vec, int row) const;

2979 7 get_col 0 4 3509 18 LMatrix3f::get_col 0 1 1218 82
/**
 * Returns the indicated column of the matrix as a three-component vector.
 */
52
inline LVecBase3f LMatrix3f::get_col(int col) const;

2980 8 get_row2 0 4 3509 19 LMatrix3f::get_row2 0 1 1219 106
/**
 * Returns the indicated row of the matrix as a two-component vector, ignoring
 * the last column.
 */
53
inline LVecBase2f LMatrix3f::get_row2(int row) const;

2981 8 get_col2 0 4 3509 19 LMatrix3f::get_col2 0 1 1220 106
/**
 * Returns the indicated column of the matrix as a two-component vector,
 * ignoring the last row.
 */
53
inline LVecBase2f LMatrix3f::get_col2(int col) const;

2982 11 operator () 0 4 3509 22 LMatrix3f::operator () 0 2 1221 1222 10
/**
 *
 */
116
inline float &LMatrix3f::operator ()(int row, int col);
inline float LMatrix3f::operator ()(int row, int col) const;

2983 6 is_nan 0 4 3509 17 LMatrix3f::is_nan 0 1 1223 91
/**
 * Returns true if any component of the matrix is not-a-number, false
 * otherwise.
 */
42
inline bool LMatrix3f::is_nan(void) const;

2984 11 is_identity 0 4 3509 22 LMatrix3f::is_identity 0 1 1224 93
/**
 * Returns true if this is (close enough to) the identity matrix, false
 * otherwise.
 */
47
inline bool LMatrix3f::is_identity(void) const;

2985 8 get_cell 0 4 3509 19 LMatrix3f::get_cell 0 1 1225 54
/**
 * Returns a particular element of the matrix.
 */
57
inline float LMatrix3f::get_cell(int row, int col) const;

2986 8 set_cell 0 4 3509 19 LMatrix3f::set_cell 0 1 1226 54
/**
 * Changes a particular element of the matrix.
 */
63
inline void LMatrix3f::set_cell(int row, int col, float value);

2987 8 get_data 0 4 3509 19 LMatrix3f::get_data 0 1 1227 162
/**
 * Returns the address of the first of the nine data elements in the matrix.
 * The remaining elements occupy the next eight positions in row-major order.
 */
52
inline float const *LMatrix3f::get_data(void) const;

2988 18 get_num_components 0 4 3509 29 LMatrix3f::get_num_components 0 1 1228 62
/**
 * Returns the number of elements in the matrix, nine.
 */
53
inline int LMatrix3f::get_num_components(void) const;

2989 10 operator < 0 4 3509 21 LMatrix3f::operator < 0 1 1229 0
64
inline bool LMatrix3f::operator <(LMatrix3f const &other) const;

2990 11 operator == 0 4 3509 22 LMatrix3f::operator == 0 1 1230 0
65
inline bool LMatrix3f::operator ==(LMatrix3f const &other) const;

2991 11 operator != 0 4 3509 22 LMatrix3f::operator != 0 1 1231 0
65
inline bool LMatrix3f::operator !=(LMatrix3f const &other) const;

2992 10 compare_to 0 4 3509 21 LMatrix3f::compare_to 0 2 1232 1233 333
/**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */

/**
 * Sorts matrices lexicographically, componentwise.  Returns a number less
 * than 0 if this matrix sorts before the other one, greater than zero if it
 * sorts after, 0 if they are equivalent (within the indicated tolerance).
 */
137
inline int LMatrix3f::compare_to(LMatrix3f const &other) const;
int LMatrix3f::compare_to(LMatrix3f const &other, float threshold) const;

2993 8 get_hash 0 4 3509 19 LMatrix3f::get_hash 0 2 1234 1235 100
/**
 * Returns a suitable hash for phash_map.
 */

/**
 * Returns a suitable hash for phash_map.
 */
114
inline std::size_t LMatrix3f::get_hash(void) const;
inline std::size_t LMatrix3f::get_hash(float threshold) const;

2994 8 add_hash 0 4 3509 19 LMatrix3f::add_hash 0 2 1236 1237 100
/**
 * Adds the vector into the running hash.
 */

/**
 * Adds the vector into the running hash.
 */
144
inline std::size_t LMatrix3f::add_hash(std::size_t hash) const;
inline std::size_t LMatrix3f::add_hash(std::size_t hash, float threshold) const;

2995 5 xform 0 4 3509 16 LMatrix3f::xform 0 1 1238 52
/**
 * 3-component vector or point times matrix.
 */
62
inline LVecBase3f LMatrix3f::xform(LVecBase3f const &v) const;

2996 11 xform_point 0 4 3509 22 LMatrix3f::xform_point 0 1 1239 162
/**
 * The matrix transforms a 2-component point (including translation component)
 * and returns the result.  This assumes the matrix is an affine transform.
 */
68
inline LVecBase2f LMatrix3f::xform_point(LVecBase2f const &v) const;

2997 9 xform_vec 0 4 3509 20 LMatrix3f::xform_vec 0 2 1240 1241 357
/**
 * The matrix transforms a 2-component vector (without translation component)
 * and returns the result.  This assumes the matrix is an affine transform.
 */

/**
 * The matrix transforms a 3-component vector and returns the result.  This
 * assumes the matrix is an orthonormal transform.
 *
 * In practice, this is the same computation as xform().
 */
133
inline LVecBase2f LMatrix3f::xform_vec(LVecBase2f const &v) const;
inline LVecBase3f LMatrix3f::xform_vec(LVecBase3f const &v) const;

2998 17 xform_vec_general 0 4 3509 28 LMatrix3f::xform_vec_general 0 1 1242 142
/**
 * The matrix transforms a 3-component vector (without translation component)
 * and returns the result, as a fully general operation.
 */
74
inline LVecBase3f LMatrix3f::xform_vec_general(LVecBase3f const &v) const;

2999 14 xform_in_place 0 4 3509 25 LMatrix3f::xform_in_place 0 1 1243 52
/**
 * 3-component vector or point times matrix.
 */
59
inline void LMatrix3f::xform_in_place(LVecBase3f &v) const;

3000 20 xform_point_in_place 0 4 3509 31 LMatrix3f::xform_point_in_place 0 1 1244 139
/**
 * The matrix transforms a 2-component point (including translation
 * component).  This assumes the matrix is an affine transform.
 */
65
inline void LMatrix3f::xform_point_in_place(LVecBase2f &v) const;

3001 18 xform_vec_in_place 0 4 3509 29 LMatrix3f::xform_vec_in_place 0 2 1245 1246 310
/**
 * The matrix transforms a 2-component vector (without translation component).
 * This assumes the matrix is an affine transform.
 */

/**
 * The matrix transforms a 3-component vector.  This assumes the matrix is an
 * orthonormal transform.
 *
 * In practice, this is the same computation as xform().
 */
127
inline void LMatrix3f::xform_vec_in_place(LVecBase2f &v) const;
inline void LMatrix3f::xform_vec_in_place(LVecBase3f &v) const;

3002 26 xform_vec_general_in_place 0 4 3509 37 LMatrix3f::xform_vec_general_in_place 0 1 1247 119
/**
 * The matrix transforms a 3-component vector (without translation component),
 * as a fully general operation.
 */
71
inline void LMatrix3f::xform_vec_general_in_place(LVecBase3f &v) const;

3003 8 multiply 0 4 3509 19 LMatrix3f::multiply 0 1 1248 52
// this = other1 * other2

// this = other1 * other2
82
inline void LMatrix3f::multiply(LMatrix3f const &other1, LMatrix3f const &other2);

3004 10 operator * 0 4 3509 21 LMatrix3f::operator * 0 2 1249 1250 0
129
inline LMatrix3f LMatrix3f::operator *(LMatrix3f const &other) const;
inline LMatrix3f LMatrix3f::operator *(float scalar) const;

3005 10 operator / 0 4 3509 21 LMatrix3f::operator / 0 1 1251 0
59
inline LMatrix3f LMatrix3f::operator /(float scalar) const;

3006 11 operator += 0 4 3509 22 LMatrix3f::operator += 0 1 1252 63
/**
 * Performs a memberwise addition between two matrices.
 */
65
inline LMatrix3f &LMatrix3f::operator +=(LMatrix3f const &other);

3007 11 operator -= 0 4 3509 22 LMatrix3f::operator -= 0 1 1253 66
/**
 * Performs a memberwise subtraction between two matrices.
 */
65
inline LMatrix3f &LMatrix3f::operator -=(LMatrix3f const &other);

3008 11 operator *= 0 4 3509 22 LMatrix3f::operator *= 0 2 1254 1255 51
/**
 *
 */

/**
 * Performs a memberwise scale.
 */
121
inline LMatrix3f &LMatrix3f::operator *=(LMatrix3f const &other);
inline LMatrix3f &LMatrix3f::operator *=(float scalar);

3009 11 operator /= 0 4 3509 22 LMatrix3f::operator /= 0 1 1256 39
/**
 * Performs a memberwise scale.
 */
55
inline LMatrix3f &LMatrix3f::operator /=(float scalar);

3010 18 componentwise_mult 0 4 3509 29 LMatrix3f::componentwise_mult 0 1 1257 10
/**
 *
 */
66
inline void LMatrix3f::componentwise_mult(LMatrix3f const &other);

3011 11 determinant 0 4 3509 22 LMatrix3f::determinant 0 1 1258 49
/**
 * Returns the determinant of the matrix.
 */
48
inline float LMatrix3f::determinant(void) const;

3012 14 transpose_from 0 4 3509 25 LMatrix3f::transpose_from 0 1 1259 10
/**
 *
 */
62
inline void LMatrix3f::transpose_from(LMatrix3f const &other);

3013 18 transpose_in_place 0 4 3509 29 LMatrix3f::transpose_in_place 0 1 1260 10
/**
 *
 */
48
inline void LMatrix3f::transpose_in_place(void);

3014 11 invert_from 0 4 3509 22 LMatrix3f::invert_from 0 1 1261 463
/**
 * Computes the inverse of the other matrix, and stores the result in this
 * matrix.  This is a fully general operation and makes no assumptions about
 * the type of transform represented by the matrix.
 *
 * The other matrix must be a different object than this matrix.  However, if
 * you need to invert a matrix in place, see invert_in_place.
 *
 * The return value is true if the matrix was successfully inverted, false if
 * there was a singularity.
 */
59
inline bool LMatrix3f::invert_from(LMatrix3f const &other);

3015 15 invert_in_place 0 4 3509 26 LMatrix3f::invert_in_place 0 1 1262 119
/**
 * Inverts the current matrix.  Returns true if the inverse is successful,
 * false if the matrix was singular.
 */
45
inline bool LMatrix3f::invert_in_place(void);

3016 21 invert_transpose_from 0 4 3509 32 LMatrix3f::invert_transpose_from 0 2 1263 1264 230
/**
 * Simultaneously computes the inverse of the indicated matrix, and then the
 * transpose of that inverse.
 */

/**
 * Simultaneously computes the inverse of the indicated matrix, and then the
 * transpose of that inverse.
 */
139
inline bool LMatrix3f::invert_transpose_from(LMatrix3f const &other);
inline bool LMatrix3f::invert_transpose_from(LMatrix4f const &other);

3017 9 ident_mat 0 4 3509 20 LMatrix3f::ident_mat 0 1 1265 147
/**
 * Returns an identity matrix.
 *
 * This function definition must appear first, since some inline functions
 * below take advantage of it.
 */
58
static inline LMatrix3f const &LMatrix3f::ident_mat(void);

3018 17 set_translate_mat 0 4 3509 28 LMatrix3f::set_translate_mat 0 1 1266 74
/**
 * Fills mat with a matrix that applies the indicated translation.
 */
66
inline void LMatrix3f::set_translate_mat(LVecBase2f const &trans);

3019 14 set_rotate_mat 0 4 3509 25 LMatrix3f::set_rotate_mat 0 2 1267 1268 225
/**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise.
 */

/**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */
156
inline void LMatrix3f::set_rotate_mat(float angle);
void LMatrix3f::set_rotate_mat(float angle, LVecBase3f const &axis, CoordinateSystem cs = ::CS_default);

3020 13 set_scale_mat 0 4 3509 24 LMatrix3f::set_scale_mat 0 2 1269 1270 194
/**
 * Fills mat with a matrix that applies the indicated scale in each of the two
 * axes.
 */

/**
 * Fills mat with a matrix that applies the indicated scale in each of the
 * three axes.
 */
125
inline void LMatrix3f::set_scale_mat(LVecBase2f const &scale);
inline void LMatrix3f::set_scale_mat(LVecBase3f const &scale);

3021 13 translate_mat 0 4 3509 24 LMatrix3f::translate_mat 0 2 1271 1272 136
/**
 * Returns a matrix that applies the indicated translation.
 */

/**
 * Returns a matrix that applies the indicated translation.
 */
144
static inline LMatrix3f LMatrix3f::translate_mat(LVecBase2f const &trans);
static inline LMatrix3f LMatrix3f::translate_mat(float tx, float ty);

3022 10 rotate_mat 0 4 3509 21 LMatrix3f::rotate_mat 0 2 1273 1274 211
/**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise.
 */

/**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */
179
static inline LMatrix3f LMatrix3f::rotate_mat(float angle);
static inline LMatrix3f LMatrix3f::rotate_mat(float angle, LVecBase3f const &axis, CoordinateSystem cs = ::CS_default);

3023 9 scale_mat 0 4 3509 20 LMatrix3f::scale_mat 0 4 1275 1276 1277 1278 356
/**
 * Returns a matrix that applies the indicated scale in each of the two axes.
 */

/**
 * Returns a matrix that applies the indicated scale in each of the two axes.
 */

/**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */

/**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */
283
static inline LMatrix3f LMatrix3f::scale_mat(LVecBase2f const &scale);
static inline LMatrix3f LMatrix3f::scale_mat(float sx, float sy);
static inline LMatrix3f LMatrix3f::scale_mat(LVecBase3f const &scale);
static inline LMatrix3f LMatrix3f::scale_mat(float sx, float sy, float sz);

3024 23 set_rotate_mat_normaxis 0 4 3509 34 LMatrix3f::set_rotate_mat_normaxis 0 1 1279 163
/**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * normalized.
 */
113
void LMatrix3f::set_rotate_mat_normaxis(float angle, LVecBase3f const &axis, CoordinateSystem cs = ::CS_default);

3025 19 rotate_mat_normaxis 0 4 3509 30 LMatrix3f::rotate_mat_normaxis 0 1 1280 156
/**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * normalized.
 */
128
static inline LMatrix3f LMatrix3f::rotate_mat_normaxis(float angle, LVecBase3f const &axis, CoordinateSystem cs = ::CS_default);

3026 13 set_shear_mat 0 4 3509 24 LMatrix3f::set_shear_mat 0 1 1281 99
/**
 * Fills mat with a matrix that applies the indicated shear in each of the
 * three planes.
 */
98
inline void LMatrix3f::set_shear_mat(LVecBase3f const &shear, CoordinateSystem cs = ::CS_default);

3027 9 shear_mat 0 4 3509 20 LMatrix3f::shear_mat 0 2 1282 1283 186
/**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */

/**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */
224
static inline LMatrix3f LMatrix3f::shear_mat(LVecBase3f const &shear, CoordinateSystem cs = ::CS_default);
static inline LMatrix3f LMatrix3f::shear_mat(float shxy, float shxz, float shyz, CoordinateSystem cs = ::CS_default);

3028 19 set_scale_shear_mat 0 4 3509 30 LMatrix3f::set_scale_shear_mat 0 1 1284 78
/**
 * Fills mat with a matrix that applies the indicated scale and shear.
 */
122
void LMatrix3f::set_scale_shear_mat(LVecBase3f const &scale, LVecBase3f const &shear, CoordinateSystem cs = ::CS_default);

3029 15 scale_shear_mat 0 4 3509 26 LMatrix3f::scale_shear_mat 0 2 1285 1286 144
/**
 * Returns a matrix that applies the indicated scale and shear.
 */

/**
 * Returns a matrix that applies the indicated scale and shear.
 */
291
static inline LMatrix3f LMatrix3f::scale_shear_mat(LVecBase3f const &scale, LVecBase3f const &shear, CoordinateSystem cs = ::CS_default);
static inline LMatrix3f LMatrix3f::scale_shear_mat(float sx, float sy, float sz, float shxy, float shxz, float shyz, CoordinateSystem cs = ::CS_default);

3030 11 convert_mat 0 4 3509 22 LMatrix3f::convert_mat 0 1 1287 119
/**
 * Returns a matrix that transforms from the indicated coordinate system to
 * the indicated coordinate system.
 */
91
static LMatrix3f const &LMatrix3f::convert_mat(CoordinateSystem from, CoordinateSystem to);

3031 12 almost_equal 0 4 3509 23 LMatrix3f::almost_equal 0 2 1288 1289 212
/**
 * Returns true if two matrices are memberwise equal within a default
 * tolerance based on the numeric type.
 */

/**
 * Returns true if two matrices are memberwise equal within a specified
 * tolerance.
 */
143
bool LMatrix3f::almost_equal(LMatrix3f const &other, float threshold) const;
inline bool LMatrix3f::almost_equal(LMatrix3f const &other) const;

3032 6 output 0 4 3509 17 LMatrix3f::output 0 1 1290 10
/**
 *
 */
43
void LMatrix3f::output(ostream &out) const;

3033 5 write 0 4 3509 16 LMatrix3f::write 0 1 1291 10
/**
 *
 */
64
void LMatrix3f::write(ostream &out, int indent_level = 0) const;

3034 8 __repr__ 0 4 3509 19 LMatrix3f::__repr__ 0 1 1292 0
51
inline std::string LMatrix3f::__repr__(void) const;

3035 13 generate_hash 0 4 3509 24 LMatrix3f::generate_hash 0 2 1293 1294 120
/**
 * Adds the vector to the indicated hash generator.
 */

/**
 * Adds the vector to the indicated hash generator.
 */
161
inline void LMatrix3f::generate_hash(ChecksumHashGenerator &hashgen) const;
void LMatrix3f::generate_hash(ChecksumHashGenerator &hashgen, float threshold) const;

3036 20 write_datagram_fixed 0 4 3509 31 LMatrix3f::write_datagram_fixed 0 1 1295 332
/**
 * Writes the matrix to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the matrix, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */
66
void LMatrix3f::write_datagram_fixed(Datagram &destination) const;

3037 19 read_datagram_fixed 0 4 3509 30 LMatrix3f::read_datagram_fixed 0 1 1296 114
/**
 * Reads the matrix from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */
60
void LMatrix3f::read_datagram_fixed(DatagramIterator &scan);

3038 14 write_datagram 0 4 3509 25 LMatrix3f::write_datagram 0 1 1297 205
/**
 * Writes the matrix to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the matrix using the standard width
 * setting, especially when you are writing a bam file.
 */
60
void LMatrix3f::write_datagram(Datagram &destination) const;

3039 13 read_datagram 0 4 3509 24 LMatrix3f::read_datagram 0 1 1298 67
/**
 * Reads the matrix from the Datagram using get_stdfloat().
 */
56
void LMatrix3f::read_datagram(DatagramIterator &source);

3040 14 get_class_type 0 4 3509 25 LMatrix3f::get_class_type 0 1 1299 0
50
static TypeHandle LMatrix3f::get_class_type(void);

3041 10 ~LMatrix3f 0 4 3509 21 LMatrix3f::~LMatrix3f 0 0 0
28
LMatrix3f::~LMatrix3f(void);

3042 9 transpose 0 1 0 9 transpose 0 4 1854 1855 1856 1857 0
191
inline LMatrix3f transpose(LMatrix3f const &a);
inline LMatrix4f transpose(LMatrix4f const &a);
inline LMatrix3d transpose(LMatrix3d const &a);
inline LMatrix4d transpose(LMatrix4d const &a);

3043 6 invert 0 1 0 6 invert 0 6 1858 1859 1860 1861 1862 1863 0
281
inline LMatrix3f invert(LMatrix3f const &a);
inline LMatrix4f invert(LMatrix4f const &a);
inline LMatrix3d invert(LMatrix3d const &a);
inline LMatrix4d invert(LMatrix4d const &a);
inline LQuaternionf invert(LQuaternionf const &a);
inline LQuaterniond invert(LQuaterniond const &a);

3044 11 operator [] 0 4 3515 27 LMatrix4f::Row::operator [] 0 2 1418 1419 10
/**
 *
 */
104
inline float LMatrix4f::Row::operator [](int i) const;
inline float &LMatrix4f::Row::operator [](int i);

3045 4 size 0 4 3515 20 LMatrix4f::Row::size 0 1 1420 58
/**
 * Returns 4: the number of columns of a LMatrix4.
 */
45
static inline int LMatrix4f::Row::size(void);

3046 3 Row 0 4 3515 19 LMatrix4f::Row::Row 0 1 1417 60
/**
 * Defines a row-level index accessor to the matrix.
 */
61
inline LMatrix4f::Row::Row(LMatrix4f::Row const &) = default;

3047 4 ~Row 0 4 3515 20 LMatrix4f::Row::~Row 0 0 0
27
LMatrix4f::Row::~Row(void);

3048 11 operator [] 0 4 3516 28 LMatrix4f::CRow::operator [] 0 1 1422 0
55
inline float LMatrix4f::CRow::operator [](int i) const;

3049 4 size 0 4 3516 21 LMatrix4f::CRow::size 0 1 1423 58
/**
 * Returns 4: the number of columns of a LMatrix4.
 */
46
static inline int LMatrix4f::CRow::size(void);

3050 4 CRow 0 4 3516 21 LMatrix4f::CRow::CRow 0 1 1421 63
/**
 * Defines a row-level constant accessor to the matrix.
 */
64
inline LMatrix4f::CRow::CRow(LMatrix4f::CRow const &) = default;

3051 5 ~CRow 0 4 3516 22 LMatrix4f::CRow::~CRow 0 0 0
29
LMatrix4f::CRow::~CRow(void);

3052 9 LMatrix4f 0 4 3513 20 LMatrix4f::LMatrix4f 0 6 1307 1308 1309 1310 1311 1312 167
// Construct a 4x4 matrix given a 3x3 rotation matrix and an optional
// translation component.

/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
487
inline LMatrix4f::LMatrix4f(void);
inline LMatrix4f::LMatrix4f(LMatrix4f const &other);
inline LMatrix4f::LMatrix4f(UnalignedLMatrix4f const &other);
inline LMatrix4f::LMatrix4f(float e00, float e01, float e02, float e03, float e10, float e11, float e12, float e13, float e20, float e21, float e22, float e23, float e30, float e31, float e32, float e33);
inline LMatrix4f::LMatrix4f(LMatrix3f const &upper3);
inline LMatrix4f::LMatrix4f(LMatrix3f const &upper3, LVecBase3f const &trans);

3053 10 operator = 0 4 3513 21 LMatrix4f::operator = 0 3 1313 1314 1315 34
/**
 *
 */

/**
 *
 */

/**
 *
 */
197
inline LMatrix4f &LMatrix4f::operator =(LMatrix4f const &other);
inline LMatrix4f &LMatrix4f::operator =(UnalignedLMatrix4f const &other);
inline LMatrix4f &LMatrix4f::operator =(float fill_value);

3054 12 operator new 0 4 3513 23 LMatrix4f::operator new 0 1 1316 0
122
inline void *LMatrix4f::operator new(std::size_t size);
inline void *LMatrix4f::operator new(std::size_t size, void *ptr);

3055 15 operator delete 0 4 3513 26 LMatrix4f::operator delete 0 0 0
106
inline void LMatrix4f::operator delete(void *ptr);
inline void LMatrix4f::operator delete(void *, void *);

3056 12 validate_ptr 0 4 3513 23 LMatrix4f::validate_ptr 0 0 0
60
static inline bool LMatrix4f::validate_ptr(void const *ptr);

3057 10 __reduce__ 0 4 3513 21 LMatrix4f::__reduce__ 0 1 1317 0
61
inline PyObject *LMatrix4f::__reduce__(PyObject *self) const;

3058 4 fill 0 4 3513 15 LMatrix4f::fill 0 1 1318 157
/**
 * Sets each element of the matrix to the indicated fill_value.  This is of
 * questionable value, but is sometimes useful when initializing to zero.
 */
46
inline void LMatrix4f::fill(float fill_value);

3059 3 set 0 4 3513 14 LMatrix4f::set 0 1 1319 10
/**
 *
 */
203
inline void LMatrix4f::set(float e00, float e01, float e02, float e03, float e10, float e11, float e12, float e13, float e20, float e21, float e22, float e23, float e30, float e31, float e32, float e33);

3060 11 set_upper_3 0 4 3513 22 LMatrix4f::set_upper_3 0 1 1320 87
// Get and set the upper 3x3 rotation matrix.

/**
 * Sets the upper 3x3 submatrix.
 */
60
inline void LMatrix4f::set_upper_3(LMatrix3f const &upper3);

3061 11 get_upper_3 0 4 3513 22 LMatrix4f::get_upper_3 0 1 1321 45
/**
 * Retrieves the upper 3x3 submatrix.
 */
52
inline LMatrix3f LMatrix4f::get_upper_3(void) const;

3062 11 operator [] 0 4 3513 22 LMatrix4f::operator [] 0 2 1322 1323 0
112
inline LMatrix4f::CRow LMatrix4f::operator [](int i) const;
inline LMatrix4f::Row LMatrix4f::operator [](int i);

3063 4 size 0 4 3513 15 LMatrix4f::size 0 1 1324 55
/**
 * Returns 4: the number of rows of a LMatrix4.
 */
40
static inline int LMatrix4f::size(void);

3064 7 set_row 0 4 3513 18 LMatrix4f::set_row 0 2 1325 1326 173
/**
 * Replaces the indicated row of the matrix.
 */

/**
 * Replaces the indicated row of the matrix with the indicated 3-component
 * vector, ignoring the last column.
 */
123
inline void LMatrix4f::set_row(int row, LVecBase4f const &v);
inline void LMatrix4f::set_row(int row, LVecBase3f const &v);

3065 7 set_col 0 4 3513 18 LMatrix4f::set_col 0 2 1327 1328 176
/**
 * Replaces the indicated column of the matrix.
 */

/**
 * Replaces the indicated column of the matrix with the indicated 3-component
 * vector, ignoring the last row.
 */
123
inline void LMatrix4f::set_col(int col, LVecBase4f const &v);
inline void LMatrix4f::set_col(int col, LVecBase3f const &v);

3066 7 get_row 0 4 3513 18 LMatrix4f::get_row 0 2 1329 1330 186
// these versions inline better

/**
 * Retrieves the indicated row of the matrix as a 4-component vector.
 */

/**
 * Stores the indicated row of the matrix as a 4-component vector.
 */
123
inline LVecBase4f LMatrix4f::get_row(int row) const;
inline void LMatrix4f::get_row(LVecBase4f &result_vec, int row) const;

3067 7 get_col 0 4 3513 18 LMatrix4f::get_col 0 1 1331 80
/**
 * Retrieves the indicated column of the matrix as a 4-component vector.
 */
52
inline LVecBase4f LMatrix4f::get_col(int col) const;

3068 8 get_row3 0 4 3513 19 LMatrix4f::get_row3 0 2 1332 1333 205
/**
 * Retrieves the row column of the matrix as a 3-component vector, ignoring
 * the last column.
 */

/**
 * Stores the row column of the matrix as a 3-component vector, ignoring the
 * last column.
 */
125
inline LVecBase3f LMatrix4f::get_row3(int row) const;
inline void LMatrix4f::get_row3(LVecBase3f &result_vec, int row) const;

3069 8 get_col3 0 4 3513 19 LMatrix4f::get_col3 0 1 1334 106
/**
 * Retrieves the indicated column of the matrix as a 3-component vector,
 * ignoring the last row.
 */
53
inline LVecBase3f LMatrix4f::get_col3(int col) const;

3070 11 operator () 0 4 3513 22 LMatrix4f::operator () 0 2 1335 1336 10
/**
 *
 */
116
inline float &LMatrix4f::operator ()(int row, int col);
inline float LMatrix4f::operator ()(int row, int col) const;

3071 6 is_nan 0 4 3513 17 LMatrix4f::is_nan 0 1 1337 91
/**
 * Returns true if any component of the matrix is not-a-number, false
 * otherwise.
 */
42
inline bool LMatrix4f::is_nan(void) const;

3072 11 is_identity 0 4 3513 22 LMatrix4f::is_identity 0 1 1338 93
/**
 * Returns true if this is (close enough to) the identity matrix, false
 * otherwise.
 */
47
inline bool LMatrix4f::is_identity(void) const;

3073 8 get_cell 0 4 3513 19 LMatrix4f::get_cell 0 1 1339 54
/**
 * Returns a particular element of the matrix.
 */
57
inline float LMatrix4f::get_cell(int row, int col) const;

3074 8 set_cell 0 4 3513 19 LMatrix4f::set_cell 0 1 1340 54
/**
 * Changes a particular element of the matrix.
 */
63
inline void LMatrix4f::set_cell(int row, int col, float value);

3075 8 get_data 0 4 3513 19 LMatrix4f::get_data 0 1 1341 162
/**
 * Returns the address of the first of the nine data elements in the matrix.
 * The remaining elements occupy the next eight positions in row-major order.
 */
52
inline float const *LMatrix4f::get_data(void) const;

3076 18 get_num_components 0 4 3513 29 LMatrix4f::get_num_components 0 1 1342 60
/**
 * Returns the number of elements in the matrix, 16.
 */
53
inline int LMatrix4f::get_num_components(void) const;

3077 5 begin 0 4 3513 16 LMatrix4f::begin 0 2 1343 1344 204
/**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */

/**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */
113
inline LMatrix4f::iterator LMatrix4f::begin(void);
inline LMatrix4f::const_iterator LMatrix4f::begin(void) const;

3078 3 end 0 4 3513 14 LMatrix4f::end 0 2 1345 1346 204
/**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */

/**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */
109
inline LMatrix4f::iterator LMatrix4f::end(void);
inline LMatrix4f::const_iterator LMatrix4f::end(void) const;

3079 10 operator < 0 4 3513 21 LMatrix4f::operator < 0 1 1347 0
64
inline bool LMatrix4f::operator <(LMatrix4f const &other) const;

3080 11 operator == 0 4 3513 22 LMatrix4f::operator == 0 1 1348 0
65
inline bool LMatrix4f::operator ==(LMatrix4f const &other) const;

3081 11 operator != 0 4 3513 22 LMatrix4f::operator != 0 1 1349 0
65
inline bool LMatrix4f::operator !=(LMatrix4f const &other) const;

3082 10 compare_to 0 4 3513 21 LMatrix4f::compare_to 0 2 1350 1351 333
/**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */

/**
 * Sorts matrices lexicographically, componentwise.  Returns a number less
 * than 0 if this matrix sorts before the other one, greater than zero if it
 * sorts after, 0 if they are equivalent (within the indicated tolerance).
 */
137
inline int LMatrix4f::compare_to(LMatrix4f const &other) const;
int LMatrix4f::compare_to(LMatrix4f const &other, float threshold) const;

3083 8 get_hash 0 4 3513 19 LMatrix4f::get_hash 0 2 1352 1353 100
/**
 * Returns a suitable hash for phash_map.
 */

/**
 * Returns a suitable hash for phash_map.
 */
114
inline std::size_t LMatrix4f::get_hash(void) const;
inline std::size_t LMatrix4f::get_hash(float threshold) const;

3084 8 add_hash 0 4 3513 19 LMatrix4f::add_hash 0 2 1354 1355 100
/**
 * Adds the vector into the running hash.
 */

/**
 * Adds the vector into the running hash.
 */
144
inline std::size_t LMatrix4f::add_hash(std::size_t hash) const;
inline std::size_t LMatrix4f::add_hash(std::size_t hash, float threshold) const;

3085 5 xform 0 4 3513 16 LMatrix4f::xform 0 1 1356 91
/**
 * 4-component vector or point times matrix.  This is a fully general
 * operation.
 */
62
inline LVecBase4f LMatrix4f::xform(LVecBase4f const &v) const;

3086 11 xform_point 0 4 3513 22 LMatrix4f::xform_point 0 1 1357 162
/**
 * The matrix transforms a 3-component point (including translation component)
 * and returns the result.  This assumes the matrix is an affine transform.
 */
68
inline LVecBase3f LMatrix4f::xform_point(LVecBase3f const &v) const;

3087 19 xform_point_general 0 4 3513 30 LMatrix4f::xform_point_general 0 1 1358 143
/**
 * The matrix transforms a 3-component point (including translation component)
 * and returns the result, as a fully general operation.
 */
76
inline LVecBase3f LMatrix4f::xform_point_general(LVecBase3f const &v) const;

3088 9 xform_vec 0 4 3513 20 LMatrix4f::xform_vec 0 1 1359 169
/**
 * The matrix transforms a 3-component vector (without translation component)
 * and returns the result.  This assumes the matrix is an orthonormal
 * transform.
 */
66
inline LVecBase3f LMatrix4f::xform_vec(LVecBase3f const &v) const;

3089 17 xform_vec_general 0 4 3513 28 LMatrix4f::xform_vec_general 0 1 1360 142
/**
 * The matrix transforms a 3-component vector (without translation component)
 * and returns the result, as a fully general operation.
 */
74
inline LVecBase3f LMatrix4f::xform_vec_general(LVecBase3f const &v) const;

3090 14 xform_in_place 0 4 3513 25 LMatrix4f::xform_in_place 0 1 1361 91
/**
 * 4-component vector or point times matrix.  This is a fully general
 * operation.
 */
59
inline void LMatrix4f::xform_in_place(LVecBase4f &v) const;

3091 20 xform_point_in_place 0 4 3513 31 LMatrix4f::xform_point_in_place 0 1 1362 139
/**
 * The matrix transforms a 3-component point (including translation
 * component).  This assumes the matrix is an affine transform.
 */
65
inline void LMatrix4f::xform_point_in_place(LVecBase3f &v) const;

3092 28 xform_point_general_in_place 0 4 3513 39 LMatrix4f::xform_point_general_in_place 0 1 1363 120
/**
 * The matrix transforms a 3-component point (including translation
 * component), as a fully general operation.
 */
73
inline void LMatrix4f::xform_point_general_in_place(LVecBase3f &v) const;

3093 18 xform_vec_in_place 0 4 3513 29 LMatrix4f::xform_vec_in_place 0 1 1364 142
/**
 * The matrix transforms a 3-component vector (without translation component).
 * This assumes the matrix is an orthonormal transform.
 */
63
inline void LMatrix4f::xform_vec_in_place(LVecBase3f &v) const;

3094 26 xform_vec_general_in_place 0 4 3513 37 LMatrix4f::xform_vec_general_in_place 0 1 1365 119
/**
 * The matrix transforms a 3-component vector (without translation component),
 * as a fully general operation.
 */
71
inline void LMatrix4f::xform_vec_general_in_place(LVecBase3f &v) const;

3095 8 multiply 0 4 3513 19 LMatrix4f::multiply 0 1 1366 52
// this = other1 * other2

// this = other1 * other2
82
inline void LMatrix4f::multiply(LMatrix4f const &other1, LMatrix4f const &other2);

3096 10 operator * 0 4 3513 21 LMatrix4f::operator * 0 2 1367 1368 0
129
inline LMatrix4f LMatrix4f::operator *(LMatrix4f const &other) const;
inline LMatrix4f LMatrix4f::operator *(float scalar) const;

3097 10 operator / 0 4 3513 21 LMatrix4f::operator / 0 1 1369 0
59
inline LMatrix4f LMatrix4f::operator /(float scalar) const;

3098 11 operator += 0 4 3513 22 LMatrix4f::operator += 0 1 1370 63
/**
 * Performs a memberwise addition between two matrices.
 */
65
inline LMatrix4f &LMatrix4f::operator +=(LMatrix4f const &other);

3099 11 operator -= 0 4 3513 22 LMatrix4f::operator -= 0 1 1371 63
/**
 * Performs a memberwise addition between two matrices.
 */
65
inline LMatrix4f &LMatrix4f::operator -=(LMatrix4f const &other);

3100 11 operator *= 0 4 3513 22 LMatrix4f::operator *= 0 2 1372 1373 22
/**
 *
 */

/**
 *
 */
121
inline LMatrix4f &LMatrix4f::operator *=(LMatrix4f const &other);
inline LMatrix4f &LMatrix4f::operator *=(float scalar);

3101 11 operator /= 0 4 3513 22 LMatrix4f::operator /= 0 1 1374 10
/**
 *
 */
55
inline LMatrix4f &LMatrix4f::operator /=(float scalar);

3102 18 componentwise_mult 0 4 3513 29 LMatrix4f::componentwise_mult 0 1 1375 10
/**
 *
 */
66
inline void LMatrix4f::componentwise_mult(LMatrix4f const &other);

3103 14 transpose_from 0 4 3513 25 LMatrix4f::transpose_from 0 1 1376 10
/**
 *
 */
62
inline void LMatrix4f::transpose_from(LMatrix4f const &other);

3104 18 transpose_in_place 0 4 3513 29 LMatrix4f::transpose_in_place 0 1 1377 10
/**
 *
 */
48
inline void LMatrix4f::transpose_in_place(void);

3105 11 invert_from 0 4 3513 22 LMatrix4f::invert_from 0 1 1378 461
/**
 * Computes the inverse of the other matrix, and stores the result in this
 * matrix.  This is a fully general operation and makes no assumptions about
 * the type of transform represented by the matrix.
 *
 * The other matrix must be a different object than this matrix.  However, if
 * you need to invert a matrix in place, see invert_in_place.
 *
 * The return value is true if the matrix was successfully inverted, false if
 * the was a singularity.
 */
59
inline bool LMatrix4f::invert_from(LMatrix4f const &other);

3106 18 invert_affine_from 0 4 3513 29 LMatrix4f::invert_affine_from 0 1 1379 139
// bugbug: we could optimize this for rotationscaletranslation matrices
// (transpose upper 3x3 and take negative of translation component)
66
inline bool LMatrix4f::invert_affine_from(LMatrix4f const &other);

3107 15 invert_in_place 0 4 3513 26 LMatrix4f::invert_in_place 0 1 1380 119
/**
 * Inverts the current matrix.  Returns true if the inverse is successful,
 * false if the matrix was singular.
 */
45
inline bool LMatrix4f::invert_in_place(void);

3108 10 accumulate 0 4 3513 21 LMatrix4f::accumulate 0 1 1381 46
/**
 * Computes (*this) += other * weight.
 */
72
inline void LMatrix4f::accumulate(LMatrix4f const &other, float weight);

3109 9 ident_mat 0 4 3513 20 LMatrix4f::ident_mat 0 1 1382 147
/**
 * Returns an identity matrix.
 *
 * This function definition must appear first, since some inline functions
 * below take advantage of it.
 */
58
static inline LMatrix4f const &LMatrix4f::ident_mat(void);

3110 8 ones_mat 0 4 3513 19 LMatrix4f::ones_mat 0 1 1383 46
/**
 * Returns an matrix filled with ones.
 */
57
static inline LMatrix4f const &LMatrix4f::ones_mat(void);

3111 9 zeros_mat 0 4 3513 20 LMatrix4f::zeros_mat 0 1 1384 47
/**
 * Returns an matrix filled with zeros.
 */
58
static inline LMatrix4f const &LMatrix4f::zeros_mat(void);

3112 17 set_translate_mat 0 4 3513 28 LMatrix4f::set_translate_mat 0 1 1385 74
/**
 * Fills mat with a matrix that applies the indicated translation.
 */
66
inline void LMatrix4f::set_translate_mat(LVecBase3f const &trans);

3113 14 set_rotate_mat 0 4 3513 25 LMatrix4f::set_rotate_mat 0 1 1386 122
/**
 * Sets mat to a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */
104
void LMatrix4f::set_rotate_mat(float angle, LVecBase3f const &axis, CoordinateSystem cs = ::CS_default);

3114 23 set_rotate_mat_normaxis 0 4 3513 34 LMatrix4f::set_rotate_mat_normaxis 0 1 1387 166
/**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * prenormalized.
 */
113
void LMatrix4f::set_rotate_mat_normaxis(float angle, LVecBase3f const &axis, CoordinateSystem cs = ::CS_default);

3115 13 set_scale_mat 0 4 3513 24 LMatrix4f::set_scale_mat 0 1 1388 97
/**
 * Fills mat with a matrix that applies the indicated scale in each of the
 * three axes.
 */
62
inline void LMatrix4f::set_scale_mat(LVecBase3f const &scale);

3116 13 set_shear_mat 0 4 3513 24 LMatrix4f::set_shear_mat 0 1 1389 99
/**
 * Fills mat with a matrix that applies the indicated shear in each of the
 * three planes.
 */
98
inline void LMatrix4f::set_shear_mat(LVecBase3f const &shear, CoordinateSystem cs = ::CS_default);

3117 19 set_scale_shear_mat 0 4 3513 30 LMatrix4f::set_scale_shear_mat 0 1 1390 78
/**
 * Fills mat with a matrix that applies the indicated scale and shear.
 */
129
inline void LMatrix4f::set_scale_shear_mat(LVecBase3f const &scale, LVecBase3f const &shear, CoordinateSystem cs = ::CS_default);

3118 13 translate_mat 0 4 3513 24 LMatrix4f::translate_mat 0 2 1391 1392 136
/**
 * Returns a matrix that applies the indicated translation.
 */

/**
 * Returns a matrix that applies the indicated translation.
 */
154
static inline LMatrix4f LMatrix4f::translate_mat(LVecBase3f const &trans);
static inline LMatrix4f LMatrix4f::translate_mat(float tx, float ty, float tz);

3119 10 rotate_mat 0 4 3513 21 LMatrix4f::rotate_mat 0 1 1393 118
/**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */
119
static inline LMatrix4f LMatrix4f::rotate_mat(float angle, LVecBase3f const &axis, CoordinateSystem cs = ::CS_default);

3120 19 rotate_mat_normaxis 0 4 3513 30 LMatrix4f::rotate_mat_normaxis 0 1 1394 159
/**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * prenormalized.
 */
128
static inline LMatrix4f LMatrix4f::rotate_mat_normaxis(float angle, LVecBase3f const &axis, CoordinateSystem cs = ::CS_default);

3121 9 scale_mat 0 4 3513 20 LMatrix4f::scale_mat 0 3 1395 1396 1397 253
/**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */

/**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */

/**
 * Returns a matrix that applies the indicated uniform scale.
 */
205
static inline LMatrix4f LMatrix4f::scale_mat(LVecBase3f const &scale);
static inline LMatrix4f LMatrix4f::scale_mat(float sx, float sy, float sz);
static inline LMatrix4f LMatrix4f::scale_mat(float scale);

3122 9 shear_mat 0 4 3513 20 LMatrix4f::shear_mat 0 2 1398 1399 186
/**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */

/**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */
224
static inline LMatrix4f LMatrix4f::shear_mat(LVecBase3f const &shear, CoordinateSystem cs = ::CS_default);
static inline LMatrix4f LMatrix4f::shear_mat(float shxy, float shxz, float shyz, CoordinateSystem cs = ::CS_default);

3123 15 scale_shear_mat 0 4 3513 26 LMatrix4f::scale_shear_mat 0 2 1400 1401 144
/**
 * Returns a matrix that applies the indicated scale and shear.
 */

/**
 * Returns a matrix that applies the indicated scale and shear.
 */
291
static inline LMatrix4f LMatrix4f::scale_shear_mat(LVecBase3f const &scale, LVecBase3f const &shear, CoordinateSystem cs = ::CS_default);
static inline LMatrix4f LMatrix4f::scale_shear_mat(float sx, float sy, float sz, float shxy, float shxz, float shyz, CoordinateSystem cs = ::CS_default);

3124 13 y_to_z_up_mat 0 4 3513 24 LMatrix4f::y_to_z_up_mat 0 1 1402 109
/**
 * Returns a matrix that transforms from the Y-up coordinate system to the
 * Z-up coordinate system.
 */
62
static inline LMatrix4f const &LMatrix4f::y_to_z_up_mat(void);

3125 13 z_to_y_up_mat 0 4 3513 24 LMatrix4f::z_to_y_up_mat 0 1 1403 109
/**
 * Returns a matrix that transforms from the Y-up coordinate system to the
 * Z-up coordinate system.
 */
62
static inline LMatrix4f const &LMatrix4f::z_to_y_up_mat(void);

3126 11 convert_mat 0 4 3513 22 LMatrix4f::convert_mat 0 1 1404 119
/**
 * Returns a matrix that transforms from the indicated coordinate system to
 * the indicated coordinate system.
 */
91
static LMatrix4f const &LMatrix4f::convert_mat(CoordinateSystem from, CoordinateSystem to);

3127 12 almost_equal 0 4 3513 23 LMatrix4f::almost_equal 0 2 1405 1406 318
/**
 * Returns true if two matrices are memberwise equal within a default
 * tolerance based on the numeric type.
 */

/**
 * Returns true if two matrices are memberwise equal within a specified
 * tolerance.  This is faster than the equivalence operator as this doesn't
 * have to guarantee that it is transitive.
 */
143
bool LMatrix4f::almost_equal(LMatrix4f const &other, float threshold) const;
inline bool LMatrix4f::almost_equal(LMatrix4f const &other) const;

3128 6 output 0 4 3513 17 LMatrix4f::output 0 1 1407 10
/**
 *
 */
43
void LMatrix4f::output(ostream &out) const;

3129 5 write 0 4 3513 16 LMatrix4f::write 0 1 1408 10
/**
 *
 */
64
void LMatrix4f::write(ostream &out, int indent_level = 0) const;

3130 8 __repr__ 0 4 3513 19 LMatrix4f::__repr__ 0 1 1409 0
51
inline std::string LMatrix4f::__repr__(void) const;

3131 13 generate_hash 0 4 3513 24 LMatrix4f::generate_hash 0 2 1410 1411 120
/**
 * Adds the vector to the indicated hash generator.
 */

/**
 * Adds the vector to the indicated hash generator.
 */
157
inline void LMatrix4f::generate_hash(ChecksumHashGenerator &hashgen) const;
void LMatrix4f::generate_hash(ChecksumHashGenerator &hashgen, float scale) const;

3132 20 write_datagram_fixed 0 4 3513 31 LMatrix4f::write_datagram_fixed 0 1 1412 332
/**
 * Writes the matrix to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the matrix, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */
66
void LMatrix4f::write_datagram_fixed(Datagram &destination) const;

3133 19 read_datagram_fixed 0 4 3513 30 LMatrix4f::read_datagram_fixed 0 1 1413 114
/**
 * Reads the matrix from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */
60
void LMatrix4f::read_datagram_fixed(DatagramIterator &scan);

3134 14 write_datagram 0 4 3513 25 LMatrix4f::write_datagram 0 1 1414 205
/**
 * Writes the matrix to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the matrix using the standard width
 * setting, especially when you are writing a bam file.
 */
60
void LMatrix4f::write_datagram(Datagram &destination) const;

3135 13 read_datagram 0 4 3513 24 LMatrix4f::read_datagram 0 1 1415 67
/**
 * Reads the matrix from the Datagram using get_stdfloat().
 */
56
void LMatrix4f::read_datagram(DatagramIterator &source);

3136 14 get_class_type 0 4 3513 25 LMatrix4f::get_class_type 0 1 1416 0
50
static TypeHandle LMatrix4f::get_class_type(void);

3137 10 ~LMatrix4f 0 4 3513 21 LMatrix4f::~LMatrix4f 0 0 0
28
LMatrix4f::~LMatrix4f(void);

3138 18 UnalignedLMatrix4f 0 4 3517 38 UnalignedLMatrix4f::UnalignedLMatrix4f 0 4 1424 1425 1426 1427 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
424
inline UnalignedLMatrix4f::UnalignedLMatrix4f(void);
inline UnalignedLMatrix4f::UnalignedLMatrix4f(LMatrix4f const &copy);
inline UnalignedLMatrix4f::UnalignedLMatrix4f(UnalignedLMatrix4f const &copy);
inline UnalignedLMatrix4f::UnalignedLMatrix4f(float e00, float e01, float e02, float e03, float e10, float e11, float e12, float e13, float e20, float e21, float e22, float e23, float e30, float e31, float e32, float e33);

3139 10 operator = 0 4 3517 30 UnalignedLMatrix4f::operator = 0 2 1428 1429 22
/**
 *
 */

/**
 *
 */
172
inline UnalignedLMatrix4f &UnalignedLMatrix4f::operator =(LMatrix4f const &copy);
inline UnalignedLMatrix4f &UnalignedLMatrix4f::operator =(UnalignedLMatrix4f const &copy);

3140 3 set 0 4 3517 23 UnalignedLMatrix4f::set 0 1 1430 10
/**
 *
 */
212
inline void UnalignedLMatrix4f::set(float e00, float e01, float e02, float e03, float e10, float e11, float e12, float e13, float e20, float e21, float e22, float e23, float e30, float e31, float e32, float e33);

3141 11 operator () 0 4 3517 31 UnalignedLMatrix4f::operator () 0 2 1431 1432 10
/**
 *
 */
134
inline float &UnalignedLMatrix4f::operator ()(int row, int col);
inline float UnalignedLMatrix4f::operator ()(int row, int col) const;

3142 8 get_data 0 4 3517 28 UnalignedLMatrix4f::get_data 0 1 1433 162
/**
 * Returns the address of the first of the nine data elements in the matrix.
 * The remaining elements occupy the next eight positions in row-major order.
 */
61
inline float const *UnalignedLMatrix4f::get_data(void) const;

3143 18 get_num_components 0 4 3517 38 UnalignedLMatrix4f::get_num_components 0 1 1434 65
/**
 * Returns the number of elements in the matrix, sixteen.
 */
62
inline int UnalignedLMatrix4f::get_num_components(void) const;

3144 14 get_class_type 0 4 3517 34 UnalignedLMatrix4f::get_class_type 0 1 1435 0
59
static TypeHandle UnalignedLMatrix4f::get_class_type(void);

3145 19 ~UnalignedLMatrix4f 0 4 3517 39 UnalignedLMatrix4f::~UnalignedLMatrix4f 0 0 0
46
UnalignedLMatrix4f::~UnalignedLMatrix4f(void);

3146 11 operator [] 0 4 3521 27 LMatrix3d::Row::operator [] 0 2 1537 1538 10
/**
 *
 */
106
inline double LMatrix3d::Row::operator [](int i) const;
inline double &LMatrix3d::Row::operator [](int i);

3147 4 size 0 4 3521 20 LMatrix3d::Row::size 0 1 1539 58
/**
 * Returns 3: the number of columns of a LMatrix3.
 */
45
static inline int LMatrix3d::Row::size(void);

3148 3 Row 0 4 3521 19 LMatrix3d::Row::Row 0 1 1536 60
/**
 * Defines a row-level index accessor to the matrix.
 */
61
inline LMatrix3d::Row::Row(LMatrix3d::Row const &) = default;

3149 4 ~Row 0 4 3521 20 LMatrix3d::Row::~Row 0 0 0
27
LMatrix3d::Row::~Row(void);

3150 11 operator [] 0 4 3522 28 LMatrix3d::CRow::operator [] 0 1 1541 0
56
inline double LMatrix3d::CRow::operator [](int i) const;

3151 4 size 0 4 3522 21 LMatrix3d::CRow::size 0 1 1542 58
/**
 * Returns 3: the number of columns of a LMatrix3.
 */
46
static inline int LMatrix3d::CRow::size(void);

3152 4 CRow 0 4 3522 21 LMatrix3d::CRow::CRow 0 1 1540 63
/**
 * Defines a row-level constant accessor to the matrix.
 */
64
inline LMatrix3d::CRow::CRow(LMatrix3d::CRow const &) = default;

3153 5 ~CRow 0 4 3522 22 LMatrix3d::CRow::~CRow 0 0 0
29
LMatrix3d::CRow::~CRow(void);

3154 9 LMatrix3d 0 4 3519 20 LMatrix3d::LMatrix3d 0 3 1436 1437 1438 34
/**
 *
 */

/**
 *
 */

/**
 *
 */
224
inline LMatrix3d::LMatrix3d(void);
inline LMatrix3d::LMatrix3d(LMatrix3d const &other);
inline LMatrix3d::LMatrix3d(double e00, double e01, double e02, double e10, double e11, double e12, double e20, double e21, double e22);

3155 10 operator = 0 4 3519 21 LMatrix3d::operator = 0 2 1439 1440 22
/**
 *
 */

/**
 *
 */
124
inline LMatrix3d &LMatrix3d::operator =(LMatrix3d const &other);
inline LMatrix3d &LMatrix3d::operator =(double fill_value);

3156 12 operator new 0 4 3519 23 LMatrix3d::operator new 0 1 1441 0
122
inline void *LMatrix3d::operator new(std::size_t size);
inline void *LMatrix3d::operator new(std::size_t size, void *ptr);

3157 15 operator delete 0 4 3519 26 LMatrix3d::operator delete 0 0 0
106
inline void LMatrix3d::operator delete(void *ptr);
inline void LMatrix3d::operator delete(void *, void *);

3158 12 validate_ptr 0 4 3519 23 LMatrix3d::validate_ptr 0 0 0
60
static inline bool LMatrix3d::validate_ptr(void const *ptr);

3159 10 __reduce__ 0 4 3519 21 LMatrix3d::__reduce__ 0 1 1442 0
61
inline PyObject *LMatrix3d::__reduce__(PyObject *self) const;

3160 4 fill 0 4 3519 15 LMatrix3d::fill 0 1 1443 157
/**
 * Sets each element of the matrix to the indicated fill_value.  This is of
 * questionable value, but is sometimes useful when initializing to zero.
 */
40
void LMatrix3d::fill(double fill_value);

3161 3 set 0 4 3519 14 LMatrix3d::set 0 1 1444 10
/**
 *
 */
135
inline void LMatrix3d::set(double e00, double e01, double e02, double e10, double e11, double e12, double e20, double e21, double e22);

3162 11 operator [] 0 4 3519 22 LMatrix3d::operator [] 0 2 1445 1446 0
112
inline LMatrix3d::CRow LMatrix3d::operator [](int i) const;
inline LMatrix3d::Row LMatrix3d::operator [](int i);

3163 4 size 0 4 3519 15 LMatrix3d::size 0 1 1447 55
/**
 * Returns 3: the number of rows of a LMatrix3.
 */
40
static inline int LMatrix3d::size(void);

3164 7 set_row 0 4 3519 18 LMatrix3d::set_row 0 2 1448 1449 193
/**
 * Replaces the indicated row of the matrix from a three-component vector.
 */

/**
 * Replaces the indicated row of the matrix from a two-component vector,
 * ignoring the last column.
 */
123
inline void LMatrix3d::set_row(int row, LVecBase3d const &v);
inline void LMatrix3d::set_row(int row, LVecBase2d const &v);

3165 7 set_col 0 4 3519 18 LMatrix3d::set_col 0 2 1450 1451 196
/**
 * Replaces the indicated column of the matrix from a three-component vector.
 */

/**
 * Replaces the indicated column of the matrix from a two-component vector,
 * ignoring the last row.
 */
123
inline void LMatrix3d::set_col(int col, LVecBase3d const &v);
inline void LMatrix3d::set_col(int col, LVecBase2d const &v);

3166 7 get_row 0 4 3519 18 LMatrix3d::get_row 0 2 1452 1453 192
// these versions inline better

/**
 * Returns the indicated row of the matrix as a three-component vector.
 */

/**
 * Stores the indicated row of the matrix as a three-component vector.
 */
123
inline LVecBase3d LMatrix3d::get_row(int row) const;
inline void LMatrix3d::get_row(LVecBase3d &result_vec, int row) const;

3167 7 get_col 0 4 3519 18 LMatrix3d::get_col 0 1 1454 82
/**
 * Returns the indicated column of the matrix as a three-component vector.
 */
52
inline LVecBase3d LMatrix3d::get_col(int col) const;

3168 8 get_row2 0 4 3519 19 LMatrix3d::get_row2 0 1 1455 106
/**
 * Returns the indicated row of the matrix as a two-component vector, ignoring
 * the last column.
 */
53
inline LVecBase2d LMatrix3d::get_row2(int row) const;

3169 8 get_col2 0 4 3519 19 LMatrix3d::get_col2 0 1 1456 106
/**
 * Returns the indicated column of the matrix as a two-component vector,
 * ignoring the last row.
 */
53
inline LVecBase2d LMatrix3d::get_col2(int col) const;

3170 11 operator () 0 4 3519 22 LMatrix3d::operator () 0 2 1457 1458 10
/**
 *
 */
118
inline double &LMatrix3d::operator ()(int row, int col);
inline double LMatrix3d::operator ()(int row, int col) const;

3171 6 is_nan 0 4 3519 17 LMatrix3d::is_nan 0 1 1459 91
/**
 * Returns true if any component of the matrix is not-a-number, false
 * otherwise.
 */
42
inline bool LMatrix3d::is_nan(void) const;

3172 11 is_identity 0 4 3519 22 LMatrix3d::is_identity 0 1 1460 93
/**
 * Returns true if this is (close enough to) the identity matrix, false
 * otherwise.
 */
47
inline bool LMatrix3d::is_identity(void) const;

3173 8 get_cell 0 4 3519 19 LMatrix3d::get_cell 0 1 1461 54
/**
 * Returns a particular element of the matrix.
 */
58
inline double LMatrix3d::get_cell(int row, int col) const;

3174 8 set_cell 0 4 3519 19 LMatrix3d::set_cell 0 1 1462 54
/**
 * Changes a particular element of the matrix.
 */
64
inline void LMatrix3d::set_cell(int row, int col, double value);

3175 8 get_data 0 4 3519 19 LMatrix3d::get_data 0 1 1463 162
/**
 * Returns the address of the first of the nine data elements in the matrix.
 * The remaining elements occupy the next eight positions in row-major order.
 */
53
inline double const *LMatrix3d::get_data(void) const;

3176 18 get_num_components 0 4 3519 29 LMatrix3d::get_num_components 0 1 1464 62
/**
 * Returns the number of elements in the matrix, nine.
 */
53
inline int LMatrix3d::get_num_components(void) const;

3177 10 operator < 0 4 3519 21 LMatrix3d::operator < 0 1 1465 0
64
inline bool LMatrix3d::operator <(LMatrix3d const &other) const;

3178 11 operator == 0 4 3519 22 LMatrix3d::operator == 0 1 1466 0
65
inline bool LMatrix3d::operator ==(LMatrix3d const &other) const;

3179 11 operator != 0 4 3519 22 LMatrix3d::operator != 0 1 1467 0
65
inline bool LMatrix3d::operator !=(LMatrix3d const &other) const;

3180 10 compare_to 0 4 3519 21 LMatrix3d::compare_to 0 2 1468 1469 333
/**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */

/**
 * Sorts matrices lexicographically, componentwise.  Returns a number less
 * than 0 if this matrix sorts before the other one, greater than zero if it
 * sorts after, 0 if they are equivalent (within the indicated tolerance).
 */
138
inline int LMatrix3d::compare_to(LMatrix3d const &other) const;
int LMatrix3d::compare_to(LMatrix3d const &other, double threshold) const;

3181 8 get_hash 0 4 3519 19 LMatrix3d::get_hash 0 2 1470 1471 100
/**
 * Returns a suitable hash for phash_map.
 */

/**
 * Returns a suitable hash for phash_map.
 */
115
inline std::size_t LMatrix3d::get_hash(void) const;
inline std::size_t LMatrix3d::get_hash(double threshold) const;

3182 8 add_hash 0 4 3519 19 LMatrix3d::add_hash 0 2 1472 1473 100
/**
 * Adds the vector into the running hash.
 */

/**
 * Adds the vector into the running hash.
 */
145
inline std::size_t LMatrix3d::add_hash(std::size_t hash) const;
inline std::size_t LMatrix3d::add_hash(std::size_t hash, double threshold) const;

3183 5 xform 0 4 3519 16 LMatrix3d::xform 0 1 1474 52
/**
 * 3-component vector or point times matrix.
 */
62
inline LVecBase3d LMatrix3d::xform(LVecBase3d const &v) const;

3184 11 xform_point 0 4 3519 22 LMatrix3d::xform_point 0 1 1475 162
/**
 * The matrix transforms a 2-component point (including translation component)
 * and returns the result.  This assumes the matrix is an affine transform.
 */
68
inline LVecBase2d LMatrix3d::xform_point(LVecBase2d const &v) const;

3185 9 xform_vec 0 4 3519 20 LMatrix3d::xform_vec 0 2 1476 1477 357
/**
 * The matrix transforms a 2-component vector (without translation component)
 * and returns the result.  This assumes the matrix is an affine transform.
 */

/**
 * The matrix transforms a 3-component vector and returns the result.  This
 * assumes the matrix is an orthonormal transform.
 *
 * In practice, this is the same computation as xform().
 */
133
inline LVecBase2d LMatrix3d::xform_vec(LVecBase2d const &v) const;
inline LVecBase3d LMatrix3d::xform_vec(LVecBase3d const &v) const;

3186 17 xform_vec_general 0 4 3519 28 LMatrix3d::xform_vec_general 0 1 1478 142
/**
 * The matrix transforms a 3-component vector (without translation component)
 * and returns the result, as a fully general operation.
 */
74
inline LVecBase3d LMatrix3d::xform_vec_general(LVecBase3d const &v) const;

3187 14 xform_in_place 0 4 3519 25 LMatrix3d::xform_in_place 0 1 1479 52
/**
 * 3-component vector or point times matrix.
 */
59
inline void LMatrix3d::xform_in_place(LVecBase3d &v) const;

3188 20 xform_point_in_place 0 4 3519 31 LMatrix3d::xform_point_in_place 0 1 1480 139
/**
 * The matrix transforms a 2-component point (including translation
 * component).  This assumes the matrix is an affine transform.
 */
65
inline void LMatrix3d::xform_point_in_place(LVecBase2d &v) const;

3189 18 xform_vec_in_place 0 4 3519 29 LMatrix3d::xform_vec_in_place 0 2 1481 1482 310
/**
 * The matrix transforms a 2-component vector (without translation component).
 * This assumes the matrix is an affine transform.
 */

/**
 * The matrix transforms a 3-component vector.  This assumes the matrix is an
 * orthonormal transform.
 *
 * In practice, this is the same computation as xform().
 */
127
inline void LMatrix3d::xform_vec_in_place(LVecBase2d &v) const;
inline void LMatrix3d::xform_vec_in_place(LVecBase3d &v) const;

3190 26 xform_vec_general_in_place 0 4 3519 37 LMatrix3d::xform_vec_general_in_place 0 1 1483 119
/**
 * The matrix transforms a 3-component vector (without translation component),
 * as a fully general operation.
 */
71
inline void LMatrix3d::xform_vec_general_in_place(LVecBase3d &v) const;

3191 8 multiply 0 4 3519 19 LMatrix3d::multiply 0 1 1484 52
// this = other1 * other2

// this = other1 * other2
82
inline void LMatrix3d::multiply(LMatrix3d const &other1, LMatrix3d const &other2);

3192 10 operator * 0 4 3519 21 LMatrix3d::operator * 0 2 1485 1486 0
130
inline LMatrix3d LMatrix3d::operator *(LMatrix3d const &other) const;
inline LMatrix3d LMatrix3d::operator *(double scalar) const;

3193 10 operator / 0 4 3519 21 LMatrix3d::operator / 0 1 1487 0
60
inline LMatrix3d LMatrix3d::operator /(double scalar) const;

3194 11 operator += 0 4 3519 22 LMatrix3d::operator += 0 1 1488 63
/**
 * Performs a memberwise addition between two matrices.
 */
65
inline LMatrix3d &LMatrix3d::operator +=(LMatrix3d const &other);

3195 11 operator -= 0 4 3519 22 LMatrix3d::operator -= 0 1 1489 66
/**
 * Performs a memberwise subtraction between two matrices.
 */
65
inline LMatrix3d &LMatrix3d::operator -=(LMatrix3d const &other);

3196 11 operator *= 0 4 3519 22 LMatrix3d::operator *= 0 2 1490 1491 51
/**
 *
 */

/**
 * Performs a memberwise scale.
 */
122
inline LMatrix3d &LMatrix3d::operator *=(LMatrix3d const &other);
inline LMatrix3d &LMatrix3d::operator *=(double scalar);

3197 11 operator /= 0 4 3519 22 LMatrix3d::operator /= 0 1 1492 39
/**
 * Performs a memberwise scale.
 */
56
inline LMatrix3d &LMatrix3d::operator /=(double scalar);

3198 18 componentwise_mult 0 4 3519 29 LMatrix3d::componentwise_mult 0 1 1493 10
/**
 *
 */
66
inline void LMatrix3d::componentwise_mult(LMatrix3d const &other);

3199 11 determinant 0 4 3519 22 LMatrix3d::determinant 0 1 1494 49
/**
 * Returns the determinant of the matrix.
 */
49
inline double LMatrix3d::determinant(void) const;

3200 14 transpose_from 0 4 3519 25 LMatrix3d::transpose_from 0 1 1495 10
/**
 *
 */
62
inline void LMatrix3d::transpose_from(LMatrix3d const &other);

3201 18 transpose_in_place 0 4 3519 29 LMatrix3d::transpose_in_place 0 1 1496 10
/**
 *
 */
48
inline void LMatrix3d::transpose_in_place(void);

3202 11 invert_from 0 4 3519 22 LMatrix3d::invert_from 0 1 1497 463
/**
 * Computes the inverse of the other matrix, and stores the result in this
 * matrix.  This is a fully general operation and makes no assumptions about
 * the type of transform represented by the matrix.
 *
 * The other matrix must be a different object than this matrix.  However, if
 * you need to invert a matrix in place, see invert_in_place.
 *
 * The return value is true if the matrix was successfully inverted, false if
 * there was a singularity.
 */
59
inline bool LMatrix3d::invert_from(LMatrix3d const &other);

3203 15 invert_in_place 0 4 3519 26 LMatrix3d::invert_in_place 0 1 1498 119
/**
 * Inverts the current matrix.  Returns true if the inverse is successful,
 * false if the matrix was singular.
 */
45
inline bool LMatrix3d::invert_in_place(void);

3204 21 invert_transpose_from 0 4 3519 32 LMatrix3d::invert_transpose_from 0 2 1499 1500 230
/**
 * Simultaneously computes the inverse of the indicated matrix, and then the
 * transpose of that inverse.
 */

/**
 * Simultaneously computes the inverse of the indicated matrix, and then the
 * transpose of that inverse.
 */
139
inline bool LMatrix3d::invert_transpose_from(LMatrix3d const &other);
inline bool LMatrix3d::invert_transpose_from(LMatrix4d const &other);

3205 9 ident_mat 0 4 3519 20 LMatrix3d::ident_mat 0 1 1501 147
/**
 * Returns an identity matrix.
 *
 * This function definition must appear first, since some inline functions
 * below take advantage of it.
 */
58
static inline LMatrix3d const &LMatrix3d::ident_mat(void);

3206 17 set_translate_mat 0 4 3519 28 LMatrix3d::set_translate_mat 0 1 1502 74
/**
 * Fills mat with a matrix that applies the indicated translation.
 */
66
inline void LMatrix3d::set_translate_mat(LVecBase2d const &trans);

3207 14 set_rotate_mat 0 4 3519 25 LMatrix3d::set_rotate_mat 0 2 1503 1504 225
/**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise.
 */

/**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */
158
inline void LMatrix3d::set_rotate_mat(double angle);
void LMatrix3d::set_rotate_mat(double angle, LVecBase3d const &axis, CoordinateSystem cs = ::CS_default);

3208 13 set_scale_mat 0 4 3519 24 LMatrix3d::set_scale_mat 0 2 1505 1506 194
/**
 * Fills mat with a matrix that applies the indicated scale in each of the two
 * axes.
 */

/**
 * Fills mat with a matrix that applies the indicated scale in each of the
 * three axes.
 */
125
inline void LMatrix3d::set_scale_mat(LVecBase2d const &scale);
inline void LMatrix3d::set_scale_mat(LVecBase3d const &scale);

3209 13 translate_mat 0 4 3519 24 LMatrix3d::translate_mat 0 2 1507 1508 136
/**
 * Returns a matrix that applies the indicated translation.
 */

/**
 * Returns a matrix that applies the indicated translation.
 */
146
static inline LMatrix3d LMatrix3d::translate_mat(LVecBase2d const &trans);
static inline LMatrix3d LMatrix3d::translate_mat(double tx, double ty);

3210 10 rotate_mat 0 4 3519 21 LMatrix3d::rotate_mat 0 2 1509 1510 211
/**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise.
 */

/**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */
181
static inline LMatrix3d LMatrix3d::rotate_mat(double angle);
static inline LMatrix3d LMatrix3d::rotate_mat(double angle, LVecBase3d const &axis, CoordinateSystem cs = ::CS_default);

3211 9 scale_mat 0 4 3519 20 LMatrix3d::scale_mat 0 4 1511 1512 1513 1514 356
/**
 * Returns a matrix that applies the indicated scale in each of the two axes.
 */

/**
 * Returns a matrix that applies the indicated scale in each of the two axes.
 */

/**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */

/**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */
288
static inline LMatrix3d LMatrix3d::scale_mat(LVecBase2d const &scale);
static inline LMatrix3d LMatrix3d::scale_mat(double sx, double sy);
static inline LMatrix3d LMatrix3d::scale_mat(LVecBase3d const &scale);
static inline LMatrix3d LMatrix3d::scale_mat(double sx, double sy, double sz);

3212 23 set_rotate_mat_normaxis 0 4 3519 34 LMatrix3d::set_rotate_mat_normaxis 0 1 1515 163
/**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * normalized.
 */
114
void LMatrix3d::set_rotate_mat_normaxis(double angle, LVecBase3d const &axis, CoordinateSystem cs = ::CS_default);

3213 19 rotate_mat_normaxis 0 4 3519 30 LMatrix3d::rotate_mat_normaxis 0 1 1516 156
/**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * normalized.
 */
129
static inline LMatrix3d LMatrix3d::rotate_mat_normaxis(double angle, LVecBase3d const &axis, CoordinateSystem cs = ::CS_default);

3214 13 set_shear_mat 0 4 3519 24 LMatrix3d::set_shear_mat 0 1 1517 99
/**
 * Fills mat with a matrix that applies the indicated shear in each of the
 * three planes.
 */
98
inline void LMatrix3d::set_shear_mat(LVecBase3d const &shear, CoordinateSystem cs = ::CS_default);

3215 9 shear_mat 0 4 3519 20 LMatrix3d::shear_mat 0 2 1518 1519 186
/**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */

/**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */
227
static inline LMatrix3d LMatrix3d::shear_mat(LVecBase3d const &shear, CoordinateSystem cs = ::CS_default);
static inline LMatrix3d LMatrix3d::shear_mat(double shxy, double shxz, double shyz, CoordinateSystem cs = ::CS_default);

3216 19 set_scale_shear_mat 0 4 3519 30 LMatrix3d::set_scale_shear_mat 0 1 1520 78
/**
 * Fills mat with a matrix that applies the indicated scale and shear.
 */
122
void LMatrix3d::set_scale_shear_mat(LVecBase3d const &scale, LVecBase3d const &shear, CoordinateSystem cs = ::CS_default);

3217 15 scale_shear_mat 0 4 3519 26 LMatrix3d::scale_shear_mat 0 2 1521 1522 144
/**
 * Returns a matrix that applies the indicated scale and shear.
 */

/**
 * Returns a matrix that applies the indicated scale and shear.
 */
297
static inline LMatrix3d LMatrix3d::scale_shear_mat(LVecBase3d const &scale, LVecBase3d const &shear, CoordinateSystem cs = ::CS_default);
static inline LMatrix3d LMatrix3d::scale_shear_mat(double sx, double sy, double sz, double shxy, double shxz, double shyz, CoordinateSystem cs = ::CS_default);

3218 11 convert_mat 0 4 3519 22 LMatrix3d::convert_mat 0 1 1523 119
/**
 * Returns a matrix that transforms from the indicated coordinate system to
 * the indicated coordinate system.
 */
91
static LMatrix3d const &LMatrix3d::convert_mat(CoordinateSystem from, CoordinateSystem to);

3219 12 almost_equal 0 4 3519 23 LMatrix3d::almost_equal 0 2 1524 1525 212
/**
 * Returns true if two matrices are memberwise equal within a default
 * tolerance based on the numeric type.
 */

/**
 * Returns true if two matrices are memberwise equal within a specified
 * tolerance.
 */
144
bool LMatrix3d::almost_equal(LMatrix3d const &other, double threshold) const;
inline bool LMatrix3d::almost_equal(LMatrix3d const &other) const;

3220 6 output 0 4 3519 17 LMatrix3d::output 0 1 1526 10
/**
 *
 */
43
void LMatrix3d::output(ostream &out) const;

3221 5 write 0 4 3519 16 LMatrix3d::write 0 1 1527 10
/**
 *
 */
64
void LMatrix3d::write(ostream &out, int indent_level = 0) const;

3222 8 __repr__ 0 4 3519 19 LMatrix3d::__repr__ 0 1 1528 0
51
inline std::string LMatrix3d::__repr__(void) const;

3223 13 generate_hash 0 4 3519 24 LMatrix3d::generate_hash 0 2 1529 1530 120
/**
 * Adds the vector to the indicated hash generator.
 */

/**
 * Adds the vector to the indicated hash generator.
 */
162
inline void LMatrix3d::generate_hash(ChecksumHashGenerator &hashgen) const;
void LMatrix3d::generate_hash(ChecksumHashGenerator &hashgen, double threshold) const;

3224 20 write_datagram_fixed 0 4 3519 31 LMatrix3d::write_datagram_fixed 0 1 1531 332
/**
 * Writes the matrix to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the matrix, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */
66
void LMatrix3d::write_datagram_fixed(Datagram &destination) const;

3225 19 read_datagram_fixed 0 4 3519 30 LMatrix3d::read_datagram_fixed 0 1 1532 114
/**
 * Reads the matrix from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */
60
void LMatrix3d::read_datagram_fixed(DatagramIterator &scan);

3226 14 write_datagram 0 4 3519 25 LMatrix3d::write_datagram 0 1 1533 205
/**
 * Writes the matrix to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the matrix using the standard width
 * setting, especially when you are writing a bam file.
 */
60
void LMatrix3d::write_datagram(Datagram &destination) const;

3227 13 read_datagram 0 4 3519 24 LMatrix3d::read_datagram 0 1 1534 67
/**
 * Reads the matrix from the Datagram using get_stdfloat().
 */
56
void LMatrix3d::read_datagram(DatagramIterator &source);

3228 14 get_class_type 0 4 3519 25 LMatrix3d::get_class_type 0 1 1535 0
50
static TypeHandle LMatrix3d::get_class_type(void);

3229 10 ~LMatrix3d 0 4 3519 21 LMatrix3d::~LMatrix3d 0 0 0
28
LMatrix3d::~LMatrix3d(void);

3230 11 operator [] 0 4 3525 27 LMatrix4d::Row::operator [] 0 2 1654 1655 10
/**
 *
 */
106
inline double LMatrix4d::Row::operator [](int i) const;
inline double &LMatrix4d::Row::operator [](int i);

3231 4 size 0 4 3525 20 LMatrix4d::Row::size 0 1 1656 58
/**
 * Returns 4: the number of columns of a LMatrix4.
 */
45
static inline int LMatrix4d::Row::size(void);

3232 3 Row 0 4 3525 19 LMatrix4d::Row::Row 0 1 1653 60
/**
 * Defines a row-level index accessor to the matrix.
 */
61
inline LMatrix4d::Row::Row(LMatrix4d::Row const &) = default;

3233 4 ~Row 0 4 3525 20 LMatrix4d::Row::~Row 0 0 0
27
LMatrix4d::Row::~Row(void);

3234 11 operator [] 0 4 3526 28 LMatrix4d::CRow::operator [] 0 1 1658 0
56
inline double LMatrix4d::CRow::operator [](int i) const;

3235 4 size 0 4 3526 21 LMatrix4d::CRow::size 0 1 1659 58
/**
 * Returns 4: the number of columns of a LMatrix4.
 */
46
static inline int LMatrix4d::CRow::size(void);

3236 4 CRow 0 4 3526 21 LMatrix4d::CRow::CRow 0 1 1657 63
/**
 * Defines a row-level constant accessor to the matrix.
 */
64
inline LMatrix4d::CRow::CRow(LMatrix4d::CRow const &) = default;

3237 5 ~CRow 0 4 3526 22 LMatrix4d::CRow::~CRow 0 0 0
29
LMatrix4d::CRow::~CRow(void);

3238 9 LMatrix4d 0 4 3523 20 LMatrix4d::LMatrix4d 0 6 1543 1544 1545 1546 1547 1548 167
// Construct a 4x4 matrix given a 3x3 rotation matrix and an optional
// translation component.

/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
503
inline LMatrix4d::LMatrix4d(void);
inline LMatrix4d::LMatrix4d(LMatrix4d const &other);
inline LMatrix4d::LMatrix4d(UnalignedLMatrix4d const &other);
inline LMatrix4d::LMatrix4d(double e00, double e01, double e02, double e03, double e10, double e11, double e12, double e13, double e20, double e21, double e22, double e23, double e30, double e31, double e32, double e33);
inline LMatrix4d::LMatrix4d(LMatrix3d const &upper3);
inline LMatrix4d::LMatrix4d(LMatrix3d const &upper3, LVecBase3d const &trans);

3239 10 operator = 0 4 3523 21 LMatrix4d::operator = 0 3 1549 1550 1551 34
/**
 *
 */

/**
 *
 */

/**
 *
 */
198
inline LMatrix4d &LMatrix4d::operator =(LMatrix4d const &other);
inline LMatrix4d &LMatrix4d::operator =(UnalignedLMatrix4d const &other);
inline LMatrix4d &LMatrix4d::operator =(double fill_value);

3240 12 operator new 0 4 3523 23 LMatrix4d::operator new 0 1 1552 0
122
inline void *LMatrix4d::operator new(std::size_t size);
inline void *LMatrix4d::operator new(std::size_t size, void *ptr);

3241 15 operator delete 0 4 3523 26 LMatrix4d::operator delete 0 0 0
106
inline void LMatrix4d::operator delete(void *ptr);
inline void LMatrix4d::operator delete(void *, void *);

3242 12 validate_ptr 0 4 3523 23 LMatrix4d::validate_ptr 0 0 0
60
static inline bool LMatrix4d::validate_ptr(void const *ptr);

3243 10 __reduce__ 0 4 3523 21 LMatrix4d::__reduce__ 0 1 1553 0
61
inline PyObject *LMatrix4d::__reduce__(PyObject *self) const;

3244 4 fill 0 4 3523 15 LMatrix4d::fill 0 1 1554 157
/**
 * Sets each element of the matrix to the indicated fill_value.  This is of
 * questionable value, but is sometimes useful when initializing to zero.
 */
47
inline void LMatrix4d::fill(double fill_value);

3245 3 set 0 4 3523 14 LMatrix4d::set 0 1 1555 10
/**
 *
 */
219
inline void LMatrix4d::set(double e00, double e01, double e02, double e03, double e10, double e11, double e12, double e13, double e20, double e21, double e22, double e23, double e30, double e31, double e32, double e33);

3246 11 set_upper_3 0 4 3523 22 LMatrix4d::set_upper_3 0 1 1556 87
// Get and set the upper 3x3 rotation matrix.

/**
 * Sets the upper 3x3 submatrix.
 */
60
inline void LMatrix4d::set_upper_3(LMatrix3d const &upper3);

3247 11 get_upper_3 0 4 3523 22 LMatrix4d::get_upper_3 0 1 1557 45
/**
 * Retrieves the upper 3x3 submatrix.
 */
52
inline LMatrix3d LMatrix4d::get_upper_3(void) const;

3248 11 operator [] 0 4 3523 22 LMatrix4d::operator [] 0 2 1558 1559 0
112
inline LMatrix4d::CRow LMatrix4d::operator [](int i) const;
inline LMatrix4d::Row LMatrix4d::operator [](int i);

3249 4 size 0 4 3523 15 LMatrix4d::size 0 1 1560 55
/**
 * Returns 4: the number of rows of a LMatrix4.
 */
40
static inline int LMatrix4d::size(void);

3250 7 set_row 0 4 3523 18 LMatrix4d::set_row 0 2 1561 1562 173
/**
 * Replaces the indicated row of the matrix.
 */

/**
 * Replaces the indicated row of the matrix with the indicated 3-component
 * vector, ignoring the last column.
 */
123
inline void LMatrix4d::set_row(int row, LVecBase4d const &v);
inline void LMatrix4d::set_row(int row, LVecBase3d const &v);

3251 7 set_col 0 4 3523 18 LMatrix4d::set_col 0 2 1563 1564 176
/**
 * Replaces the indicated column of the matrix.
 */

/**
 * Replaces the indicated column of the matrix with the indicated 3-component
 * vector, ignoring the last row.
 */
123
inline void LMatrix4d::set_col(int col, LVecBase4d const &v);
inline void LMatrix4d::set_col(int col, LVecBase3d const &v);

3252 7 get_row 0 4 3523 18 LMatrix4d::get_row 0 2 1565 1566 186
// these versions inline better

/**
 * Retrieves the indicated row of the matrix as a 4-component vector.
 */

/**
 * Stores the indicated row of the matrix as a 4-component vector.
 */
123
inline LVecBase4d LMatrix4d::get_row(int row) const;
inline void LMatrix4d::get_row(LVecBase4d &result_vec, int row) const;

3253 7 get_col 0 4 3523 18 LMatrix4d::get_col 0 1 1567 80
/**
 * Retrieves the indicated column of the matrix as a 4-component vector.
 */
52
inline LVecBase4d LMatrix4d::get_col(int col) const;

3254 8 get_row3 0 4 3523 19 LMatrix4d::get_row3 0 2 1568 1569 205
/**
 * Retrieves the row column of the matrix as a 3-component vector, ignoring
 * the last column.
 */

/**
 * Stores the row column of the matrix as a 3-component vector, ignoring the
 * last column.
 */
125
inline LVecBase3d LMatrix4d::get_row3(int row) const;
inline void LMatrix4d::get_row3(LVecBase3d &result_vec, int row) const;

3255 8 get_col3 0 4 3523 19 LMatrix4d::get_col3 0 1 1570 106
/**
 * Retrieves the indicated column of the matrix as a 3-component vector,
 * ignoring the last row.
 */
53
inline LVecBase3d LMatrix4d::get_col3(int col) const;

3256 11 operator () 0 4 3523 22 LMatrix4d::operator () 0 2 1571 1572 10
/**
 *
 */
118
inline double &LMatrix4d::operator ()(int row, int col);
inline double LMatrix4d::operator ()(int row, int col) const;

3257 6 is_nan 0 4 3523 17 LMatrix4d::is_nan 0 1 1573 91
/**
 * Returns true if any component of the matrix is not-a-number, false
 * otherwise.
 */
42
inline bool LMatrix4d::is_nan(void) const;

3258 11 is_identity 0 4 3523 22 LMatrix4d::is_identity 0 1 1574 93
/**
 * Returns true if this is (close enough to) the identity matrix, false
 * otherwise.
 */
47
inline bool LMatrix4d::is_identity(void) const;

3259 8 get_cell 0 4 3523 19 LMatrix4d::get_cell 0 1 1575 54
/**
 * Returns a particular element of the matrix.
 */
58
inline double LMatrix4d::get_cell(int row, int col) const;

3260 8 set_cell 0 4 3523 19 LMatrix4d::set_cell 0 1 1576 54
/**
 * Changes a particular element of the matrix.
 */
64
inline void LMatrix4d::set_cell(int row, int col, double value);

3261 8 get_data 0 4 3523 19 LMatrix4d::get_data 0 1 1577 162
/**
 * Returns the address of the first of the nine data elements in the matrix.
 * The remaining elements occupy the next eight positions in row-major order.
 */
53
inline double const *LMatrix4d::get_data(void) const;

3262 18 get_num_components 0 4 3523 29 LMatrix4d::get_num_components 0 1 1578 60
/**
 * Returns the number of elements in the matrix, 16.
 */
53
inline int LMatrix4d::get_num_components(void) const;

3263 5 begin 0 4 3523 16 LMatrix4d::begin 0 2 1579 1580 204
/**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */

/**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */
113
inline LMatrix4d::iterator LMatrix4d::begin(void);
inline LMatrix4d::const_iterator LMatrix4d::begin(void) const;

3264 3 end 0 4 3523 14 LMatrix4d::end 0 2 1581 1582 204
/**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */

/**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */
109
inline LMatrix4d::iterator LMatrix4d::end(void);
inline LMatrix4d::const_iterator LMatrix4d::end(void) const;

3265 10 operator < 0 4 3523 21 LMatrix4d::operator < 0 1 1583 0
64
inline bool LMatrix4d::operator <(LMatrix4d const &other) const;

3266 11 operator == 0 4 3523 22 LMatrix4d::operator == 0 1 1584 0
65
inline bool LMatrix4d::operator ==(LMatrix4d const &other) const;

3267 11 operator != 0 4 3523 22 LMatrix4d::operator != 0 1 1585 0
65
inline bool LMatrix4d::operator !=(LMatrix4d const &other) const;

3268 10 compare_to 0 4 3523 21 LMatrix4d::compare_to 0 2 1586 1587 333
/**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */

/**
 * Sorts matrices lexicographically, componentwise.  Returns a number less
 * than 0 if this matrix sorts before the other one, greater than zero if it
 * sorts after, 0 if they are equivalent (within the indicated tolerance).
 */
138
inline int LMatrix4d::compare_to(LMatrix4d const &other) const;
int LMatrix4d::compare_to(LMatrix4d const &other, double threshold) const;

3269 8 get_hash 0 4 3523 19 LMatrix4d::get_hash 0 2 1588 1589 100
/**
 * Returns a suitable hash for phash_map.
 */

/**
 * Returns a suitable hash for phash_map.
 */
115
inline std::size_t LMatrix4d::get_hash(void) const;
inline std::size_t LMatrix4d::get_hash(double threshold) const;

3270 8 add_hash 0 4 3523 19 LMatrix4d::add_hash 0 2 1590 1591 100
/**
 * Adds the vector into the running hash.
 */

/**
 * Adds the vector into the running hash.
 */
145
inline std::size_t LMatrix4d::add_hash(std::size_t hash) const;
inline std::size_t LMatrix4d::add_hash(std::size_t hash, double threshold) const;

3271 5 xform 0 4 3523 16 LMatrix4d::xform 0 1 1592 91
/**
 * 4-component vector or point times matrix.  This is a fully general
 * operation.
 */
62
inline LVecBase4d LMatrix4d::xform(LVecBase4d const &v) const;

3272 11 xform_point 0 4 3523 22 LMatrix4d::xform_point 0 1 1593 162
/**
 * The matrix transforms a 3-component point (including translation component)
 * and returns the result.  This assumes the matrix is an affine transform.
 */
68
inline LVecBase3d LMatrix4d::xform_point(LVecBase3d const &v) const;

3273 19 xform_point_general 0 4 3523 30 LMatrix4d::xform_point_general 0 1 1594 143
/**
 * The matrix transforms a 3-component point (including translation component)
 * and returns the result, as a fully general operation.
 */
76
inline LVecBase3d LMatrix4d::xform_point_general(LVecBase3d const &v) const;

3274 9 xform_vec 0 4 3523 20 LMatrix4d::xform_vec 0 1 1595 169
/**
 * The matrix transforms a 3-component vector (without translation component)
 * and returns the result.  This assumes the matrix is an orthonormal
 * transform.
 */
66
inline LVecBase3d LMatrix4d::xform_vec(LVecBase3d const &v) const;

3275 17 xform_vec_general 0 4 3523 28 LMatrix4d::xform_vec_general 0 1 1596 142
/**
 * The matrix transforms a 3-component vector (without translation component)
 * and returns the result, as a fully general operation.
 */
74
inline LVecBase3d LMatrix4d::xform_vec_general(LVecBase3d const &v) const;

3276 14 xform_in_place 0 4 3523 25 LMatrix4d::xform_in_place 0 1 1597 91
/**
 * 4-component vector or point times matrix.  This is a fully general
 * operation.
 */
59
inline void LMatrix4d::xform_in_place(LVecBase4d &v) const;

3277 20 xform_point_in_place 0 4 3523 31 LMatrix4d::xform_point_in_place 0 1 1598 139
/**
 * The matrix transforms a 3-component point (including translation
 * component).  This assumes the matrix is an affine transform.
 */
65
inline void LMatrix4d::xform_point_in_place(LVecBase3d &v) const;

3278 28 xform_point_general_in_place 0 4 3523 39 LMatrix4d::xform_point_general_in_place 0 1 1599 120
/**
 * The matrix transforms a 3-component point (including translation
 * component), as a fully general operation.
 */
73
inline void LMatrix4d::xform_point_general_in_place(LVecBase3d &v) const;

3279 18 xform_vec_in_place 0 4 3523 29 LMatrix4d::xform_vec_in_place 0 1 1600 142
/**
 * The matrix transforms a 3-component vector (without translation component).
 * This assumes the matrix is an orthonormal transform.
 */
63
inline void LMatrix4d::xform_vec_in_place(LVecBase3d &v) const;

3280 26 xform_vec_general_in_place 0 4 3523 37 LMatrix4d::xform_vec_general_in_place 0 1 1601 119
/**
 * The matrix transforms a 3-component vector (without translation component),
 * as a fully general operation.
 */
71
inline void LMatrix4d::xform_vec_general_in_place(LVecBase3d &v) const;

3281 8 multiply 0 4 3523 19 LMatrix4d::multiply 0 1 1602 52
// this = other1 * other2

// this = other1 * other2
82
inline void LMatrix4d::multiply(LMatrix4d const &other1, LMatrix4d const &other2);

3282 10 operator * 0 4 3523 21 LMatrix4d::operator * 0 2 1603 1604 0
130
inline LMatrix4d LMatrix4d::operator *(LMatrix4d const &other) const;
inline LMatrix4d LMatrix4d::operator *(double scalar) const;

3283 10 operator / 0 4 3523 21 LMatrix4d::operator / 0 1 1605 0
60
inline LMatrix4d LMatrix4d::operator /(double scalar) const;

3284 11 operator += 0 4 3523 22 LMatrix4d::operator += 0 1 1606 63
/**
 * Performs a memberwise addition between two matrices.
 */
65
inline LMatrix4d &LMatrix4d::operator +=(LMatrix4d const &other);

3285 11 operator -= 0 4 3523 22 LMatrix4d::operator -= 0 1 1607 63
/**
 * Performs a memberwise addition between two matrices.
 */
65
inline LMatrix4d &LMatrix4d::operator -=(LMatrix4d const &other);

3286 11 operator *= 0 4 3523 22 LMatrix4d::operator *= 0 2 1608 1609 22
/**
 *
 */

/**
 *
 */
122
inline LMatrix4d &LMatrix4d::operator *=(LMatrix4d const &other);
inline LMatrix4d &LMatrix4d::operator *=(double scalar);

3287 11 operator /= 0 4 3523 22 LMatrix4d::operator /= 0 1 1610 10
/**
 *
 */
56
inline LMatrix4d &LMatrix4d::operator /=(double scalar);

3288 18 componentwise_mult 0 4 3523 29 LMatrix4d::componentwise_mult 0 1 1611 10
/**
 *
 */
66
inline void LMatrix4d::componentwise_mult(LMatrix4d const &other);

3289 14 transpose_from 0 4 3523 25 LMatrix4d::transpose_from 0 1 1612 10
/**
 *
 */
62
inline void LMatrix4d::transpose_from(LMatrix4d const &other);

3290 18 transpose_in_place 0 4 3523 29 LMatrix4d::transpose_in_place 0 1 1613 10
/**
 *
 */
48
inline void LMatrix4d::transpose_in_place(void);

3291 11 invert_from 0 4 3523 22 LMatrix4d::invert_from 0 1 1614 461
/**
 * Computes the inverse of the other matrix, and stores the result in this
 * matrix.  This is a fully general operation and makes no assumptions about
 * the type of transform represented by the matrix.
 *
 * The other matrix must be a different object than this matrix.  However, if
 * you need to invert a matrix in place, see invert_in_place.
 *
 * The return value is true if the matrix was successfully inverted, false if
 * the was a singularity.
 */
59
inline bool LMatrix4d::invert_from(LMatrix4d const &other);

3292 18 invert_affine_from 0 4 3523 29 LMatrix4d::invert_affine_from 0 1 1615 139
// bugbug: we could optimize this for rotationscaletranslation matrices
// (transpose upper 3x3 and take negative of translation component)
66
inline bool LMatrix4d::invert_affine_from(LMatrix4d const &other);

3293 15 invert_in_place 0 4 3523 26 LMatrix4d::invert_in_place 0 1 1616 119
/**
 * Inverts the current matrix.  Returns true if the inverse is successful,
 * false if the matrix was singular.
 */
45
inline bool LMatrix4d::invert_in_place(void);

3294 10 accumulate 0 4 3523 21 LMatrix4d::accumulate 0 1 1617 46
/**
 * Computes (*this) += other * weight.
 */
73
inline void LMatrix4d::accumulate(LMatrix4d const &other, double weight);

3295 9 ident_mat 0 4 3523 20 LMatrix4d::ident_mat 0 1 1618 147
/**
 * Returns an identity matrix.
 *
 * This function definition must appear first, since some inline functions
 * below take advantage of it.
 */
58
static inline LMatrix4d const &LMatrix4d::ident_mat(void);

3296 8 ones_mat 0 4 3523 19 LMatrix4d::ones_mat 0 1 1619 46
/**
 * Returns an matrix filled with ones.
 */
57
static inline LMatrix4d const &LMatrix4d::ones_mat(void);

3297 9 zeros_mat 0 4 3523 20 LMatrix4d::zeros_mat 0 1 1620 47
/**
 * Returns an matrix filled with zeros.
 */
58
static inline LMatrix4d const &LMatrix4d::zeros_mat(void);

3298 17 set_translate_mat 0 4 3523 28 LMatrix4d::set_translate_mat 0 1 1621 74
/**
 * Fills mat with a matrix that applies the indicated translation.
 */
66
inline void LMatrix4d::set_translate_mat(LVecBase3d const &trans);

3299 14 set_rotate_mat 0 4 3523 25 LMatrix4d::set_rotate_mat 0 1 1622 122
/**
 * Sets mat to a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */
105
void LMatrix4d::set_rotate_mat(double angle, LVecBase3d const &axis, CoordinateSystem cs = ::CS_default);

3300 23 set_rotate_mat_normaxis 0 4 3523 34 LMatrix4d::set_rotate_mat_normaxis 0 1 1623 166
/**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * prenormalized.
 */
114
void LMatrix4d::set_rotate_mat_normaxis(double angle, LVecBase3d const &axis, CoordinateSystem cs = ::CS_default);

3301 13 set_scale_mat 0 4 3523 24 LMatrix4d::set_scale_mat 0 1 1624 97
/**
 * Fills mat with a matrix that applies the indicated scale in each of the
 * three axes.
 */
62
inline void LMatrix4d::set_scale_mat(LVecBase3d const &scale);

3302 13 set_shear_mat 0 4 3523 24 LMatrix4d::set_shear_mat 0 1 1625 99
/**
 * Fills mat with a matrix that applies the indicated shear in each of the
 * three planes.
 */
98
inline void LMatrix4d::set_shear_mat(LVecBase3d const &shear, CoordinateSystem cs = ::CS_default);

3303 19 set_scale_shear_mat 0 4 3523 30 LMatrix4d::set_scale_shear_mat 0 1 1626 78
/**
 * Fills mat with a matrix that applies the indicated scale and shear.
 */
129
inline void LMatrix4d::set_scale_shear_mat(LVecBase3d const &scale, LVecBase3d const &shear, CoordinateSystem cs = ::CS_default);

3304 13 translate_mat 0 4 3523 24 LMatrix4d::translate_mat 0 2 1627 1628 136
/**
 * Returns a matrix that applies the indicated translation.
 */

/**
 * Returns a matrix that applies the indicated translation.
 */
157
static inline LMatrix4d LMatrix4d::translate_mat(LVecBase3d const &trans);
static inline LMatrix4d LMatrix4d::translate_mat(double tx, double ty, double tz);

3305 10 rotate_mat 0 4 3523 21 LMatrix4d::rotate_mat 0 1 1629 118
/**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */
120
static inline LMatrix4d LMatrix4d::rotate_mat(double angle, LVecBase3d const &axis, CoordinateSystem cs = ::CS_default);

3306 19 rotate_mat_normaxis 0 4 3523 30 LMatrix4d::rotate_mat_normaxis 0 1 1630 159
/**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * prenormalized.
 */
129
static inline LMatrix4d LMatrix4d::rotate_mat_normaxis(double angle, LVecBase3d const &axis, CoordinateSystem cs = ::CS_default);

3307 9 scale_mat 0 4 3523 20 LMatrix4d::scale_mat 0 3 1631 1632 1633 253
/**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */

/**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */

/**
 * Returns a matrix that applies the indicated uniform scale.
 */
209
static inline LMatrix4d LMatrix4d::scale_mat(LVecBase3d const &scale);
static inline LMatrix4d LMatrix4d::scale_mat(double sx, double sy, double sz);
static inline LMatrix4d LMatrix4d::scale_mat(double scale);

3308 9 shear_mat 0 4 3523 20 LMatrix4d::shear_mat 0 2 1634 1635 186
/**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */

/**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */
227
static inline LMatrix4d LMatrix4d::shear_mat(LVecBase3d const &shear, CoordinateSystem cs = ::CS_default);
static inline LMatrix4d LMatrix4d::shear_mat(double shxy, double shxz, double shyz, CoordinateSystem cs = ::CS_default);

3309 15 scale_shear_mat 0 4 3523 26 LMatrix4d::scale_shear_mat 0 2 1636 1637 144
/**
 * Returns a matrix that applies the indicated scale and shear.
 */

/**
 * Returns a matrix that applies the indicated scale and shear.
 */
297
static inline LMatrix4d LMatrix4d::scale_shear_mat(LVecBase3d const &scale, LVecBase3d const &shear, CoordinateSystem cs = ::CS_default);
static inline LMatrix4d LMatrix4d::scale_shear_mat(double sx, double sy, double sz, double shxy, double shxz, double shyz, CoordinateSystem cs = ::CS_default);

3310 13 y_to_z_up_mat 0 4 3523 24 LMatrix4d::y_to_z_up_mat 0 1 1638 109
/**
 * Returns a matrix that transforms from the Y-up coordinate system to the
 * Z-up coordinate system.
 */
62
static inline LMatrix4d const &LMatrix4d::y_to_z_up_mat(void);

3311 13 z_to_y_up_mat 0 4 3523 24 LMatrix4d::z_to_y_up_mat 0 1 1639 109
/**
 * Returns a matrix that transforms from the Y-up coordinate system to the
 * Z-up coordinate system.
 */
62
static inline LMatrix4d const &LMatrix4d::z_to_y_up_mat(void);

3312 11 convert_mat 0 4 3523 22 LMatrix4d::convert_mat 0 1 1640 119
/**
 * Returns a matrix that transforms from the indicated coordinate system to
 * the indicated coordinate system.
 */
91
static LMatrix4d const &LMatrix4d::convert_mat(CoordinateSystem from, CoordinateSystem to);

3313 12 almost_equal 0 4 3523 23 LMatrix4d::almost_equal 0 2 1641 1642 318
/**
 * Returns true if two matrices are memberwise equal within a default
 * tolerance based on the numeric type.
 */

/**
 * Returns true if two matrices are memberwise equal within a specified
 * tolerance.  This is faster than the equivalence operator as this doesn't
 * have to guarantee that it is transitive.
 */
144
bool LMatrix4d::almost_equal(LMatrix4d const &other, double threshold) const;
inline bool LMatrix4d::almost_equal(LMatrix4d const &other) const;

3314 6 output 0 4 3523 17 LMatrix4d::output 0 1 1643 10
/**
 *
 */
43
void LMatrix4d::output(ostream &out) const;

3315 5 write 0 4 3523 16 LMatrix4d::write 0 1 1644 10
/**
 *
 */
64
void LMatrix4d::write(ostream &out, int indent_level = 0) const;

3316 8 __repr__ 0 4 3523 19 LMatrix4d::__repr__ 0 1 1645 0
51
inline std::string LMatrix4d::__repr__(void) const;

3317 13 generate_hash 0 4 3523 24 LMatrix4d::generate_hash 0 2 1646 1647 120
/**
 * Adds the vector to the indicated hash generator.
 */

/**
 * Adds the vector to the indicated hash generator.
 */
158
inline void LMatrix4d::generate_hash(ChecksumHashGenerator &hashgen) const;
void LMatrix4d::generate_hash(ChecksumHashGenerator &hashgen, double scale) const;

3318 20 write_datagram_fixed 0 4 3523 31 LMatrix4d::write_datagram_fixed 0 1 1648 332
/**
 * Writes the matrix to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the matrix, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */
66
void LMatrix4d::write_datagram_fixed(Datagram &destination) const;

3319 19 read_datagram_fixed 0 4 3523 30 LMatrix4d::read_datagram_fixed 0 1 1649 114
/**
 * Reads the matrix from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */
60
void LMatrix4d::read_datagram_fixed(DatagramIterator &scan);

3320 14 write_datagram 0 4 3523 25 LMatrix4d::write_datagram 0 1 1650 205
/**
 * Writes the matrix to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the matrix using the standard width
 * setting, especially when you are writing a bam file.
 */
60
void LMatrix4d::write_datagram(Datagram &destination) const;

3321 13 read_datagram 0 4 3523 24 LMatrix4d::read_datagram 0 1 1651 67
/**
 * Reads the matrix from the Datagram using get_stdfloat().
 */
56
void LMatrix4d::read_datagram(DatagramIterator &source);

3322 14 get_class_type 0 4 3523 25 LMatrix4d::get_class_type 0 1 1652 0
50
static TypeHandle LMatrix4d::get_class_type(void);

3323 10 ~LMatrix4d 0 4 3523 21 LMatrix4d::~LMatrix4d 0 0 0
28
LMatrix4d::~LMatrix4d(void);

3324 18 UnalignedLMatrix4d 0 4 3527 38 UnalignedLMatrix4d::UnalignedLMatrix4d 0 4 1660 1661 1662 1663 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
440
inline UnalignedLMatrix4d::UnalignedLMatrix4d(void);
inline UnalignedLMatrix4d::UnalignedLMatrix4d(LMatrix4d const &copy);
inline UnalignedLMatrix4d::UnalignedLMatrix4d(UnalignedLMatrix4d const &copy);
inline UnalignedLMatrix4d::UnalignedLMatrix4d(double e00, double e01, double e02, double e03, double e10, double e11, double e12, double e13, double e20, double e21, double e22, double e23, double e30, double e31, double e32, double e33);

3325 10 operator = 0 4 3527 30 UnalignedLMatrix4d::operator = 0 2 1664 1665 22
/**
 *
 */

/**
 *
 */
172
inline UnalignedLMatrix4d &UnalignedLMatrix4d::operator =(LMatrix4d const &copy);
inline UnalignedLMatrix4d &UnalignedLMatrix4d::operator =(UnalignedLMatrix4d const &copy);

3326 3 set 0 4 3527 23 UnalignedLMatrix4d::set 0 1 1666 10
/**
 *
 */
228
inline void UnalignedLMatrix4d::set(double e00, double e01, double e02, double e03, double e10, double e11, double e12, double e13, double e20, double e21, double e22, double e23, double e30, double e31, double e32, double e33);

3327 11 operator () 0 4 3527 31 UnalignedLMatrix4d::operator () 0 2 1667 1668 10
/**
 *
 */
136
inline double &UnalignedLMatrix4d::operator ()(int row, int col);
inline double UnalignedLMatrix4d::operator ()(int row, int col) const;

3328 8 get_data 0 4 3527 28 UnalignedLMatrix4d::get_data 0 1 1669 162
/**
 * Returns the address of the first of the nine data elements in the matrix.
 * The remaining elements occupy the next eight positions in row-major order.
 */
62
inline double const *UnalignedLMatrix4d::get_data(void) const;

3329 18 get_num_components 0 4 3527 38 UnalignedLMatrix4d::get_num_components 0 1 1670 65
/**
 * Returns the number of elements in the matrix, sixteen.
 */
62
inline int UnalignedLMatrix4d::get_num_components(void) const;

3330 14 get_class_type 0 4 3527 34 UnalignedLMatrix4d::get_class_type 0 1 1671 0
59
static TypeHandle UnalignedLMatrix4d::get_class_type(void);

3331 19 ~UnalignedLMatrix4d 0 4 3527 39 UnalignedLMatrix4d::~UnalignedLMatrix4d 0 0 0
46
UnalignedLMatrix4d::~UnalignedLMatrix4d(void);

3332 10 operator * 0 1 0 10 operator * 0 24 1864 1865 1866 1867 1868 1869 1870 1871 1872 1873 1874 1875 1876 1877 1878 1879 1880 1881 1882 1883 1884 1885 1886 1887 0
1659
inline LVecBase3f operator *(LVecBase3f const &v, LMatrix3f const &m);
inline LVector3f operator *(LVector3f const &v, LMatrix3f const &m);
inline LPoint3f operator *(LPoint3f const &v, LMatrix3f const &m);
inline LVector2f operator *(LVector2f const &v, LMatrix3f const &m);
inline LPoint2f operator *(LPoint2f const &v, LMatrix3f const &m);
inline LVecBase4f operator *(LVecBase4f const &v, LMatrix4f const &m);
inline LPoint4f operator *(LPoint4f const &v, LMatrix4f const &m);
inline LVector4f operator *(LVector4f const &v, LMatrix4f const &m);
inline LVector3f operator *(LVector3f const &v, LMatrix4f const &m);
inline LPoint3f operator *(LPoint3f const &v, LMatrix4f const &m);
inline LVecBase3d operator *(LVecBase3d const &v, LMatrix3d const &m);
inline LVector3d operator *(LVector3d const &v, LMatrix3d const &m);
inline LPoint3d operator *(LPoint3d const &v, LMatrix3d const &m);
inline LVector2d operator *(LVector2d const &v, LMatrix3d const &m);
inline LPoint2d operator *(LPoint2d const &v, LMatrix3d const &m);
inline LVecBase4d operator *(LVecBase4d const &v, LMatrix4d const &m);
inline LPoint4d operator *(LPoint4d const &v, LMatrix4d const &m);
inline LVector4d operator *(LVector4d const &v, LMatrix4d const &m);
inline LVector3d operator *(LVector3d const &v, LMatrix4d const &m);
inline LPoint3d operator *(LPoint3d const &v, LMatrix4d const &m);
inline LMatrix3f operator *(LMatrix3f const &m, LQuaternionf const &q);
inline LMatrix4f operator *(LMatrix4f const &m, LQuaternionf const &q);
inline LMatrix3d operator *(LMatrix3d const &m, LQuaterniond const &q);
inline LMatrix4d operator *(LMatrix4d const &m, LQuaterniond const &q);

3333 11 operator *= 0 1 0 11 operator *= 0 16 1888 1889 1890 1891 1892 1893 1894 1895 1896 1897 1898 1899 1900 1901 1902 1903 0
941
inline void operator *=(LVecBase3f &v, LMatrix3f const &m);
inline void operator *=(LVector3f &v, LMatrix3f const &m);
inline void operator *=(LPoint3f &v, LMatrix3f const &m);
inline void operator *=(LVector2f &v, LMatrix3f const &m);
inline void operator *=(LPoint2f &v, LMatrix3f const &m);
inline void operator *=(LVecBase4f &v, LMatrix4f const &m);
inline void operator *=(LVector3f &v, LMatrix4f const &m);
inline void operator *=(LPoint3f &v, LMatrix4f const &m);
inline void operator *=(LVecBase3d &v, LMatrix3d const &m);
inline void operator *=(LVector3d &v, LMatrix3d const &m);
inline void operator *=(LPoint3d &v, LMatrix3d const &m);
inline void operator *=(LVector2d &v, LMatrix3d const &m);
inline void operator *=(LPoint2d &v, LMatrix3d const &m);
inline void operator *=(LVecBase4d &v, LMatrix4d const &m);
inline void operator *=(LVector3d &v, LMatrix4d const &m);
inline void operator *=(LPoint3d &v, LMatrix4d const &m);

3334 22 generic_write_datagram 0 1 0 22 generic_write_datagram 0 4 1904 1905 1906 1907 0
303
inline void generic_write_datagram(Datagram &dest, LMatrix3f const &value);
inline void generic_write_datagram(Datagram &dest, LMatrix4f const &value);
inline void generic_write_datagram(Datagram &dest, LMatrix3d const &value);
inline void generic_write_datagram(Datagram &dest, LMatrix4d const &value);

3335 21 generic_read_datagram 0 1 0 21 generic_read_datagram 0 4 1908 1909 1910 1911 0
319
inline void generic_read_datagram(LMatrix3f &result, DatagramIterator &source);
inline void generic_read_datagram(LMatrix4f &result, DatagramIterator &source);
inline void generic_read_datagram(LMatrix3d &result, DatagramIterator &source);
inline void generic_read_datagram(LMatrix4d &result, DatagramIterator &source);

3336 14 compose_matrix 0 1 0 14 compose_matrix 0 10 1912 1913 1914 1915 1916 1917 1918 1919 1920 1921 0
1484
void compose_matrix(LMatrix3f &mat, LVecBase3f const &scale, LVecBase3f const &shear, LVecBase3f const &hpr, CoordinateSystem cs = ::CS_default);
inline void compose_matrix(LMatrix4f &mat, LVecBase3f const &scale, LVecBase3f const &shear, LVecBase3f const &hpr, LVecBase3f const &translate, CoordinateSystem cs = ::CS_default);
inline void compose_matrix(LMatrix4f &mat, float const components[::num_matrix_components], CoordinateSystem cs = ::CS_default);
inline void compose_matrix(LMatrix3f &mat, LVecBase3f const &scale, LVecBase3f const &hpr, CoordinateSystem cs = ::CS_default);
inline void compose_matrix(LMatrix4f &mat, LVecBase3f const &scale, LVecBase3f const &hpr, LVecBase3f const &translate, CoordinateSystem cs = ::CS_default);
void compose_matrix(LMatrix3d &mat, LVecBase3d const &scale, LVecBase3d const &shear, LVecBase3d const &hpr, CoordinateSystem cs = ::CS_default);
inline void compose_matrix(LMatrix4d &mat, LVecBase3d const &scale, LVecBase3d const &shear, LVecBase3d const &hpr, LVecBase3d const &translate, CoordinateSystem cs = ::CS_default);
inline void compose_matrix(LMatrix4d &mat, double const components[::num_matrix_components], CoordinateSystem cs = ::CS_default);
inline void compose_matrix(LMatrix3d &mat, LVecBase3d const &scale, LVecBase3d const &hpr, CoordinateSystem cs = ::CS_default);
inline void compose_matrix(LMatrix4d &mat, LVecBase3d const &scale, LVecBase3d const &hpr, LVecBase3d const &translate, CoordinateSystem cs = ::CS_default);

3337 16 decompose_matrix 0 1 0 16 decompose_matrix 0 10 1922 1923 1924 1925 1926 1927 1928 1929 1930 1931 0
1408
bool decompose_matrix(LMatrix3f const &mat, LVecBase3f &scale, LVecBase3f &shear, LVecBase3f &hpr, CoordinateSystem cs = ::CS_default);
inline bool decompose_matrix(LMatrix4f const &mat, LVecBase3f &scale, LVecBase3f &shear, LVecBase3f &hpr, LVecBase3f &translate, CoordinateSystem cs = ::CS_default);
inline bool decompose_matrix(LMatrix4f const &mat, float components[::num_matrix_components], CoordinateSystem CS = ::CS_default);
inline bool decompose_matrix(LMatrix3f const &mat, LVecBase3f &scale, LVecBase3f &hpr, CoordinateSystem cs = ::CS_default);
inline bool decompose_matrix(LMatrix4f const &mat, LVecBase3f &scale, LVecBase3f &hpr, LVecBase3f &translate, CoordinateSystem cs = ::CS_default);
bool decompose_matrix(LMatrix3d const &mat, LVecBase3d &scale, LVecBase3d &shear, LVecBase3d &hpr, CoordinateSystem cs = ::CS_default);
inline bool decompose_matrix(LMatrix4d const &mat, LVecBase3d &scale, LVecBase3d &shear, LVecBase3d &hpr, LVecBase3d &translate, CoordinateSystem cs = ::CS_default);
inline bool decompose_matrix(LMatrix4d const &mat, double components[::num_matrix_components], CoordinateSystem CS = ::CS_default);
inline bool decompose_matrix(LMatrix3d const &mat, LVecBase3d &scale, LVecBase3d &hpr, CoordinateSystem cs = ::CS_default);
inline bool decompose_matrix(LMatrix4d const &mat, LVecBase3d &scale, LVecBase3d &hpr, LVecBase3d &translate, CoordinateSystem cs = ::CS_default);

3338 24 decompose_matrix_old_hpr 0 1 0 24 decompose_matrix_old_hpr 0 2 1932 1933 0
287
bool decompose_matrix_old_hpr(LMatrix3f const &mat, LVecBase3f &scale, LVecBase3f &shear, LVecBase3f &hpr, CoordinateSystem cs = ::CS_default);
bool decompose_matrix_old_hpr(LMatrix3d const &mat, LVecBase3d &scale, LVecBase3d &shear, LVecBase3d &hpr, CoordinateSystem cs = ::CS_default);

3339 14 old_to_new_hpr 0 1 0 14 old_to_new_hpr 0 2 1934 1935 0
107
LVecBase3f old_to_new_hpr(LVecBase3f const &old_hpr);
LVecBase3d old_to_new_hpr(LVecBase3d const &old_hpr);

3340 12 LQuaternionf 0 4 3529 26 LQuaternionf::LQuaternionf 0 5 1672 1673 1674 1675 1676 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
305
inline LQuaternionf::LQuaternionf(void);
inline LQuaternionf::LQuaternionf(LVecBase4f const &copy);
inline LQuaternionf::LQuaternionf(float r, LVecBase3f const &copy);
inline LQuaternionf::LQuaternionf(float r, float i, float j, float k);
inline LQuaternionf::LQuaternionf(LQuaternionf const &) = default;

3341 14 pure_imaginary 0 4 3529 28 LQuaternionf::pure_imaginary 0 1 1677 10
/**
 *
 */
69
static LQuaternionf LQuaternionf::pure_imaginary(LVector3f const &v);

3342 9 conjugate 0 4 3529 23 LQuaternionf::conjugate 0 1 1678 54
/**
 * Returns the complex conjugate of this quat.
 */
56
inline LQuaternionf LQuaternionf::conjugate(void) const;

3343 5 xform 0 4 3529 19 LQuaternionf::xform 0 2 1679 1680 122
/**
 * Transforms a 3-d vector by the indicated rotation
 */

/**
 * Transforms a 4-d vector by the indicated rotation
 */
131
inline LVecBase3f LQuaternionf::xform(LVecBase3f const &v) const;
inline LVecBase4f LQuaternionf::xform(LVecBase4f const &v) const;

3344 8 multiply 0 4 3529 22 LQuaternionf::multiply 0 1 1681 45
/**
 * actual multiply call (non virtual)
 */
74
inline LQuaternionf LQuaternionf::multiply(LQuaternionf const &rhs) const;

3345 10 operator - 0 68 3529 24 LQuaternionf::operator - 0 1 1682 0
57
inline LQuaternionf LQuaternionf::operator -(void) const;

3346 10 operator + 0 4 3529 24 LQuaternionf::operator + 0 1 1683 0
78
inline LQuaternionf LQuaternionf::operator +(LQuaternionf const &other) const;

3347 10 operator - 0 4 3529 24 LQuaternionf::operator - 0 1 1684 0
78
inline LQuaternionf LQuaternionf::operator -(LQuaternionf const &other) const;

3348 9 angle_rad 0 4 3529 23 LQuaternionf::angle_rad 0 1 1685 127
/**
 * Returns the angle between the orientation represented by this quaternion
 * and the other one, expressed in radians.
 */
70
inline float LQuaternionf::angle_rad(LQuaternionf const &other) const;

3349 9 angle_deg 0 4 3529 23 LQuaternionf::angle_deg 0 1 1686 127
/**
 * Returns the angle between the orientation represented by this quaternion
 * and the other one, expressed in degrees.
 */
70
inline float LQuaternionf::angle_deg(LQuaternionf const &other) const;

3350 10 operator * 0 4 3529 24 LQuaternionf::operator * 0 4 1687 1688 1689 1690 0
263
inline LQuaternionf LQuaternionf::operator *(float scalar) const;
inline LQuaternionf LQuaternionf::operator *(LQuaternionf const &) const;
inline LMatrix3f LQuaternionf::operator *(LMatrix3f const &);
inline LMatrix4f LQuaternionf::operator *(LMatrix4f const &);

3351 10 operator / 0 4 3529 24 LQuaternionf::operator / 0 1 1691 0
65
inline LQuaternionf LQuaternionf::operator /(float scalar) const;

3352 11 operator *= 0 4 3529 25 LQuaternionf::operator *= 0 1 1692 10
/**
 *
 */
69
inline LQuaternionf &LQuaternionf::operator *=(LQuaternionf const &);

3353 12 almost_equal 0 4 3529 26 LQuaternionf::almost_equal 0 2 1693 1694 218
/**
 * Returns true if two quaternions are memberwise equal within a default
 * tolerance based on the numeric type.
 */

/**
 * Returns true if two quaternions are memberwise equal within a specified
 * tolerance.
 */
162
inline bool LQuaternionf::almost_equal(LQuaternionf const &other) const;
inline bool LQuaternionf::almost_equal(LQuaternionf const &other, float threshold) const;

3354 17 is_same_direction 0 4 3529 31 LQuaternionf::is_same_direction 0 1 1695 127
/**
 * Returns true if two quaternions represent the same rotation within a
 * default tolerance based on the numeric type.
 */
77
inline bool LQuaternionf::is_same_direction(LQuaternionf const &other) const;

3355 21 almost_same_direction 0 4 3529 35 LQuaternionf::almost_same_direction 0 1 1696 103
/**
 * Returns true if two quaternions represent the same rotation within a
 * specified tolerance.
 */
98
inline bool LQuaternionf::almost_same_direction(LQuaternionf const &other, float threshold) const;

3356 6 output 0 4 3529 20 LQuaternionf::output 0 1 1697 10
/**
 *
 */
50
inline void LQuaternionf::output(ostream &) const;

3357 17 extract_to_matrix 0 4 3529 31 LQuaternionf::extract_to_matrix 0 2 1698 1699 88
/**
 * Based on the quat lib from VRPN.
 */

/**
 * Based on the quat lib from VRPN.
 */
115
void LQuaternionf::extract_to_matrix(LMatrix3f &m) const;
void LQuaternionf::extract_to_matrix(LMatrix4f &m) const;

3358 15 set_from_matrix 0 4 3529 29 LQuaternionf::set_from_matrix 0 2 1700 1701 238
/**
 *
 */

/**
 * Sets the quaternion according to the rotation represented by the matrix.
 * Originally we tried an algorithm presented by Do-While Jones, but that
 * turned out to be broken.  This is based on the quat lib from UNC.
 */
118
void LQuaternionf::set_from_matrix(LMatrix3f const &m);
inline void LQuaternionf::set_from_matrix(LMatrix4f const &m);

3359 7 set_hpr 0 4 3529 21 LQuaternionf::set_hpr 0 1 1702 132
/**
 * Sets the quaternion as the unit quaternion that is equivalent to these
 * Euler angles.  (from Real-time Rendering, p.49)
 */
86
void LQuaternionf::set_hpr(LVecBase3f const &hpr, CoordinateSystem cs = ::CS_default);

3360 7 get_hpr 0 4 3529 21 LQuaternionf::get_hpr 0 1 1703 73
/**
 * Extracts the equivalent Euler angles from the unit quaternion.
 */
75
LVecBase3f LQuaternionf::get_hpr(CoordinateSystem cs = ::CS_default) const;

3361 8 get_axis 0 4 3529 22 LQuaternionf::get_axis 0 1 1704 180
/**
 * This, along with get_angle(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the axis; it
 * is not normalized.
 */
52
inline LVector3f LQuaternionf::get_axis(void) const;

3362 19 get_axis_normalized 0 4 3529 33 LQuaternionf::get_axis_normalized 0 1 1705 169
/**
 * This, along with get_angle(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the
 * normalized axis.
 */
63
inline LVector3f LQuaternionf::get_axis_normalized(void) const;

3363 13 get_angle_rad 0 4 3529 27 LQuaternionf::get_angle_rad 0 1 1706 343
/**
 * This, along with get_axis(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the angle, in
 * radians counterclockwise about the axis.
 *
 * It is necessary to ensure the quaternion has been normalized (for instance,
 * with a call to normalize()) before calling this method.
 */
53
inline float LQuaternionf::get_angle_rad(void) const;

3364 9 get_angle 0 4 3529 23 LQuaternionf::get_angle 0 1 1707 343
/**
 * This, along with get_axis(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the angle, in
 * degrees counterclockwise about the axis.
 *
 * It is necessary to ensure the quaternion has been normalized (for instance,
 * with a call to normalize()) before calling this method.
 */
49
inline float LQuaternionf::get_angle(void) const;

3365 23 set_from_axis_angle_rad 0 4 3529 37 LQuaternionf::set_from_axis_angle_rad 0 1 1708 86
/**
 * angle_rad is the angle about the axis in radians.  axis must be normalized.
 */
90
inline void LQuaternionf::set_from_axis_angle_rad(float angle_rad, LVector3f const &axis);

3366 19 set_from_axis_angle 0 4 3529 33 LQuaternionf::set_from_axis_angle 0 1 1709 86
/**
 * angle_deg is the angle about the axis in degrees.  axis must be normalized.
 */
86
inline void LQuaternionf::set_from_axis_angle(float angle_deg, LVector3f const &axis);

3367 6 get_up 0 4 3529 20 LQuaternionf::get_up 0 1 1710 96
/**
 * Returns the orientation represented by this quaternion, expressed as an up
 * vector.
 */
80
inline LVector3f LQuaternionf::get_up(CoordinateSystem cs = ::CS_default) const;

3368 9 get_right 0 4 3529 23 LQuaternionf::get_right 0 1 1711 98
/**
 * Returns the orientation represented by this quaternion, expressed as a
 * right vector.
 */
83
inline LVector3f LQuaternionf::get_right(CoordinateSystem cs = ::CS_default) const;

3369 11 get_forward 0 4 3529 25 LQuaternionf::get_forward 0 1 1712 100
/**
 * Returns the orientation represented by this quaternion, expressed as a
 * forward vector.
 */
85
inline LVector3f LQuaternionf::get_forward(CoordinateSystem cs = ::CS_default) const;

3370 5 get_r 0 4 3529 19 LQuaternionf::get_r 0 1 1713 10
/**
 *
 */
45
inline float LQuaternionf::get_r(void) const;

3371 5 get_i 0 4 3529 19 LQuaternionf::get_i 0 1 1714 10
/**
 *
 */
45
inline float LQuaternionf::get_i(void) const;

3372 5 get_j 0 4 3529 19 LQuaternionf::get_j 0 1 1715 10
/**
 *
 */
45
inline float LQuaternionf::get_j(void) const;

3373 5 get_k 0 4 3529 19 LQuaternionf::get_k 0 1 1716 10
/**
 *
 */
45
inline float LQuaternionf::get_k(void) const;

3374 5 set_r 0 4 3529 19 LQuaternionf::set_r 0 1 1717 10
/**
 *
 */
41
inline void LQuaternionf::set_r(float r);

3375 5 set_i 0 4 3529 19 LQuaternionf::set_i 0 1 1718 10
/**
 *
 */
41
inline void LQuaternionf::set_i(float i);

3376 5 set_j 0 4 3529 19 LQuaternionf::set_j 0 1 1719 10
/**
 *
 */
41
inline void LQuaternionf::set_j(float j);

3377 5 set_k 0 4 3529 19 LQuaternionf::set_k 0 1 1720 10
/**
 *
 */
41
inline void LQuaternionf::set_k(float k);

3378 9 normalize 0 4 3529 23 LQuaternionf::normalize 0 1 1721 10
/**
 *
 */
42
inline bool LQuaternionf::normalize(void);

3379 14 conjugate_from 0 4 3529 28 LQuaternionf::conjugate_from 0 1 1722 466
/**
 * Computes the conjugate of the other quat, and stores the result in this
 * quat.  This is a fully general operation and makes no assumptions about the
 * type of transform represented by the quat.
 *
 * The other quat must be a different object than this quat.  However, if you
 * need to get a conjugate of a quat in place, see conjugate_in_place.
 *
 * The return value is true if the quat was successfully inverted, false if
 * there was a singularity.
 */
68
inline bool LQuaternionf::conjugate_from(LQuaternionf const &other);

3380 18 conjugate_in_place 0 4 3529 32 LQuaternionf::conjugate_in_place 0 1 1723 129
/**
 * Sets this to be the conjugate of the current quat.  Returns true if the
 * successful, false if the quat was singular.
 */
51
inline bool LQuaternionf::conjugate_in_place(void);

3381 11 invert_from 0 4 3529 25 LQuaternionf::invert_from 0 1 1724 448
/**
 * Computes the inverse of the other quat, and stores the result in this quat.
 * This is a fully general operation and makes no assumptions about the type
 * of transform represented by the quat.
 *
 * The other quat must be a different object than this quat.  However, if you
 * need to invert a quat in place, see invert_in_place.
 *
 * The return value is true if the quat was successfully inverted, false if
 * there was a singularity.
 */
65
inline bool LQuaternionf::invert_from(LQuaternionf const &other);

3382 15 invert_in_place 0 4 3529 29 LQuaternionf::invert_in_place 0 1 1725 115
/**
 * Inverts the current quat.  Returns true if the inverse is successful, false
 * if the quat was singular.
 */
48
inline bool LQuaternionf::invert_in_place(void);

3383 11 is_identity 0 4 3529 25 LQuaternionf::is_identity 0 1 1726 98
/**
 * Returns true if this quaternion represents the identity transformation: no
 * rotation.
 */
50
inline bool LQuaternionf::is_identity(void) const;

3384 18 is_almost_identity 0 4 3529 32 LQuaternionf::is_almost_identity 0 1 1727 110
/**
 * Returns true if this quaternion represents the identity transformation
 * within a given tolerance.
 */
68
inline bool LQuaternionf::is_almost_identity(float tolerance) const;

3385 10 ident_quat 0 4 3529 24 LQuaternionf::ident_quat 0 1 1728 42
/**
 * Returns an identity quaternion.
 */
65
static inline LQuaternionf const &LQuaternionf::ident_quat(void);

3386 14 get_class_type 0 4 3529 28 LQuaternionf::get_class_type 0 1 1729 0
53
static TypeHandle LQuaternionf::get_class_type(void);

3387 13 ~LQuaternionf 0 4 3529 27 LQuaternionf::~LQuaternionf 0 0 0
34
LQuaternionf::~LQuaternionf(void);

3388 12 LQuaterniond 0 4 3530 26 LQuaterniond::LQuaterniond 0 5 1730 1731 1732 1733 1734 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
310
inline LQuaterniond::LQuaterniond(void);
inline LQuaterniond::LQuaterniond(LVecBase4d const &copy);
inline LQuaterniond::LQuaterniond(double r, LVecBase3d const &copy);
inline LQuaterniond::LQuaterniond(double r, double i, double j, double k);
inline LQuaterniond::LQuaterniond(LQuaterniond const &) = default;

3389 14 pure_imaginary 0 4 3530 28 LQuaterniond::pure_imaginary 0 1 1735 10
/**
 *
 */
69
static LQuaterniond LQuaterniond::pure_imaginary(LVector3d const &v);

3390 9 conjugate 0 4 3530 23 LQuaterniond::conjugate 0 1 1736 54
/**
 * Returns the complex conjugate of this quat.
 */
56
inline LQuaterniond LQuaterniond::conjugate(void) const;

3391 5 xform 0 4 3530 19 LQuaterniond::xform 0 2 1737 1738 122
/**
 * Transforms a 3-d vector by the indicated rotation
 */

/**
 * Transforms a 4-d vector by the indicated rotation
 */
131
inline LVecBase3d LQuaterniond::xform(LVecBase3d const &v) const;
inline LVecBase4d LQuaterniond::xform(LVecBase4d const &v) const;

3392 8 multiply 0 4 3530 22 LQuaterniond::multiply 0 1 1739 45
/**
 * actual multiply call (non virtual)
 */
74
inline LQuaterniond LQuaterniond::multiply(LQuaterniond const &rhs) const;

3393 10 operator - 0 68 3530 24 LQuaterniond::operator - 0 1 1740 0
57
inline LQuaterniond LQuaterniond::operator -(void) const;

3394 10 operator + 0 4 3530 24 LQuaterniond::operator + 0 1 1741 0
78
inline LQuaterniond LQuaterniond::operator +(LQuaterniond const &other) const;

3395 10 operator - 0 4 3530 24 LQuaterniond::operator - 0 1 1742 0
78
inline LQuaterniond LQuaterniond::operator -(LQuaterniond const &other) const;

3396 9 angle_rad 0 4 3530 23 LQuaterniond::angle_rad 0 1 1743 127
/**
 * Returns the angle between the orientation represented by this quaternion
 * and the other one, expressed in radians.
 */
71
inline double LQuaterniond::angle_rad(LQuaterniond const &other) const;

3397 9 angle_deg 0 4 3530 23 LQuaterniond::angle_deg 0 1 1744 127
/**
 * Returns the angle between the orientation represented by this quaternion
 * and the other one, expressed in degrees.
 */
71
inline double LQuaterniond::angle_deg(LQuaterniond const &other) const;

3398 10 operator * 0 4 3530 24 LQuaterniond::operator * 0 4 1745 1746 1747 1748 0
264
inline LQuaterniond LQuaterniond::operator *(double scalar) const;
inline LQuaterniond LQuaterniond::operator *(LQuaterniond const &) const;
inline LMatrix3d LQuaterniond::operator *(LMatrix3d const &);
inline LMatrix4d LQuaterniond::operator *(LMatrix4d const &);

3399 10 operator / 0 4 3530 24 LQuaterniond::operator / 0 1 1749 0
66
inline LQuaterniond LQuaterniond::operator /(double scalar) const;

3400 11 operator *= 0 4 3530 25 LQuaterniond::operator *= 0 1 1750 10
/**
 *
 */
69
inline LQuaterniond &LQuaterniond::operator *=(LQuaterniond const &);

3401 12 almost_equal 0 4 3530 26 LQuaterniond::almost_equal 0 2 1751 1752 218
/**
 * Returns true if two quaternions are memberwise equal within a default
 * tolerance based on the numeric type.
 */

/**
 * Returns true if two quaternions are memberwise equal within a specified
 * tolerance.
 */
163
inline bool LQuaterniond::almost_equal(LQuaterniond const &other) const;
inline bool LQuaterniond::almost_equal(LQuaterniond const &other, double threshold) const;

3402 17 is_same_direction 0 4 3530 31 LQuaterniond::is_same_direction 0 1 1753 127
/**
 * Returns true if two quaternions represent the same rotation within a
 * default tolerance based on the numeric type.
 */
77
inline bool LQuaterniond::is_same_direction(LQuaterniond const &other) const;

3403 21 almost_same_direction 0 4 3530 35 LQuaterniond::almost_same_direction 0 1 1754 103
/**
 * Returns true if two quaternions represent the same rotation within a
 * specified tolerance.
 */
99
inline bool LQuaterniond::almost_same_direction(LQuaterniond const &other, double threshold) const;

3404 6 output 0 4 3530 20 LQuaterniond::output 0 1 1755 10
/**
 *
 */
50
inline void LQuaterniond::output(ostream &) const;

3405 17 extract_to_matrix 0 4 3530 31 LQuaterniond::extract_to_matrix 0 2 1756 1757 88
/**
 * Based on the quat lib from VRPN.
 */

/**
 * Based on the quat lib from VRPN.
 */
115
void LQuaterniond::extract_to_matrix(LMatrix3d &m) const;
void LQuaterniond::extract_to_matrix(LMatrix4d &m) const;

3406 15 set_from_matrix 0 4 3530 29 LQuaterniond::set_from_matrix 0 2 1758 1759 238
/**
 *
 */

/**
 * Sets the quaternion according to the rotation represented by the matrix.
 * Originally we tried an algorithm presented by Do-While Jones, but that
 * turned out to be broken.  This is based on the quat lib from UNC.
 */
118
void LQuaterniond::set_from_matrix(LMatrix3d const &m);
inline void LQuaterniond::set_from_matrix(LMatrix4d const &m);

3407 7 set_hpr 0 4 3530 21 LQuaterniond::set_hpr 0 1 1760 132
/**
 * Sets the quaternion as the unit quaternion that is equivalent to these
 * Euler angles.  (from Real-time Rendering, p.49)
 */
86
void LQuaterniond::set_hpr(LVecBase3d const &hpr, CoordinateSystem cs = ::CS_default);

3408 7 get_hpr 0 4 3530 21 LQuaterniond::get_hpr 0 1 1761 73
/**
 * Extracts the equivalent Euler angles from the unit quaternion.
 */
75
LVecBase3d LQuaterniond::get_hpr(CoordinateSystem cs = ::CS_default) const;

3409 8 get_axis 0 4 3530 22 LQuaterniond::get_axis 0 1 1762 180
/**
 * This, along with get_angle(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the axis; it
 * is not normalized.
 */
52
inline LVector3d LQuaterniond::get_axis(void) const;

3410 19 get_axis_normalized 0 4 3530 33 LQuaterniond::get_axis_normalized 0 1 1763 169
/**
 * This, along with get_angle(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the
 * normalized axis.
 */
63
inline LVector3d LQuaterniond::get_axis_normalized(void) const;

3411 13 get_angle_rad 0 4 3530 27 LQuaterniond::get_angle_rad 0 1 1764 343
/**
 * This, along with get_axis(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the angle, in
 * radians counterclockwise about the axis.
 *
 * It is necessary to ensure the quaternion has been normalized (for instance,
 * with a call to normalize()) before calling this method.
 */
54
inline double LQuaterniond::get_angle_rad(void) const;

3412 9 get_angle 0 4 3530 23 LQuaterniond::get_angle 0 1 1765 343
/**
 * This, along with get_axis(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the angle, in
 * degrees counterclockwise about the axis.
 *
 * It is necessary to ensure the quaternion has been normalized (for instance,
 * with a call to normalize()) before calling this method.
 */
50
inline double LQuaterniond::get_angle(void) const;

3413 23 set_from_axis_angle_rad 0 4 3530 37 LQuaterniond::set_from_axis_angle_rad 0 1 1766 86
/**
 * angle_rad is the angle about the axis in radians.  axis must be normalized.
 */
91
inline void LQuaterniond::set_from_axis_angle_rad(double angle_rad, LVector3d const &axis);

3414 19 set_from_axis_angle 0 4 3530 33 LQuaterniond::set_from_axis_angle 0 1 1767 86
/**
 * angle_deg is the angle about the axis in degrees.  axis must be normalized.
 */
87
inline void LQuaterniond::set_from_axis_angle(double angle_deg, LVector3d const &axis);

3415 6 get_up 0 4 3530 20 LQuaterniond::get_up 0 1 1768 96
/**
 * Returns the orientation represented by this quaternion, expressed as an up
 * vector.
 */
80
inline LVector3d LQuaterniond::get_up(CoordinateSystem cs = ::CS_default) const;

3416 9 get_right 0 4 3530 23 LQuaterniond::get_right 0 1 1769 98
/**
 * Returns the orientation represented by this quaternion, expressed as a
 * right vector.
 */
83
inline LVector3d LQuaterniond::get_right(CoordinateSystem cs = ::CS_default) const;

3417 11 get_forward 0 4 3530 25 LQuaterniond::get_forward 0 1 1770 100
/**
 * Returns the orientation represented by this quaternion, expressed as a
 * forward vector.
 */
85
inline LVector3d LQuaterniond::get_forward(CoordinateSystem cs = ::CS_default) const;

3418 5 get_r 0 4 3530 19 LQuaterniond::get_r 0 1 1771 10
/**
 *
 */
46
inline double LQuaterniond::get_r(void) const;

3419 5 get_i 0 4 3530 19 LQuaterniond::get_i 0 1 1772 10
/**
 *
 */
46
inline double LQuaterniond::get_i(void) const;

3420 5 get_j 0 4 3530 19 LQuaterniond::get_j 0 1 1773 10
/**
 *
 */
46
inline double LQuaterniond::get_j(void) const;

3421 5 get_k 0 4 3530 19 LQuaterniond::get_k 0 1 1774 10
/**
 *
 */
46
inline double LQuaterniond::get_k(void) const;

3422 5 set_r 0 4 3530 19 LQuaterniond::set_r 0 1 1775 10
/**
 *
 */
42
inline void LQuaterniond::set_r(double r);

3423 5 set_i 0 4 3530 19 LQuaterniond::set_i 0 1 1776 10
/**
 *
 */
42
inline void LQuaterniond::set_i(double i);

3424 5 set_j 0 4 3530 19 LQuaterniond::set_j 0 1 1777 10
/**
 *
 */
42
inline void LQuaterniond::set_j(double j);

3425 5 set_k 0 4 3530 19 LQuaterniond::set_k 0 1 1778 10
/**
 *
 */
42
inline void LQuaterniond::set_k(double k);

3426 9 normalize 0 4 3530 23 LQuaterniond::normalize 0 1 1779 10
/**
 *
 */
42
inline bool LQuaterniond::normalize(void);

3427 14 conjugate_from 0 4 3530 28 LQuaterniond::conjugate_from 0 1 1780 466
/**
 * Computes the conjugate of the other quat, and stores the result in this
 * quat.  This is a fully general operation and makes no assumptions about the
 * type of transform represented by the quat.
 *
 * The other quat must be a different object than this quat.  However, if you
 * need to get a conjugate of a quat in place, see conjugate_in_place.
 *
 * The return value is true if the quat was successfully inverted, false if
 * there was a singularity.
 */
68
inline bool LQuaterniond::conjugate_from(LQuaterniond const &other);

3428 18 conjugate_in_place 0 4 3530 32 LQuaterniond::conjugate_in_place 0 1 1781 129
/**
 * Sets this to be the conjugate of the current quat.  Returns true if the
 * successful, false if the quat was singular.
 */
51
inline bool LQuaterniond::conjugate_in_place(void);

3429 11 invert_from 0 4 3530 25 LQuaterniond::invert_from 0 1 1782 448
/**
 * Computes the inverse of the other quat, and stores the result in this quat.
 * This is a fully general operation and makes no assumptions about the type
 * of transform represented by the quat.
 *
 * The other quat must be a different object than this quat.  However, if you
 * need to invert a quat in place, see invert_in_place.
 *
 * The return value is true if the quat was successfully inverted, false if
 * there was a singularity.
 */
65
inline bool LQuaterniond::invert_from(LQuaterniond const &other);

3430 15 invert_in_place 0 4 3530 29 LQuaterniond::invert_in_place 0 1 1783 115
/**
 * Inverts the current quat.  Returns true if the inverse is successful, false
 * if the quat was singular.
 */
48
inline bool LQuaterniond::invert_in_place(void);

3431 11 is_identity 0 4 3530 25 LQuaterniond::is_identity 0 1 1784 98
/**
 * Returns true if this quaternion represents the identity transformation: no
 * rotation.
 */
50
inline bool LQuaterniond::is_identity(void) const;

3432 18 is_almost_identity 0 4 3530 32 LQuaterniond::is_almost_identity 0 1 1785 110
/**
 * Returns true if this quaternion represents the identity transformation
 * within a given tolerance.
 */
69
inline bool LQuaterniond::is_almost_identity(double tolerance) const;

3433 10 ident_quat 0 4 3530 24 LQuaterniond::ident_quat 0 1 1786 42
/**
 * Returns an identity quaternion.
 */
65
static inline LQuaterniond const &LQuaterniond::ident_quat(void);

3434 14 get_class_type 0 4 3530 28 LQuaterniond::get_class_type 0 1 1787 0
53
static TypeHandle LQuaterniond::get_class_type(void);

3435 13 ~LQuaterniond 0 4 3530 27 LQuaterniond::~LQuaterniond 0 0 0
34
LQuaterniond::~LQuaterniond(void);

3436 10 LRotationf 0 4 3531 22 LRotationf::LRotationf 0 9 1788 1789 1790 1791 1792 1793 1794 1795 1796 185
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 * lmatrix3
 */

/**
 * lmatrix4
 */

/**
 * axis + angle (in degrees)
 */

/**
 * Sets the rotation from the given Euler angles.
 */
500
inline LRotationf::LRotationf(void);
inline LRotationf::LRotationf(LQuaternionf const &c);
inline LRotationf::LRotationf(LVecBase4f const &copy);
inline LRotationf::LRotationf(float r, float i, float j, float k);
inline LRotationf::LRotationf(LVector3f const &axis, float angle);
inline LRotationf::LRotationf(LMatrix3f const &m);
inline LRotationf::LRotationf(LMatrix4f const &m);
inline LRotationf::LRotationf(float h, float p, float r);
inline LRotationf::LRotationf(LRotationf const &) = default;

3437 10 operator * 0 4 3531 22 LRotationf::operator * 0 3 1797 1798 1799 0
211
inline LRotationf LRotationf::operator *(float scalar) const;
inline LRotationf LRotationf::operator *(LRotationf const &other) const;
inline LQuaternionf LRotationf::operator *(LQuaternionf const &other) const;

3438 10 operator / 0 4 3531 22 LRotationf::operator / 0 1 1800 0
61
inline LRotationf LRotationf::operator /(float scalar) const;

3439 14 get_class_type 0 4 3531 26 LRotationf::get_class_type 0 1 1801 0
51
static TypeHandle LRotationf::get_class_type(void);

3440 11 ~LRotationf 0 4 3531 23 LRotationf::~LRotationf 0 0 0
30
LRotationf::~LRotationf(void);

3441 10 LRotationd 0 4 3532 22 LRotationd::LRotationd 0 9 1802 1803 1804 1805 1806 1807 1808 1809 1810 185
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 * lmatrix3
 */

/**
 * lmatrix4
 */

/**
 * axis + angle (in degrees)
 */

/**
 * Sets the rotation from the given Euler angles.
 */
508
inline LRotationd::LRotationd(void);
inline LRotationd::LRotationd(LQuaterniond const &c);
inline LRotationd::LRotationd(LVecBase4d const &copy);
inline LRotationd::LRotationd(double r, double i, double j, double k);
inline LRotationd::LRotationd(LVector3d const &axis, double angle);
inline LRotationd::LRotationd(LMatrix3d const &m);
inline LRotationd::LRotationd(LMatrix4d const &m);
inline LRotationd::LRotationd(double h, double p, double r);
inline LRotationd::LRotationd(LRotationd const &) = default;

3442 10 operator * 0 4 3532 22 LRotationd::operator * 0 3 1811 1812 1813 0
212
inline LRotationd LRotationd::operator *(double scalar) const;
inline LRotationd LRotationd::operator *(LRotationd const &other) const;
inline LQuaterniond LRotationd::operator *(LQuaterniond const &other) const;

3443 10 operator / 0 4 3532 22 LRotationd::operator / 0 1 1814 0
62
inline LRotationd LRotationd::operator /(double scalar) const;

3444 14 get_class_type 0 4 3532 26 LRotationd::get_class_type 0 1 1815 0
51
static TypeHandle LRotationd::get_class_type(void);

3445 11 ~LRotationd 0 4 3532 23 LRotationd::~LRotationd 0 0 0
30
LRotationd::~LRotationd(void);

3446 13 LOrientationf 0 4 3533 28 LOrientationf::LOrientationf 0 7 1816 1817 1818 1819 1820 1821 1822 101
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 * vector + twist
 */

/**
 * matrix3
 */

/**
 * matrix4
 */
436
inline LOrientationf::LOrientationf(void);
inline LOrientationf::LOrientationf(LQuaternionf const &c);
inline LOrientationf::LOrientationf(float r, float i, float j, float k);
inline LOrientationf::LOrientationf(LVector3f const &point_at, float twist);
inline LOrientationf::LOrientationf(LMatrix3f const &m);
inline LOrientationf::LOrientationf(LMatrix4f const &m);
inline LOrientationf::LOrientationf(LOrientationf const &) = default;

3447 10 operator * 0 4 3533 25 LOrientationf::operator * 0 2 1823 1824 0
159
inline LOrientationf LOrientationf::operator *(LRotationf const &other) const;
inline LOrientationf LOrientationf::operator *(LQuaternionf const &other) const;

3448 14 get_class_type 0 4 3533 29 LOrientationf::get_class_type 0 1 1825 0
54
static TypeHandle LOrientationf::get_class_type(void);

3449 14 ~LOrientationf 0 4 3533 29 LOrientationf::~LOrientationf 0 0 0
36
LOrientationf::~LOrientationf(void);

3450 13 LOrientationd 0 4 3534 28 LOrientationd::LOrientationd 0 7 1826 1827 1828 1829 1830 1831 1832 101
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 * vector + twist
 */

/**
 * matrix3
 */

/**
 * matrix4
 */
441
inline LOrientationd::LOrientationd(void);
inline LOrientationd::LOrientationd(LQuaterniond const &c);
inline LOrientationd::LOrientationd(double r, double i, double j, double k);
inline LOrientationd::LOrientationd(LVector3d const &point_at, double twist);
inline LOrientationd::LOrientationd(LMatrix3d const &m);
inline LOrientationd::LOrientationd(LMatrix4d const &m);
inline LOrientationd::LOrientationd(LOrientationd const &) = default;

3451 10 operator * 0 4 3534 25 LOrientationd::operator * 0 2 1833 1834 0
159
inline LOrientationd LOrientationd::operator *(LRotationd const &other) const;
inline LOrientationd LOrientationd::operator *(LQuaterniond const &other) const;

3452 14 get_class_type 0 4 3534 29 LOrientationd::get_class_type 0 1 1835 0
54
static TypeHandle LOrientationd::get_class_type(void);

3453 14 ~LOrientationd 0 4 3534 29 LOrientationd::~LOrientationd 0 0 0
36
LOrientationd::~LOrientationd(void);

3454 19 ConfigVariableColor 0 4 3605 40 ConfigVariableColor::ConfigVariableColor 0 4 1836 1837 1838 1839 34
/**
 *
 */

/**
 *
 */

/**
 *
 */
488
inline ConfigVariableColor::ConfigVariableColor(std::string const &name);
inline ConfigVariableColor::ConfigVariableColor(std::string const &name, LColor const &default_value, std::string const &description = string(), int flags = 0);
inline ConfigVariableColor::ConfigVariableColor(std::string const &name, std::string const &default_value, std::string const &description = string(), int flags = 0);
inline ConfigVariableColor::ConfigVariableColor(ConfigVariableColor const &) = default;

3455 10 operator = 0 4 3605 31 ConfigVariableColor::operator = 0 1 1840 0
65
inline void ConfigVariableColor::operator =(LColor const &value);

3456 17 operator typecast 0 132 3605 38 ConfigVariableColor::operator typecast 0 1 1845 0
72
inline LColor const &ConfigVariableColor::operator typecast(void) const;

3457 11 operator [] 0 4 3605 32 ConfigVariableColor::operator [] 0 1 1841 0
65
inline PN_stdfloat ConfigVariableColor::operator [](int n) const;

3458 9 set_value 0 4 3605 30 ConfigVariableColor::set_value 0 1 1842 48
/**
 * Reassigns the variable's local value.
 */
64
inline void ConfigVariableColor::set_value(LColor const &value);

3459 9 get_value 0 4 3605 30 ConfigVariableColor::get_value 0 1 1843 40
/**
 * Returns the variable's value.
 */
64
inline LColor const &ConfigVariableColor::get_value(void) const;

3460 17 get_default_value 0 4 3605 38 ConfigVariableColor::get_default_value 0 1 1844 48
/**
 * Returns the variable's default value.
 */
65
inline LColor ConfigVariableColor::get_default_value(void) const;

3461 20 ~ConfigVariableColor 0 4 3605 41 ConfigVariableColor::~ConfigVariableColor 0 0 0
48
ConfigVariableColor::~ConfigVariableColor(void);

1935
1 0 0 7 2 3607 1937 0 0 0 
2 0 0 7 2 3607 1937 0 0 1 6 param0 0 3608  
3 0 0 7 8 3610 2002 0 0 0 
4 0 0 7 8 3610 2002 0 0 1 6 param0 0 3611  
5 0 0 7 8 3610 2002 0 10 /**
 *
 */ 1 10 fill_value 1 3465  
6 0 0 7 8 3610 2002 0 10 /**
 *
 */ 2 1 x 1 3465  1 y 1 3465  
7 0 0 4 9 3615 0 0 0 2 4 this 3 3610  4 size 1 3613  
8 0 0 6 12 3610 0 0 0 2 4 this 3 3610  4 copy 1 3611  
9 0 0 6 12 3610 0 0 0 2 4 this 3 3610  10 fill_value 1 3465  
10 0 0 6 13 3611 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
11 0 0 6 14 3611 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
12 0 0 6 15 3611 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
13 0 0 6 16 3616 0 0 0 1 4 this 3 3611  
14 0 0 6 17 3616 0 0 0 2 4 this 3 3611  9 attr_name 1 3619  
15 0 0 6 18 3471 0 0 0 3 4 this 3 3610  9 attr_name 1 3619  6 assign 1 3616  
16 0 0 4 19 3615 0 0 10 /**
 *
 */ 3 4 this 3 3610  1 i 1 3471  10 assign_val 1 3465  
17 0 0 6 19 3465 0 0 0 2 4 this 3 3611  1 i 1 3471  
18 0 0 6 20 3471 0 0 0 0 
19 0 0 6 21 3620 0 0 91 /**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */ 1 4 this 3 3611  
20 0 0 6 22 3465 0 0 10 /**
 *
 */ 2 4 this 3 3611  1 i 1 3471  
21 0 0 4 23 3615 0 0 10 /**
 *
 */ 3 4 this 3 3610  1 i 1 3471  5 value 1 3465  
22 0 0 6 24 3465 0 0 10 /**
 *
 */ 1 4 this 3 3611  
23 0 0 6 25 3465 0 0 10 /**
 *
 */ 1 4 this 3 3611  
24 0 0 4 26 3615 0 0 10 /**
 *
 */ 2 4 this 3 3610  5 value 1 3465  
25 0 0 4 27 3615 0 0 10 /**
 *
 */ 2 4 this 3 3610  5 value 1 3465  
26 0 0 4 31 3615 0 0 152 // These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages: 3 4 this 3 3610  1 i 1 3471  5 value 1 3465  
27 0 0 4 32 3615 0 0 10 /**
 *
 */ 2 4 this 3 3610  5 value 1 3465  
28 0 0 4 33 3615 0 0 10 /**
 *
 */ 2 4 this 3 3610  5 value 1 3465  
29 0 0 4 34 3615 0 0 155 /**
 * Returns the address of the first of the two data elements in the vector.
 * The next element occupies the next position consecutively in memory.
 */ 1 4 this 3 3611  
30 0 0 6 35 3471 0 0 0 0 
31 0 0 4 36 3615 0 0 129 /**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */ 2 4 this 3 3610  10 fill_value 1 3465  
32 0 0 4 37 3615 0 0 10 /**
 *
 */ 3 4 this 3 3610  1 x 1 3465  1 y 1 3465  
33 0 0 6 38 3465 0 0 10 /**
 *
 */ 2 4 this 3 3611  5 other 1 3611  
34 0 0 6 39 3465 0 0 69 /**
 * Returns the square of the vector's length, cheap and easy.
 */ 1 4 this 3 3611  
35 0 0 6 40 3465 0 0 72 /**
 * Returns the length of the vector, by the Pythagorean theorem.
 */ 1 4 this 3 3611  
36 0 0 6 41 3620 0 0 127 /**
 * Normalizes the vector in place.  Returns true if the vector was normalized,
 * false if it was a zero-length vector.
 */ 1 4 this 3 3610  
37 0 0 7 42 3610 2002 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3611  
38 0 0 7 43 3610 2002 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3611  4 onto 1 3611  
39 0 0 6 44 3620 0 0 0 2 4 this 3 3611  5 other 1 3611  
40 0 0 6 45 3620 0 0 0 2 4 this 3 3611  5 other 1 3611  
41 0 0 6 46 3620 0 0 0 2 4 this 3 3611  5 other 1 3611  
42 0 0 6 47 3471 0 0 97 /**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */ 2 4 this 3 3611  5 other 1 3611  
43 0 0 6 47 3471 0 0 233 /**
 * Sorts vectors lexicographically, componentwise.  Returns a number less than
 * 0 if this vector sorts before the other one, greater than zero if it sorts
 * after, 0 if they are equivalent (within the indicated tolerance).
 */ 3 4 this 3 3611  5 other 1 3611  9 threshold 1 3465  
44 0 0 6 48 3613 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 1 4 this 3 3611  
45 0 0 6 48 3613 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 2 4 this 3 3611  9 threshold 1 3465  
46 0 0 6 49 3613 0 0 49 /**
 * Adds the vector into the running hash.
 */ 2 4 this 3 3611  4 hash 1 3613  
47 0 0 6 49 3613 0 0 49 /**
 * Adds the vector into the running hash.
 */ 3 4 this 3 3611  4 hash 1 3613  9 threshold 1 3465  
48 0 0 4 50 3615 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 2 4 this 3 3611  7 hashgen 1 3621  
49 0 0 4 50 3615 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 3 4 this 3 3611  7 hashgen 1 3621  9 threshold 1 3465  
50 0 0 7 51 3610 2002 0 0 1 4 this 3 3611  
51 0 0 7 52 3610 2002 0 0 2 4 this 3 3611  5 other 1 3611  
52 0 0 7 53 3610 2002 0 0 2 4 this 3 3611  5 other 1 3611  
53 0 0 7 54 3610 2002 0 0 2 4 this 3 3611  6 scalar 1 3465  
54 0 0 7 55 3610 2002 0 0 2 4 this 3 3611  6 scalar 1 3465  
55 0 0 6 56 3610 0 0 0 2 4 this 3 3610  5 other 1 3611  
56 0 0 6 57 3610 0 0 0 2 4 this 3 3610  5 other 1 3611  
57 0 0 6 58 3610 0 0 0 2 4 this 3 3610  6 scalar 1 3465  
58 0 0 6 59 3610 0 0 0 2 4 this 3 3610  6 scalar 1 3465  
59 0 0 4 60 3615 0 0 10 /**
 *
 */ 2 4 this 3 3610  5 other 1 3611  
60 0 0 7 61 3610 2002 0 0 2 4 this 3 3611  8 exponent 1 3465  
61 0 0 6 62 3616 0 0 0 2 4 this 3 3610  8 exponent 1 3465  
62 0 0 7 63 3610 2002 0 10 /**
 *
 */ 2 4 this 3 3611  5 other 1 3611  
63 0 0 7 64 3610 2002 0 10 /**
 *
 */ 2 4 this 3 3611  5 other 1 3611  
64 0 0 6 65 3620 0 0 116 /**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */ 2 4 this 3 3611  5 other 1 3611  
65 0 0 6 65 3620 0 0 92 /**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */ 3 4 this 3 3611  5 other 1 3611  9 threshold 1 3465  
66 0 0 4 66 3615 0 0 10 /**
 *
 */ 2 4 this 3 3611  3 out 1 3623  
67 0 0 6 67 3619 0 0 0 1 4 this 3 3611  
68 0 0 4 68 3615 0 0 332 /**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */ 2 4 this 3 3611  11 destination 1 3625  
69 0 0 4 69 3615 0 0 114 /**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */ 2 4 this 3 3610  6 source 1 3627  
70 0 0 4 70 3615 0 0 205 /**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */ 2 4 this 3 3611  11 destination 1 3625  
71 0 0 4 71 3615 0 0 67 /**
 * Reads the vector from the Datagram using get_stdfloat().
 */ 2 4 this 3 3610  6 source 1 3627  
72 0 0 7 72 3630 0 0 0 0 
73 0 0 7 76 3631 2065 0 0 0 
74 0 0 7 76 3631 2065 0 0 1 6 param0 0 3632  
75 0 0 7 76 3631 2065 0 10 /**
 *
 */ 1 10 fill_value 1 3468  
76 0 0 7 76 3631 2065 0 10 /**
 *
 */ 2 1 x 1 3468  1 y 1 3468  
77 0 0 4 77 3615 0 0 0 2 4 this 3 3631  4 size 1 3613  
78 0 0 6 80 3631 0 0 0 2 4 this 3 3631  4 copy 1 3632  
79 0 0 6 80 3631 0 0 0 2 4 this 3 3631  10 fill_value 1 3468  
80 0 0 6 81 3632 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
81 0 0 6 82 3632 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
82 0 0 6 83 3632 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
83 0 0 6 84 3616 0 0 0 1 4 this 3 3632  
84 0 0 6 85 3616 0 0 0 2 4 this 3 3632  9 attr_name 1 3619  
85 0 0 6 86 3471 0 0 0 3 4 this 3 3631  9 attr_name 1 3619  6 assign 1 3616  
86 0 0 4 87 3615 0 0 10 /**
 *
 */ 3 4 this 3 3631  1 i 1 3471  10 assign_val 1 3468  
87 0 0 6 87 3468 0 0 0 2 4 this 3 3632  1 i 1 3471  
88 0 0 6 88 3471 0 0 0 0 
89 0 0 6 89 3620 0 0 91 /**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */ 1 4 this 3 3632  
90 0 0 6 90 3468 0 0 10 /**
 *
 */ 2 4 this 3 3632  1 i 1 3471  
91 0 0 4 91 3615 0 0 10 /**
 *
 */ 3 4 this 3 3631  1 i 1 3471  5 value 1 3468  
92 0 0 6 92 3468 0 0 10 /**
 *
 */ 1 4 this 3 3632  
93 0 0 6 93 3468 0 0 10 /**
 *
 */ 1 4 this 3 3632  
94 0 0 4 94 3615 0 0 10 /**
 *
 */ 2 4 this 3 3631  5 value 1 3468  
95 0 0 4 95 3615 0 0 10 /**
 *
 */ 2 4 this 3 3631  5 value 1 3468  
96 0 0 4 99 3615 0 0 152 // These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages: 3 4 this 3 3631  1 i 1 3471  5 value 1 3468  
97 0 0 4 100 3615 0 0 10 /**
 *
 */ 2 4 this 3 3631  5 value 1 3468  
98 0 0 4 101 3615 0 0 10 /**
 *
 */ 2 4 this 3 3631  5 value 1 3468  
99 0 0 4 102 3615 0 0 155 /**
 * Returns the address of the first of the two data elements in the vector.
 * The next element occupies the next position consecutively in memory.
 */ 1 4 this 3 3632  
100 0 0 6 103 3471 0 0 0 0 
101 0 0 4 104 3615 0 0 129 /**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */ 2 4 this 3 3631  10 fill_value 1 3468  
102 0 0 4 105 3615 0 0 10 /**
 *
 */ 3 4 this 3 3631  1 x 1 3468  1 y 1 3468  
103 0 0 6 106 3468 0 0 10 /**
 *
 */ 2 4 this 3 3632  5 other 1 3632  
104 0 0 6 107 3468 0 0 69 /**
 * Returns the square of the vector's length, cheap and easy.
 */ 1 4 this 3 3632  
105 0 0 6 108 3468 0 0 72 /**
 * Returns the length of the vector, by the Pythagorean theorem.
 */ 1 4 this 3 3632  
106 0 0 6 109 3620 0 0 127 /**
 * Normalizes the vector in place.  Returns true if the vector was normalized,
 * false if it was a zero-length vector.
 */ 1 4 this 3 3631  
107 0 0 7 110 3631 2065 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3632  
108 0 0 7 111 3631 2065 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3632  4 onto 1 3632  
109 0 0 6 112 3620 0 0 0 2 4 this 3 3632  5 other 1 3632  
110 0 0 6 113 3620 0 0 0 2 4 this 3 3632  5 other 1 3632  
111 0 0 6 114 3620 0 0 0 2 4 this 3 3632  5 other 1 3632  
112 0 0 6 115 3471 0 0 97 /**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */ 2 4 this 3 3632  5 other 1 3632  
113 0 0 6 115 3471 0 0 233 /**
 * Sorts vectors lexicographically, componentwise.  Returns a number less than
 * 0 if this vector sorts before the other one, greater than zero if it sorts
 * after, 0 if they are equivalent (within the indicated tolerance).
 */ 3 4 this 3 3632  5 other 1 3632  9 threshold 1 3468  
114 0 0 6 116 3613 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 1 4 this 3 3632  
115 0 0 6 116 3613 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 2 4 this 3 3632  9 threshold 1 3468  
116 0 0 6 117 3613 0 0 49 /**
 * Adds the vector into the running hash.
 */ 2 4 this 3 3632  4 hash 1 3613  
117 0 0 6 117 3613 0 0 49 /**
 * Adds the vector into the running hash.
 */ 3 4 this 3 3632  4 hash 1 3613  9 threshold 1 3468  
118 0 0 4 118 3615 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 2 4 this 3 3632  7 hashgen 1 3621  
119 0 0 4 118 3615 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 3 4 this 3 3632  7 hashgen 1 3621  9 threshold 1 3468  
120 0 0 7 119 3631 2065 0 0 1 4 this 3 3632  
121 0 0 7 120 3631 2065 0 0 2 4 this 3 3632  5 other 1 3632  
122 0 0 7 121 3631 2065 0 0 2 4 this 3 3632  5 other 1 3632  
123 0 0 7 122 3631 2065 0 0 2 4 this 3 3632  6 scalar 1 3468  
124 0 0 7 123 3631 2065 0 0 2 4 this 3 3632  6 scalar 1 3468  
125 0 0 6 124 3631 0 0 0 2 4 this 3 3631  5 other 1 3632  
126 0 0 6 125 3631 0 0 0 2 4 this 3 3631  5 other 1 3632  
127 0 0 6 126 3631 0 0 0 2 4 this 3 3631  6 scalar 1 3468  
128 0 0 6 127 3631 0 0 0 2 4 this 3 3631  6 scalar 1 3468  
129 0 0 4 128 3615 0 0 10 /**
 *
 */ 2 4 this 3 3631  5 other 1 3632  
130 0 0 7 129 3631 2065 0 0 2 4 this 3 3632  8 exponent 1 3468  
131 0 0 6 130 3616 0 0 0 2 4 this 3 3631  8 exponent 1 3468  
132 0 0 7 131 3631 2065 0 10 /**
 *
 */ 2 4 this 3 3632  5 other 1 3632  
133 0 0 7 132 3631 2065 0 10 /**
 *
 */ 2 4 this 3 3632  5 other 1 3632  
134 0 0 6 133 3620 0 0 116 /**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */ 2 4 this 3 3632  5 other 1 3632  
135 0 0 6 133 3620 0 0 92 /**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */ 3 4 this 3 3632  5 other 1 3632  9 threshold 1 3468  
136 0 0 4 134 3615 0 0 10 /**
 *
 */ 2 4 this 3 3632  3 out 1 3623  
137 0 0 6 135 3619 0 0 0 1 4 this 3 3632  
138 0 0 4 136 3615 0 0 332 /**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */ 2 4 this 3 3632  11 destination 1 3625  
139 0 0 4 137 3615 0 0 114 /**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */ 2 4 this 3 3631  6 source 1 3627  
140 0 0 4 138 3615 0 0 205 /**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */ 2 4 this 3 3632  11 destination 1 3625  
141 0 0 4 139 3615 0 0 67 /**
 * Reads the vector from the Datagram using get_stdfloat().
 */ 2 4 this 3 3631  6 source 1 3627  
142 0 0 7 140 3630 0 0 0 0 
143 0 0 7 144 3634 2124 0 0 0 
144 0 0 7 144 3634 2124 0 0 1 6 param0 0 3635  
145 0 0 7 144 3634 2124 0 10 /**
 *
 */ 1 10 fill_value 1 3471  
146 0 0 7 144 3634 2124 0 10 /**
 *
 */ 2 1 x 1 3471  1 y 1 3471  
147 0 0 4 145 3615 0 0 0 2 4 this 3 3634  4 size 1 3613  
148 0 0 6 148 3634 0 0 0 2 4 this 3 3634  4 copy 1 3635  
149 0 0 6 148 3634 0 0 0 2 4 this 3 3634  10 fill_value 1 3471  
150 0 0 6 149 3635 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
151 0 0 6 150 3635 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
152 0 0 6 151 3635 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
153 0 0 6 152 3616 0 0 0 1 4 this 3 3635  
154 0 0 6 153 3616 0 0 0 2 4 this 3 3635  9 attr_name 1 3619  
155 0 0 6 154 3471 0 0 0 3 4 this 3 3634  9 attr_name 1 3619  6 assign 1 3616  
156 0 0 4 155 3615 0 0 10 /**
 *
 */ 3 4 this 3 3634  1 i 1 3471  10 assign_val 1 3471  
157 0 0 6 155 3471 0 0 0 2 4 this 3 3635  1 i 1 3471  
158 0 0 6 156 3471 0 0 0 0 
159 0 0 6 157 3620 0 0 91 /**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */ 1 4 this 3 3635  
160 0 0 6 158 3471 0 0 10 /**
 *
 */ 2 4 this 3 3635  1 i 1 3471  
161 0 0 4 159 3615 0 0 10 /**
 *
 */ 3 4 this 3 3634  1 i 1 3471  5 value 1 3471  
162 0 0 6 160 3471 0 0 10 /**
 *
 */ 1 4 this 3 3635  
163 0 0 6 161 3471 0 0 10 /**
 *
 */ 1 4 this 3 3635  
164 0 0 4 162 3615 0 0 10 /**
 *
 */ 2 4 this 3 3634  5 value 1 3471  
165 0 0 4 163 3615 0 0 10 /**
 *
 */ 2 4 this 3 3634  5 value 1 3471  
166 0 0 4 167 3615 0 0 152 // These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages: 3 4 this 3 3634  1 i 1 3471  5 value 1 3471  
167 0 0 4 168 3615 0 0 10 /**
 *
 */ 2 4 this 3 3634  5 value 1 3471  
168 0 0 4 169 3615 0 0 10 /**
 *
 */ 2 4 this 3 3634  5 value 1 3471  
169 0 0 4 170 3615 0 0 155 /**
 * Returns the address of the first of the two data elements in the vector.
 * The next element occupies the next position consecutively in memory.
 */ 1 4 this 3 3635  
170 0 0 6 171 3471 0 0 0 0 
171 0 0 4 172 3615 0 0 129 /**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */ 2 4 this 3 3634  10 fill_value 1 3471  
172 0 0 4 173 3615 0 0 10 /**
 *
 */ 3 4 this 3 3634  1 x 1 3471  1 y 1 3471  
173 0 0 6 174 3471 0 0 10 /**
 *
 */ 2 4 this 3 3635  5 other 1 3635  
174 0 0 6 175 3471 0 0 69 /**
 * Returns the square of the vector's length, cheap and easy.
 */ 1 4 this 3 3635  
175 0 0 6 176 3620 0 0 0 2 4 this 3 3635  5 other 1 3635  
176 0 0 6 177 3620 0 0 0 2 4 this 3 3635  5 other 1 3635  
177 0 0 6 178 3620 0 0 0 2 4 this 3 3635  5 other 1 3635  
178 0 0 6 179 3471 0 0 97 /**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */ 2 4 this 3 3635  5 other 1 3635  
179 0 0 6 180 3613 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 1 4 this 3 3635  
180 0 0 6 181 3613 0 0 49 /**
 * Adds the vector into the running hash.
 */ 2 4 this 3 3635  4 hash 1 3613  
181 0 0 4 182 3615 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 2 4 this 3 3635  7 hashgen 1 3621  
182 0 0 7 183 3634 2124 0 0 1 4 this 3 3635  
183 0 0 7 184 3634 2124 0 0 2 4 this 3 3635  5 other 1 3635  
184 0 0 7 185 3634 2124 0 0 2 4 this 3 3635  5 other 1 3635  
185 0 0 7 186 3634 2124 0 0 2 4 this 3 3635  6 scalar 1 3471  
186 0 0 7 187 3634 2124 0 0 2 4 this 3 3635  6 scalar 1 3471  
187 0 0 6 188 3634 0 0 0 2 4 this 3 3634  5 other 1 3635  
188 0 0 6 189 3634 0 0 0 2 4 this 3 3634  5 other 1 3635  
189 0 0 6 190 3634 0 0 0 2 4 this 3 3634  6 scalar 1 3471  
190 0 0 6 191 3634 0 0 0 2 4 this 3 3634  6 scalar 1 3471  
191 0 0 4 192 3615 0 0 10 /**
 *
 */ 2 4 this 3 3634  5 other 1 3635  
192 0 0 7 193 3634 2124 0 0 2 4 this 3 3635  8 exponent 1 3471  
193 0 0 6 194 3616 0 0 0 2 4 this 3 3634  8 exponent 1 3471  
194 0 0 7 195 3634 2124 0 10 /**
 *
 */ 2 4 this 3 3635  5 other 1 3635  
195 0 0 7 196 3634 2124 0 10 /**
 *
 */ 2 4 this 3 3635  5 other 1 3635  
196 0 0 6 197 3620 0 0 116 /**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */ 2 4 this 3 3635  5 other 1 3635  
197 0 0 6 197 3620 0 0 92 /**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */ 3 4 this 3 3635  5 other 1 3635  9 threshold 1 3471  
198 0 0 4 198 3615 0 0 10 /**
 *
 */ 2 4 this 3 3635  3 out 1 3623  
199 0 0 6 199 3619 0 0 0 1 4 this 3 3635  
200 0 0 4 200 3615 0 0 332 /**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */ 2 4 this 3 3635  11 destination 1 3625  
201 0 0 4 201 3615 0 0 114 /**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */ 2 4 this 3 3634  6 source 1 3627  
202 0 0 4 202 3615 0 0 205 /**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */ 2 4 this 3 3635  11 destination 1 3625  
203 0 0 4 203 3615 0 0 67 /**
 * Reads the vector from the Datagram using get_stdfloat().
 */ 2 4 this 3 3634  6 source 1 3627  
204 0 0 7 204 3630 0 0 0 0 
205 0 0 7 207 3637 2142 0 0 0 
206 0 0 7 207 3637 2142 0 53 /**
 * Constructs a new LVector2 from a LVecBase2
 */ 1 4 copy 1 3611  
207 0 0 7 207 3637 2142 0 0 1 6 param0 0 3638  
208 0 0 7 207 3637 2142 0 79 /**
 * Constructs a new LVector2 with all components set to the fill value.
 */ 1 10 fill_value 1 3465  
209 0 0 7 207 3637 2142 0 10 /**
 *
 */ 2 1 x 1 3465  1 y 1 3465  
210 0 0 6 208 3616 0 0 0 2 4 this 3 3638  9 attr_name 1 3619  
211 0 0 6 209 3471 0 0 0 3 4 this 3 3637  9 attr_name 1 3619  6 assign 1 3616  
212 0 0 6 210 3638 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
213 0 0 6 211 3638 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
214 0 0 6 212 3638 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
215 0 0 7 213 3637 2142 0 0 1 4 this 3 3638  
216 0 0 7 214 3610 2002 0 0 2 4 this 3 3638  5 other 1 3611  
217 0 0 7 214 3637 2142 0 0 2 4 this 3 3638  5 other 1 3638  
218 0 0 7 215 3610 2002 0 0 2 4 this 3 3638  5 other 1 3611  
219 0 0 7 215 3637 2142 0 0 2 4 this 3 3638  5 other 1 3638  
220 0 0 7 216 3637 2142 0 0 2 4 this 3 3638  6 scalar 1 3465  
221 0 0 7 217 3637 2142 0 0 2 4 this 3 3638  6 scalar 1 3465  
222 0 0 7 218 3637 2142 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3638  
223 0 0 7 219 3637 2142 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3638  4 onto 1 3611  
224 0 0 6 220 3465 0 0 92 /**
 * returns the signed angled between two vectors.  normalization is NOT
 * necessary
 */ 2 4 this 3 3638  5 other 1 3638  
225 0 0 6 221 3465 0 0 92 /**
 * returns the signed angled between two vectors.  normalization is NOT
 * necessary
 */ 2 4 this 3 3638  5 other 1 3638  
226 0 0 6 222 3619 0 0 0 1 4 this 3 3638  
227 0 0 7 223 3630 0 0 0 0 
228 0 0 7 226 3640 2160 0 0 0 
229 0 0 7 226 3640 2160 0 53 /**
 * Constructs a new LVector2 from a LVecBase2
 */ 1 4 copy 1 3632  
230 0 0 7 226 3640 2160 0 0 1 6 param0 0 3641  
231 0 0 7 226 3640 2160 0 79 /**
 * Constructs a new LVector2 with all components set to the fill value.
 */ 1 10 fill_value 1 3468  
232 0 0 7 226 3640 2160 0 10 /**
 *
 */ 2 1 x 1 3468  1 y 1 3468  
233 0 0 6 227 3616 0 0 0 2 4 this 3 3641  9 attr_name 1 3619  
234 0 0 6 228 3471 0 0 0 3 4 this 3 3640  9 attr_name 1 3619  6 assign 1 3616  
235 0 0 6 229 3641 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
236 0 0 6 230 3641 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
237 0 0 6 231 3641 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
238 0 0 7 232 3640 2160 0 0 1 4 this 3 3641  
239 0 0 7 233 3631 2065 0 0 2 4 this 3 3641  5 other 1 3632  
240 0 0 7 233 3640 2160 0 0 2 4 this 3 3641  5 other 1 3641  
241 0 0 7 234 3631 2065 0 0 2 4 this 3 3641  5 other 1 3632  
242 0 0 7 234 3640 2160 0 0 2 4 this 3 3641  5 other 1 3641  
243 0 0 7 235 3640 2160 0 0 2 4 this 3 3641  6 scalar 1 3468  
244 0 0 7 236 3640 2160 0 0 2 4 this 3 3641  6 scalar 1 3468  
245 0 0 7 237 3640 2160 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3641  
246 0 0 7 238 3640 2160 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3641  4 onto 1 3632  
247 0 0 6 239 3468 0 0 92 /**
 * returns the signed angled between two vectors.  normalization is NOT
 * necessary
 */ 2 4 this 3 3641  5 other 1 3641  
248 0 0 6 240 3468 0 0 92 /**
 * returns the signed angled between two vectors.  normalization is NOT
 * necessary
 */ 2 4 this 3 3641  5 other 1 3641  
249 0 0 6 241 3619 0 0 0 1 4 this 3 3641  
250 0 0 7 242 3630 0 0 0 0 
251 0 0 7 245 3643 2174 0 0 0 
252 0 0 7 245 3643 2174 0 53 /**
 * Constructs a new LVector2 from a LVecBase2
 */ 1 4 copy 1 3635  
253 0 0 7 245 3643 2174 0 0 1 6 param0 0 3644  
254 0 0 7 245 3643 2174 0 79 /**
 * Constructs a new LVector2 with all components set to the fill value.
 */ 1 10 fill_value 1 3471  
255 0 0 7 245 3643 2174 0 10 /**
 *
 */ 2 1 x 1 3471  1 y 1 3471  
256 0 0 6 246 3616 0 0 0 2 4 this 3 3644  9 attr_name 1 3619  
257 0 0 6 247 3471 0 0 0 3 4 this 3 3643  9 attr_name 1 3619  6 assign 1 3616  
258 0 0 6 248 3644 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
259 0 0 6 249 3644 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
260 0 0 6 250 3644 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
261 0 0 7 251 3643 2174 0 0 1 4 this 3 3644  
262 0 0 7 252 3634 2124 0 0 2 4 this 3 3644  5 other 1 3635  
263 0 0 7 252 3643 2174 0 0 2 4 this 3 3644  5 other 1 3644  
264 0 0 7 253 3634 2124 0 0 2 4 this 3 3644  5 other 1 3635  
265 0 0 7 253 3643 2174 0 0 2 4 this 3 3644  5 other 1 3644  
266 0 0 7 254 3643 2174 0 0 2 4 this 3 3644  6 scalar 1 3471  
267 0 0 7 255 3643 2174 0 0 2 4 this 3 3644  6 scalar 1 3471  
268 0 0 6 256 3619 0 0 0 1 4 this 3 3644  
269 0 0 7 257 3630 0 0 0 0 
270 0 0 7 260 3646 2190 0 0 0 
271 0 0 7 260 3646 2190 0 0 1 6 param0 0 3647  
272 0 0 7 260 3646 2190 0 52 /**
 * Constructs a new LPoint2 from a LVecBase2
 */ 1 4 copy 1 3611  
273 0 0 7 260 3646 2190 0 73 /**
 * Constructs a new LPoint2 all components set to the fill value.
 */ 1 10 fill_value 1 3465  
274 0 0 7 260 3646 2190 0 61 /**
 * Constructs a new LPoint2 with the given components
 */ 2 1 x 1 3465  1 y 1 3465  
275 0 0 6 261 3616 0 0 0 2 4 this 3 3647  9 attr_name 1 3619  
276 0 0 6 262 3471 0 0 0 3 4 this 3 3646  9 attr_name 1 3619  6 assign 1 3616  
277 0 0 6 263 3647 0 0 39 /**
 * Returns a zero-length point.
 */ 0 
278 0 0 6 264 3647 0 0 34 /**
 * Returns a unit X point.
 */ 0 
279 0 0 6 265 3647 0 0 34 /**
 * Returns a unit Y point.
 */ 0 
280 0 0 7 266 3646 2190 0 0 1 4 this 3 3647  
281 0 0 7 267 3610 2002 0 0 2 4 this 3 3647  5 other 1 3611  
282 0 0 7 267 3646 2190 0 0 2 4 this 3 3647  5 other 1 3638  
283 0 0 7 268 3637 2142 0 0 2 4 this 3 3647  5 other 1 3647  
284 0 0 7 268 3610 2002 0 0 2 4 this 3 3647  5 other 1 3611  
285 0 0 7 268 3646 2190 0 0 2 4 this 3 3647  5 other 1 3638  
286 0 0 7 269 3646 2190 0 0 2 4 this 3 3647  6 scalar 1 3465  
287 0 0 7 270 3646 2190 0 0 2 4 this 3 3647  6 scalar 1 3465  
288 0 0 7 271 3646 2190 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3647  
289 0 0 7 272 3646 2190 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3647  4 onto 1 3611  
290 0 0 6 273 3619 0 0 0 1 4 this 3 3647  
291 0 0 7 274 3630 0 0 0 0 
292 0 0 7 277 3649 2206 0 0 0 
293 0 0 7 277 3649 2206 0 0 1 6 param0 0 3650  
294 0 0 7 277 3649 2206 0 52 /**
 * Constructs a new LPoint2 from a LVecBase2
 */ 1 4 copy 1 3632  
295 0 0 7 277 3649 2206 0 73 /**
 * Constructs a new LPoint2 all components set to the fill value.
 */ 1 10 fill_value 1 3468  
296 0 0 7 277 3649 2206 0 61 /**
 * Constructs a new LPoint2 with the given components
 */ 2 1 x 1 3468  1 y 1 3468  
297 0 0 6 278 3616 0 0 0 2 4 this 3 3650  9 attr_name 1 3619  
298 0 0 6 279 3471 0 0 0 3 4 this 3 3649  9 attr_name 1 3619  6 assign 1 3616  
299 0 0 6 280 3650 0 0 39 /**
 * Returns a zero-length point.
 */ 0 
300 0 0 6 281 3650 0 0 34 /**
 * Returns a unit X point.
 */ 0 
301 0 0 6 282 3650 0 0 34 /**
 * Returns a unit Y point.
 */ 0 
302 0 0 7 283 3649 2206 0 0 1 4 this 3 3650  
303 0 0 7 284 3631 2065 0 0 2 4 this 3 3650  5 other 1 3632  
304 0 0 7 284 3649 2206 0 0 2 4 this 3 3650  5 other 1 3641  
305 0 0 7 285 3640 2160 0 0 2 4 this 3 3650  5 other 1 3650  
306 0 0 7 285 3631 2065 0 0 2 4 this 3 3650  5 other 1 3632  
307 0 0 7 285 3649 2206 0 0 2 4 this 3 3650  5 other 1 3641  
308 0 0 7 286 3649 2206 0 0 2 4 this 3 3650  6 scalar 1 3468  
309 0 0 7 287 3649 2206 0 0 2 4 this 3 3650  6 scalar 1 3468  
310 0 0 7 288 3649 2206 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3650  
311 0 0 7 289 3649 2206 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3650  4 onto 1 3632  
312 0 0 6 290 3619 0 0 0 1 4 this 3 3650  
313 0 0 7 291 3630 0 0 0 0 
314 0 0 7 294 3652 2220 0 0 0 
315 0 0 7 294 3652 2220 0 0 1 6 param0 0 3653  
316 0 0 7 294 3652 2220 0 52 /**
 * Constructs a new LPoint2 from a LVecBase2
 */ 1 4 copy 1 3635  
317 0 0 7 294 3652 2220 0 73 /**
 * Constructs a new LPoint2 all components set to the fill value.
 */ 1 10 fill_value 1 3471  
318 0 0 7 294 3652 2220 0 61 /**
 * Constructs a new LPoint2 with the given components
 */ 2 1 x 1 3471  1 y 1 3471  
319 0 0 6 295 3616 0 0 0 2 4 this 3 3653  9 attr_name 1 3619  
320 0 0 6 296 3471 0 0 0 3 4 this 3 3652  9 attr_name 1 3619  6 assign 1 3616  
321 0 0 6 297 3653 0 0 39 /**
 * Returns a zero-length point.
 */ 0 
322 0 0 6 298 3653 0 0 34 /**
 * Returns a unit X point.
 */ 0 
323 0 0 6 299 3653 0 0 34 /**
 * Returns a unit Y point.
 */ 0 
324 0 0 7 300 3652 2220 0 0 1 4 this 3 3653  
325 0 0 7 301 3634 2124 0 0 2 4 this 3 3653  5 other 1 3635  
326 0 0 7 301 3652 2220 0 0 2 4 this 3 3653  5 other 1 3644  
327 0 0 7 302 3643 2174 0 0 2 4 this 3 3653  5 other 1 3653  
328 0 0 7 302 3634 2124 0 0 2 4 this 3 3653  5 other 1 3635  
329 0 0 7 302 3652 2220 0 0 2 4 this 3 3653  5 other 1 3644  
330 0 0 7 303 3652 2220 0 0 2 4 this 3 3653  6 scalar 1 3471  
331 0 0 7 304 3652 2220 0 0 2 4 this 3 3653  6 scalar 1 3471  
332 0 0 6 305 3619 0 0 0 1 4 this 3 3653  
333 0 0 7 306 3630 0 0 0 0 
334 0 0 7 310 3655 2293 0 0 0 
335 0 0 7 310 3655 2293 0 10 /**
 *
 */ 2 4 copy 1 3611  1 z 1 3465  
336 0 0 7 310 3655 2293 0 0 1 6 param0 0 3656  
337 0 0 7 310 3655 2293 0 10 /**
 *
 */ 1 10 fill_value 1 3465  
338 0 0 7 310 3655 2293 0 10 /**
 *
 */ 3 1 x 1 3465  1 y 1 3465  1 z 1 3465  
339 0 0 4 311 3615 0 0 0 2 4 this 3 3655  4 size 1 3613  
340 0 0 6 314 3655 0 0 0 2 4 this 3 3655  4 copy 1 3656  
341 0 0 6 314 3655 0 0 0 2 4 this 3 3655  10 fill_value 1 3465  
342 0 0 6 315 3656 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
343 0 0 6 316 3656 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
344 0 0 6 317 3656 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
345 0 0 6 318 3656 0 0 35 /**
 * Returns a unit Z vector.
 */ 0 
346 0 0 6 319 3616 0 0 0 1 4 this 3 3656  
347 0 0 6 320 3616 0 0 0 2 4 this 3 3656  9 attr_name 1 3619  
348 0 0 6 321 3471 0 0 0 3 4 this 3 3655  9 attr_name 1 3619  6 assign 1 3616  
349 0 0 4 322 3615 0 0 10 /**
 *
 */ 3 4 this 3 3655  1 i 1 3471  10 assign_val 1 3465  
350 0 0 6 322 3465 0 0 0 2 4 this 3 3656  1 i 1 3471  
351 0 0 6 323 3471 0 0 0 0 
352 0 0 6 324 3620 0 0 91 /**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */ 1 4 this 3 3656  
353 0 0 6 325 3465 0 0 10 /**
 *
 */ 2 4 this 3 3656  1 i 1 3471  
354 0 0 6 326 3465 0 0 10 /**
 *
 */ 1 4 this 3 3656  
355 0 0 6 327 3465 0 0 10 /**
 *
 */ 1 4 this 3 3656  
356 0 0 6 328 3465 0 0 10 /**
 *
 */ 1 4 this 3 3656  
357 0 0 4 329 3615 0 0 10 /**
 *
 */ 3 4 this 3 3655  1 i 1 3471  5 value 1 3465  
358 0 0 4 330 3615 0 0 10 /**
 *
 */ 2 4 this 3 3655  5 value 1 3465  
359 0 0 4 331 3615 0 0 10 /**
 *
 */ 2 4 this 3 3655  5 value 1 3465  
360 0 0 4 332 3615 0 0 10 /**
 *
 */ 2 4 this 3 3655  5 value 1 3465  
361 0 0 7 333 3610 2002 0 100 /**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */ 1 4 this 3 3656  
362 0 0 7 334 3610 2002 0 105 /**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */ 1 4 this 3 3656  
363 0 0 7 335 3610 2002 0 99 /**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */ 1 4 this 3 3656  
364 0 0 4 342 3615 0 0 152 // These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages: 3 4 this 3 3655  1 i 1 3471  5 value 1 3465  
365 0 0 4 343 3615 0 0 10 /**
 *
 */ 2 4 this 3 3655  5 value 1 3465  
366 0 0 4 344 3615 0 0 10 /**
 *
 */ 2 4 this 3 3655  5 value 1 3465  
367 0 0 4 345 3615 0 0 10 /**
 *
 */ 2 4 this 3 3655  5 value 1 3465  
368 0 0 4 346 3615 0 0 162 /**
 * Returns the address of the first of the three data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */ 1 4 this 3 3656  
369 0 0 6 347 3471 0 0 0 0 
370 0 0 4 348 3615 0 0 129 /**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */ 2 4 this 3 3655  10 fill_value 1 3465  
371 0 0 4 349 3615 0 0 10 /**
 *
 */ 4 4 this 3 3655  1 x 1 3465  1 y 1 3465  1 z 1 3465  
372 0 0 6 350 3465 0 0 10 /**
 *
 */ 2 4 this 3 3656  5 other 1 3656  
373 0 0 6 351 3465 0 0 69 /**
 * Returns the square of the vector's length, cheap and easy.
 */ 1 4 this 3 3656  
374 0 0 6 352 3465 0 0 72 /**
 * Returns the length of the vector, by the Pythagorean theorem.
 */ 1 4 this 3 3656  
375 0 0 6 353 3620 0 0 127 /**
 * Normalizes the vector in place.  Returns true if the vector was normalized,
 * false if it was a zero-length vector.
 */ 1 4 this 3 3655  
376 0 0 7 354 3655 2293 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3656  
377 0 0 7 355 3655 2293 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3656  4 onto 1 3656  
378 0 0 7 356 3655 2293 0 10 /**
 *
 */ 2 4 this 3 3656  5 other 1 3656  
379 0 0 6 357 3620 0 0 0 2 4 this 3 3656  5 other 1 3656  
380 0 0 6 358 3620 0 0 0 2 4 this 3 3656  5 other 1 3656  
381 0 0 6 359 3620 0 0 0 2 4 this 3 3656  5 other 1 3656  
382 0 0 7 360 3655 2293 0 623 /**
 * Try to un-spin the hpr to a standard form.  Like all standards, someone
 * decides between many arbitrary possible standards.  This function assumes
 * that 0 and 360 are the same, as is 720 and -360.  Also 180 and -180 are the
 * same.  Another example is -90 and 270. Each element will be in the range
 * -180.0 to 179.99999. The original usage of this function is for human
 * readable output.
 *
 * It doesn't work so well for asserting that foo_hpr is roughly equal to
 * bar_hpr.  Try using LQuaternionf::is_same_direction() for that.  See Also:
 * get_standardized_rotation, LQuaternion::is_same_direction
 */ 1 4 this 3 3656  
383 0 0 6 361 3471 0 0 97 /**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */ 2 4 this 3 3656  5 other 1 3656  
384 0 0 6 361 3471 0 0 233 /**
 * Sorts vectors lexicographically, componentwise.  Returns a number less than
 * 0 if this vector sorts before the other one, greater than zero if it sorts
 * after, 0 if they are equivalent (within the indicated tolerance).
 */ 3 4 this 3 3656  5 other 1 3656  9 threshold 1 3465  
385 0 0 6 362 3613 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 1 4 this 3 3656  
386 0 0 6 362 3613 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 2 4 this 3 3656  9 threshold 1 3465  
387 0 0 6 363 3613 0 0 49 /**
 * Adds the vector into the running hash.
 */ 2 4 this 3 3656  4 hash 1 3613  
388 0 0 6 363 3613 0 0 49 /**
 * Adds the vector into the running hash.
 */ 3 4 this 3 3656  4 hash 1 3613  9 threshold 1 3465  
389 0 0 4 364 3615 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 2 4 this 3 3656  7 hashgen 1 3621  
390 0 0 4 364 3615 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 3 4 this 3 3656  7 hashgen 1 3621  9 threshold 1 3465  
391 0 0 7 365 3655 2293 0 0 1 4 this 3 3656  
392 0 0 7 366 3655 2293 0 0 2 4 this 3 3656  5 other 1 3656  
393 0 0 7 367 3655 2293 0 0 2 4 this 3 3656  5 other 1 3656  
394 0 0 7 368 3655 2293 0 0 2 4 this 3 3656  6 scalar 1 3465  
395 0 0 7 369 3655 2293 0 0 2 4 this 3 3656  6 scalar 1 3465  
396 0 0 6 370 3655 0 0 0 2 4 this 3 3655  5 other 1 3656  
397 0 0 6 371 3655 0 0 0 2 4 this 3 3655  5 other 1 3656  
398 0 0 6 372 3655 0 0 0 2 4 this 3 3655  6 scalar 1 3465  
399 0 0 6 373 3655 0 0 0 2 4 this 3 3655  6 scalar 1 3465  
400 0 0 4 374 3615 0 0 10 /**
 *
 */ 2 4 this 3 3655  5 other 1 3656  
401 0 0 7 375 3655 2293 0 0 2 4 this 3 3656  8 exponent 1 3465  
402 0 0 6 376 3616 0 0 0 2 4 this 3 3655  8 exponent 1 3465  
403 0 0 7 377 3655 2293 0 10 /**
 *
 */ 2 4 this 3 3656  5 other 1 3656  
404 0 0 7 378 3655 2293 0 10 /**
 *
 */ 2 4 this 3 3656  5 other 1 3656  
405 0 0 4 379 3615 0 0 10 /**
 *
 */ 2 4 this 3 3655  5 other 1 3656  
406 0 0 6 380 3620 0 0 116 /**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */ 2 4 this 3 3656  5 other 1 3656  
407 0 0 6 380 3620 0 0 92 /**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */ 3 4 this 3 3656  5 other 1 3656  9 threshold 1 3465  
408 0 0 4 381 3615 0 0 10 /**
 *
 */ 2 4 this 3 3656  3 out 1 3623  
409 0 0 6 382 3619 0 0 0 1 4 this 3 3656  
410 0 0 4 383 3615 0 0 332 /**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */ 2 4 this 3 3656  11 destination 1 3625  
411 0 0 4 384 3615 0 0 114 /**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */ 2 4 this 3 3655  6 source 1 3627  
412 0 0 4 385 3615 0 0 205 /**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */ 2 4 this 3 3656  11 destination 1 3625  
413 0 0 4 386 3615 0 0 67 /**
 * Reads the vector from the Datagram using get_stdfloat().
 */ 2 4 this 3 3655  6 source 1 3627  
414 0 0 7 387 3630 0 0 0 0 
415 0 0 7 391 3658 2366 0 0 0 
416 0 0 7 391 3658 2366 0 10 /**
 *
 */ 2 4 copy 1 3632  1 z 1 3468  
417 0 0 7 391 3658 2366 0 0 1 6 param0 0 3659  
418 0 0 7 391 3658 2366 0 10 /**
 *
 */ 1 10 fill_value 1 3468  
419 0 0 7 391 3658 2366 0 10 /**
 *
 */ 3 1 x 1 3468  1 y 1 3468  1 z 1 3468  
420 0 0 4 392 3615 0 0 0 2 4 this 3 3658  4 size 1 3613  
421 0 0 6 395 3658 0 0 0 2 4 this 3 3658  4 copy 1 3659  
422 0 0 6 395 3658 0 0 0 2 4 this 3 3658  10 fill_value 1 3468  
423 0 0 6 396 3659 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
424 0 0 6 397 3659 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
425 0 0 6 398 3659 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
426 0 0 6 399 3659 0 0 35 /**
 * Returns a unit Z vector.
 */ 0 
427 0 0 6 400 3616 0 0 0 1 4 this 3 3659  
428 0 0 6 401 3616 0 0 0 2 4 this 3 3659  9 attr_name 1 3619  
429 0 0 6 402 3471 0 0 0 3 4 this 3 3658  9 attr_name 1 3619  6 assign 1 3616  
430 0 0 4 403 3615 0 0 10 /**
 *
 */ 3 4 this 3 3658  1 i 1 3471  10 assign_val 1 3468  
431 0 0 6 403 3468 0 0 0 2 4 this 3 3659  1 i 1 3471  
432 0 0 6 404 3471 0 0 0 0 
433 0 0 6 405 3620 0 0 91 /**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */ 1 4 this 3 3659  
434 0 0 6 406 3468 0 0 10 /**
 *
 */ 2 4 this 3 3659  1 i 1 3471  
435 0 0 6 407 3468 0 0 10 /**
 *
 */ 1 4 this 3 3659  
436 0 0 6 408 3468 0 0 10 /**
 *
 */ 1 4 this 3 3659  
437 0 0 6 409 3468 0 0 10 /**
 *
 */ 1 4 this 3 3659  
438 0 0 4 410 3615 0 0 10 /**
 *
 */ 3 4 this 3 3658  1 i 1 3471  5 value 1 3468  
439 0 0 4 411 3615 0 0 10 /**
 *
 */ 2 4 this 3 3658  5 value 1 3468  
440 0 0 4 412 3615 0 0 10 /**
 *
 */ 2 4 this 3 3658  5 value 1 3468  
441 0 0 4 413 3615 0 0 10 /**
 *
 */ 2 4 this 3 3658  5 value 1 3468  
442 0 0 7 414 3631 2065 0 100 /**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */ 1 4 this 3 3659  
443 0 0 7 415 3631 2065 0 105 /**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */ 1 4 this 3 3659  
444 0 0 7 416 3631 2065 0 99 /**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */ 1 4 this 3 3659  
445 0 0 4 423 3615 0 0 152 // These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages: 3 4 this 3 3658  1 i 1 3471  5 value 1 3468  
446 0 0 4 424 3615 0 0 10 /**
 *
 */ 2 4 this 3 3658  5 value 1 3468  
447 0 0 4 425 3615 0 0 10 /**
 *
 */ 2 4 this 3 3658  5 value 1 3468  
448 0 0 4 426 3615 0 0 10 /**
 *
 */ 2 4 this 3 3658  5 value 1 3468  
449 0 0 4 427 3615 0 0 162 /**
 * Returns the address of the first of the three data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */ 1 4 this 3 3659  
450 0 0 6 428 3471 0 0 0 0 
451 0 0 4 429 3615 0 0 129 /**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */ 2 4 this 3 3658  10 fill_value 1 3468  
452 0 0 4 430 3615 0 0 10 /**
 *
 */ 4 4 this 3 3658  1 x 1 3468  1 y 1 3468  1 z 1 3468  
453 0 0 6 431 3468 0 0 10 /**
 *
 */ 2 4 this 3 3659  5 other 1 3659  
454 0 0 6 432 3468 0 0 69 /**
 * Returns the square of the vector's length, cheap and easy.
 */ 1 4 this 3 3659  
455 0 0 6 433 3468 0 0 72 /**
 * Returns the length of the vector, by the Pythagorean theorem.
 */ 1 4 this 3 3659  
456 0 0 6 434 3620 0 0 127 /**
 * Normalizes the vector in place.  Returns true if the vector was normalized,
 * false if it was a zero-length vector.
 */ 1 4 this 3 3658  
457 0 0 7 435 3658 2366 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3659  
458 0 0 7 436 3658 2366 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3659  4 onto 1 3659  
459 0 0 7 437 3658 2366 0 10 /**
 *
 */ 2 4 this 3 3659  5 other 1 3659  
460 0 0 6 438 3620 0 0 0 2 4 this 3 3659  5 other 1 3659  
461 0 0 6 439 3620 0 0 0 2 4 this 3 3659  5 other 1 3659  
462 0 0 6 440 3620 0 0 0 2 4 this 3 3659  5 other 1 3659  
463 0 0 7 441 3658 2366 0 623 /**
 * Try to un-spin the hpr to a standard form.  Like all standards, someone
 * decides between many arbitrary possible standards.  This function assumes
 * that 0 and 360 are the same, as is 720 and -360.  Also 180 and -180 are the
 * same.  Another example is -90 and 270. Each element will be in the range
 * -180.0 to 179.99999. The original usage of this function is for human
 * readable output.
 *
 * It doesn't work so well for asserting that foo_hpr is roughly equal to
 * bar_hpr.  Try using LQuaternionf::is_same_direction() for that.  See Also:
 * get_standardized_rotation, LQuaternion::is_same_direction
 */ 1 4 this 3 3659  
464 0 0 6 442 3471 0 0 97 /**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */ 2 4 this 3 3659  5 other 1 3659  
465 0 0 6 442 3471 0 0 233 /**
 * Sorts vectors lexicographically, componentwise.  Returns a number less than
 * 0 if this vector sorts before the other one, greater than zero if it sorts
 * after, 0 if they are equivalent (within the indicated tolerance).
 */ 3 4 this 3 3659  5 other 1 3659  9 threshold 1 3468  
466 0 0 6 443 3613 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 1 4 this 3 3659  
467 0 0 6 443 3613 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 2 4 this 3 3659  9 threshold 1 3468  
468 0 0 6 444 3613 0 0 49 /**
 * Adds the vector into the running hash.
 */ 2 4 this 3 3659  4 hash 1 3613  
469 0 0 6 444 3613 0 0 49 /**
 * Adds the vector into the running hash.
 */ 3 4 this 3 3659  4 hash 1 3613  9 threshold 1 3468  
470 0 0 4 445 3615 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 2 4 this 3 3659  7 hashgen 1 3621  
471 0 0 4 445 3615 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 3 4 this 3 3659  7 hashgen 1 3621  9 threshold 1 3468  
472 0 0 7 446 3658 2366 0 0 1 4 this 3 3659  
473 0 0 7 447 3658 2366 0 0 2 4 this 3 3659  5 other 1 3659  
474 0 0 7 448 3658 2366 0 0 2 4 this 3 3659  5 other 1 3659  
475 0 0 7 449 3658 2366 0 0 2 4 this 3 3659  6 scalar 1 3468  
476 0 0 7 450 3658 2366 0 0 2 4 this 3 3659  6 scalar 1 3468  
477 0 0 6 451 3658 0 0 0 2 4 this 3 3658  5 other 1 3659  
478 0 0 6 452 3658 0 0 0 2 4 this 3 3658  5 other 1 3659  
479 0 0 6 453 3658 0 0 0 2 4 this 3 3658  6 scalar 1 3468  
480 0 0 6 454 3658 0 0 0 2 4 this 3 3658  6 scalar 1 3468  
481 0 0 4 455 3615 0 0 10 /**
 *
 */ 2 4 this 3 3658  5 other 1 3659  
482 0 0 7 456 3658 2366 0 0 2 4 this 3 3659  8 exponent 1 3468  
483 0 0 6 457 3616 0 0 0 2 4 this 3 3658  8 exponent 1 3468  
484 0 0 7 458 3658 2366 0 10 /**
 *
 */ 2 4 this 3 3659  5 other 1 3659  
485 0 0 7 459 3658 2366 0 10 /**
 *
 */ 2 4 this 3 3659  5 other 1 3659  
486 0 0 4 460 3615 0 0 10 /**
 *
 */ 2 4 this 3 3658  5 other 1 3659  
487 0 0 6 461 3620 0 0 116 /**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */ 2 4 this 3 3659  5 other 1 3659  
488 0 0 6 461 3620 0 0 92 /**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */ 3 4 this 3 3659  5 other 1 3659  9 threshold 1 3468  
489 0 0 4 462 3615 0 0 10 /**
 *
 */ 2 4 this 3 3659  3 out 1 3623  
490 0 0 6 463 3619 0 0 0 1 4 this 3 3659  
491 0 0 4 464 3615 0 0 332 /**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */ 2 4 this 3 3659  11 destination 1 3625  
492 0 0 4 465 3615 0 0 114 /**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */ 2 4 this 3 3658  6 source 1 3627  
493 0 0 4 466 3615 0 0 205 /**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */ 2 4 this 3 3659  11 destination 1 3625  
494 0 0 4 467 3615 0 0 67 /**
 * Reads the vector from the Datagram using get_stdfloat().
 */ 2 4 this 3 3658  6 source 1 3627  
495 0 0 7 468 3630 0 0 0 0 
496 0 0 7 472 3661 2434 0 0 0 
497 0 0 7 472 3661 2434 0 10 /**
 *
 */ 2 4 copy 1 3635  1 z 1 3471  
498 0 0 7 472 3661 2434 0 0 1 6 param0 0 3662  
499 0 0 7 472 3661 2434 0 10 /**
 *
 */ 1 10 fill_value 1 3471  
500 0 0 7 472 3661 2434 0 10 /**
 *
 */ 3 1 x 1 3471  1 y 1 3471  1 z 1 3471  
501 0 0 4 473 3615 0 0 0 2 4 this 3 3661  4 size 1 3613  
502 0 0 6 476 3661 0 0 0 2 4 this 3 3661  4 copy 1 3662  
503 0 0 6 476 3661 0 0 0 2 4 this 3 3661  10 fill_value 1 3471  
504 0 0 6 477 3662 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
505 0 0 6 478 3662 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
506 0 0 6 479 3662 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
507 0 0 6 480 3662 0 0 35 /**
 * Returns a unit Z vector.
 */ 0 
508 0 0 6 481 3616 0 0 0 1 4 this 3 3662  
509 0 0 6 482 3616 0 0 0 2 4 this 3 3662  9 attr_name 1 3619  
510 0 0 6 483 3471 0 0 0 3 4 this 3 3661  9 attr_name 1 3619  6 assign 1 3616  
511 0 0 4 484 3615 0 0 10 /**
 *
 */ 3 4 this 3 3661  1 i 1 3471  10 assign_val 1 3471  
512 0 0 6 484 3471 0 0 0 2 4 this 3 3662  1 i 1 3471  
513 0 0 6 485 3471 0 0 0 0 
514 0 0 6 486 3620 0 0 91 /**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */ 1 4 this 3 3662  
515 0 0 6 487 3471 0 0 10 /**
 *
 */ 2 4 this 3 3662  1 i 1 3471  
516 0 0 6 488 3471 0 0 10 /**
 *
 */ 1 4 this 3 3662  
517 0 0 6 489 3471 0 0 10 /**
 *
 */ 1 4 this 3 3662  
518 0 0 6 490 3471 0 0 10 /**
 *
 */ 1 4 this 3 3662  
519 0 0 4 491 3615 0 0 10 /**
 *
 */ 3 4 this 3 3661  1 i 1 3471  5 value 1 3471  
520 0 0 4 492 3615 0 0 10 /**
 *
 */ 2 4 this 3 3661  5 value 1 3471  
521 0 0 4 493 3615 0 0 10 /**
 *
 */ 2 4 this 3 3661  5 value 1 3471  
522 0 0 4 494 3615 0 0 10 /**
 *
 */ 2 4 this 3 3661  5 value 1 3471  
523 0 0 7 495 3634 2124 0 100 /**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */ 1 4 this 3 3662  
524 0 0 7 496 3634 2124 0 105 /**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */ 1 4 this 3 3662  
525 0 0 7 497 3634 2124 0 99 /**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */ 1 4 this 3 3662  
526 0 0 4 504 3615 0 0 152 // These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages: 3 4 this 3 3661  1 i 1 3471  5 value 1 3471  
527 0 0 4 505 3615 0 0 10 /**
 *
 */ 2 4 this 3 3661  5 value 1 3471  
528 0 0 4 506 3615 0 0 10 /**
 *
 */ 2 4 this 3 3661  5 value 1 3471  
529 0 0 4 507 3615 0 0 10 /**
 *
 */ 2 4 this 3 3661  5 value 1 3471  
530 0 0 4 508 3615 0 0 162 /**
 * Returns the address of the first of the three data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */ 1 4 this 3 3662  
531 0 0 6 509 3471 0 0 0 0 
532 0 0 4 510 3615 0 0 129 /**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */ 2 4 this 3 3661  10 fill_value 1 3471  
533 0 0 4 511 3615 0 0 10 /**
 *
 */ 4 4 this 3 3661  1 x 1 3471  1 y 1 3471  1 z 1 3471  
534 0 0 6 512 3471 0 0 10 /**
 *
 */ 2 4 this 3 3662  5 other 1 3662  
535 0 0 6 513 3471 0 0 69 /**
 * Returns the square of the vector's length, cheap and easy.
 */ 1 4 this 3 3662  
536 0 0 7 514 3661 2434 0 10 /**
 *
 */ 2 4 this 3 3662  5 other 1 3662  
537 0 0 6 515 3620 0 0 0 2 4 this 3 3662  5 other 1 3662  
538 0 0 6 516 3620 0 0 0 2 4 this 3 3662  5 other 1 3662  
539 0 0 6 517 3620 0 0 0 2 4 this 3 3662  5 other 1 3662  
540 0 0 6 518 3471 0 0 97 /**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */ 2 4 this 3 3662  5 other 1 3662  
541 0 0 6 519 3613 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 1 4 this 3 3662  
542 0 0 6 520 3613 0 0 49 /**
 * Adds the vector into the running hash.
 */ 2 4 this 3 3662  4 hash 1 3613  
543 0 0 4 521 3615 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 2 4 this 3 3662  7 hashgen 1 3621  
544 0 0 7 522 3661 2434 0 0 1 4 this 3 3662  
545 0 0 7 523 3661 2434 0 0 2 4 this 3 3662  5 other 1 3662  
546 0 0 7 524 3661 2434 0 0 2 4 this 3 3662  5 other 1 3662  
547 0 0 7 525 3661 2434 0 0 2 4 this 3 3662  6 scalar 1 3471  
548 0 0 7 526 3661 2434 0 0 2 4 this 3 3662  6 scalar 1 3471  
549 0 0 6 527 3661 0 0 0 2 4 this 3 3661  5 other 1 3662  
550 0 0 6 528 3661 0 0 0 2 4 this 3 3661  5 other 1 3662  
551 0 0 6 529 3661 0 0 0 2 4 this 3 3661  6 scalar 1 3471  
552 0 0 6 530 3661 0 0 0 2 4 this 3 3661  6 scalar 1 3471  
553 0 0 4 531 3615 0 0 10 /**
 *
 */ 2 4 this 3 3661  5 other 1 3662  
554 0 0 7 532 3661 2434 0 0 2 4 this 3 3662  8 exponent 1 3471  
555 0 0 6 533 3616 0 0 0 2 4 this 3 3661  8 exponent 1 3471  
556 0 0 7 534 3661 2434 0 10 /**
 *
 */ 2 4 this 3 3662  5 other 1 3662  
557 0 0 7 535 3661 2434 0 10 /**
 *
 */ 2 4 this 3 3662  5 other 1 3662  
558 0 0 4 536 3615 0 0 10 /**
 *
 */ 2 4 this 3 3661  5 other 1 3662  
559 0 0 6 537 3620 0 0 116 /**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */ 2 4 this 3 3662  5 other 1 3662  
560 0 0 6 537 3620 0 0 92 /**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */ 3 4 this 3 3662  5 other 1 3662  9 threshold 1 3471  
561 0 0 4 538 3615 0 0 10 /**
 *
 */ 2 4 this 3 3662  3 out 1 3623  
562 0 0 6 539 3619 0 0 0 1 4 this 3 3662  
563 0 0 4 540 3615 0 0 332 /**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */ 2 4 this 3 3662  11 destination 1 3625  
564 0 0 4 541 3615 0 0 114 /**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */ 2 4 this 3 3661  6 source 1 3627  
565 0 0 4 542 3615 0 0 205 /**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */ 2 4 this 3 3662  11 destination 1 3625  
566 0 0 4 543 3615 0 0 67 /**
 * Reads the vector from the Datagram using get_stdfloat().
 */ 2 4 this 3 3661  6 source 1 3627  
567 0 0 7 544 3630 0 0 0 0 
568 0 0 7 552 3664 2472 0 0 0 
569 0 0 7 552 3664 2472 0 10 /**
 *
 */ 2 4 copy 1 3611  1 z 1 3465  
570 0 0 7 552 3664 2472 0 10 /**
 *
 */ 1 4 copy 1 3656  
571 0 0 7 552 3664 2472 0 0 1 6 param0 0 3665  
572 0 0 7 552 3664 2472 0 10 /**
 *
 */ 1 10 fill_value 1 3465  
573 0 0 7 552 3664 2472 0 10 /**
 *
 */ 3 1 x 1 3465  1 y 1 3465  1 z 1 3465  
574 0 0 6 553 3616 0 0 0 2 4 this 3 3665  9 attr_name 1 3619  
575 0 0 6 554 3471 0 0 0 3 4 this 3 3664  9 attr_name 1 3619  6 assign 1 3616  
576 0 0 6 555 3665 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
577 0 0 6 556 3665 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
578 0 0 6 557 3665 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
579 0 0 6 558 3665 0 0 35 /**
 * Returns a unit Z vector.
 */ 0 
580 0 0 7 559 3637 2142 0 100 /**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */ 1 4 this 3 3665  
581 0 0 7 560 3637 2142 0 105 /**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */ 1 4 this 3 3665  
582 0 0 7 561 3637 2142 0 99 /**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */ 1 4 this 3 3665  
583 0 0 7 565 3664 2472 0 0 1 4 this 3 3665  
584 0 0 7 566 3655 2293 0 0 2 4 this 3 3665  5 other 1 3656  
585 0 0 7 566 3664 2472 0 0 2 4 this 3 3665  5 other 1 3665  
586 0 0 7 567 3655 2293 0 0 2 4 this 3 3665  5 other 1 3656  
587 0 0 7 567 3664 2472 0 0 2 4 this 3 3665  5 other 1 3665  
588 0 0 7 568 3664 2472 0 10 /**
 *
 */ 2 4 this 3 3665  5 other 1 3656  
589 0 0 7 569 3664 2472 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3665  
590 0 0 7 570 3664 2472 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3665  4 onto 1 3656  
591 0 0 6 571 3465 0 0 147 /**
 * Returns the unsigned angle between this vector and the other one, expressed
 * in radians.  Both vectors should be initially normalized.
 */ 2 4 this 3 3665  5 other 1 3665  
592 0 0 6 572 3465 0 0 138 /**
 * Returns the angle between this vector and the other one, expressed in
 * degrees.  Both vectors should be initially normalized.
 */ 2 4 this 3 3665  5 other 1 3665  
593 0 0 6 573 3465 0 0 259 /**
 * returns the signed angle between two vectors.  The angle is positive if the
 * rotation from this vector to other is clockwise when looking in the
 * direction of the ref vector.
 *
 * Vectors (except the ref vector) should be initially normalized.
 */ 3 4 this 3 3665  5 other 1 3665  3 ref 1 3665  
594 0 0 6 574 3465 0 0 259 /**
 * Returns the signed angle between two vectors.  The angle is positive if the
 * rotation from this vector to other is clockwise when looking in the
 * direction of the ref vector.
 *
 * Vectors (except the ref vector) should be initially normalized.
 */ 3 4 this 3 3665  5 other 1 3665  3 ref 1 3665  
595 0 0 6 575 3465 0 0 50 /**
 * This method is deprecated.  Do not use.
 */ 2 4 this 3 3665  5 other 1 3665  
596 0 0 6 576 3465 0 0 50 /**
 * This method is deprecated.  Do not use.
 */ 2 4 this 3 3665  5 other 1 3665  
597 0 0 7 577 3664 2472 0 0 2 4 this 3 3665  6 scalar 1 3465  
598 0 0 7 578 3664 2472 0 0 2 4 this 3 3665  6 scalar 1 3465  
599 0 0 7 579 3664 2472 0 65 /**
 * Returns the up vector for the given coordinate system.
 */ 1 2 cs 1 3484  
600 0 0 7 580 3664 2472 0 68 /**
 * Returns the right vector for the given coordinate system.
 */ 1 2 cs 1 3484  
601 0 0 7 581 3664 2472 0 70 /**
 * Returns the forward vector for the given coordinate system.
 */ 1 2 cs 1 3484  
602 0 0 7 582 3664 2472 0 67 /**
 * Returns the down vector for the given coordinate system.
 */ 1 2 cs 1 3484  
603 0 0 7 583 3664 2472 0 67 /**
 * Returns the left vector for the given coordinate system.
 */ 1 2 cs 1 3484  
604 0 0 7 584 3664 2472 0 67 /**
 * Returns the back vector for the given coordinate system.
 */ 1 2 cs 1 3484  
605 0 0 7 585 3664 2472 0 152 /**
 * Returns a vector that is described by its right, forward, and up
 * components, in whatever way the coordinate system represents that vector.
 */ 4 5 right 1 3465  3 fwd 1 3465  2 up 1 3465  2 cs 1 3484  
606 0 0 6 586 3619 0 0 0 1 4 this 3 3665  
607 0 0 7 587 3630 0 0 0 0 
608 0 0 7 590 3667 2506 0 0 0 
609 0 0 7 590 3667 2506 0 10 /**
 *
 */ 2 4 copy 1 3632  1 z 1 3468  
610 0 0 7 590 3667 2506 0 10 /**
 *
 */ 1 4 copy 1 3659  
611 0 0 7 590 3667 2506 0 0 1 6 param0 0 3668  
612 0 0 7 590 3667 2506 0 10 /**
 *
 */ 1 10 fill_value 1 3468  
613 0 0 7 590 3667 2506 0 10 /**
 *
 */ 3 1 x 1 3468  1 y 1 3468  1 z 1 3468  
614 0 0 6 591 3616 0 0 0 2 4 this 3 3668  9 attr_name 1 3619  
615 0 0 6 592 3471 0 0 0 3 4 this 3 3667  9 attr_name 1 3619  6 assign 1 3616  
616 0 0 6 593 3668 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
617 0 0 6 594 3668 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
618 0 0 6 595 3668 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
619 0 0 6 596 3668 0 0 35 /**
 * Returns a unit Z vector.
 */ 0 
620 0 0 7 597 3640 2160 0 100 /**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */ 1 4 this 3 3668  
621 0 0 7 598 3640 2160 0 105 /**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */ 1 4 this 3 3668  
622 0 0 7 599 3640 2160 0 99 /**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */ 1 4 this 3 3668  
623 0 0 7 603 3667 2506 0 0 1 4 this 3 3668  
624 0 0 7 604 3658 2366 0 0 2 4 this 3 3668  5 other 1 3659  
625 0 0 7 604 3667 2506 0 0 2 4 this 3 3668  5 other 1 3668  
626 0 0 7 605 3658 2366 0 0 2 4 this 3 3668  5 other 1 3659  
627 0 0 7 605 3667 2506 0 0 2 4 this 3 3668  5 other 1 3668  
628 0 0 7 606 3667 2506 0 10 /**
 *
 */ 2 4 this 3 3668  5 other 1 3659  
629 0 0 7 607 3667 2506 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3668  
630 0 0 7 608 3667 2506 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3668  4 onto 1 3659  
631 0 0 6 609 3468 0 0 147 /**
 * Returns the unsigned angle between this vector and the other one, expressed
 * in radians.  Both vectors should be initially normalized.
 */ 2 4 this 3 3668  5 other 1 3668  
632 0 0 6 610 3468 0 0 138 /**
 * Returns the angle between this vector and the other one, expressed in
 * degrees.  Both vectors should be initially normalized.
 */ 2 4 this 3 3668  5 other 1 3668  
633 0 0 6 611 3468 0 0 259 /**
 * returns the signed angle between two vectors.  The angle is positive if the
 * rotation from this vector to other is clockwise when looking in the
 * direction of the ref vector.
 *
 * Vectors (except the ref vector) should be initially normalized.
 */ 3 4 this 3 3668  5 other 1 3668  3 ref 1 3668  
634 0 0 6 612 3468 0 0 259 /**
 * Returns the signed angle between two vectors.  The angle is positive if the
 * rotation from this vector to other is clockwise when looking in the
 * direction of the ref vector.
 *
 * Vectors (except the ref vector) should be initially normalized.
 */ 3 4 this 3 3668  5 other 1 3668  3 ref 1 3668  
635 0 0 6 613 3468 0 0 50 /**
 * This method is deprecated.  Do not use.
 */ 2 4 this 3 3668  5 other 1 3668  
636 0 0 6 614 3468 0 0 50 /**
 * This method is deprecated.  Do not use.
 */ 2 4 this 3 3668  5 other 1 3668  
637 0 0 7 615 3667 2506 0 0 2 4 this 3 3668  6 scalar 1 3468  
638 0 0 7 616 3667 2506 0 0 2 4 this 3 3668  6 scalar 1 3468  
639 0 0 7 617 3667 2506 0 65 /**
 * Returns the up vector for the given coordinate system.
 */ 1 2 cs 1 3484  
640 0 0 7 618 3667 2506 0 68 /**
 * Returns the right vector for the given coordinate system.
 */ 1 2 cs 1 3484  
641 0 0 7 619 3667 2506 0 70 /**
 * Returns the forward vector for the given coordinate system.
 */ 1 2 cs 1 3484  
642 0 0 7 620 3667 2506 0 67 /**
 * Returns the down vector for the given coordinate system.
 */ 1 2 cs 1 3484  
643 0 0 7 621 3667 2506 0 67 /**
 * Returns the left vector for the given coordinate system.
 */ 1 2 cs 1 3484  
644 0 0 7 622 3667 2506 0 67 /**
 * Returns the back vector for the given coordinate system.
 */ 1 2 cs 1 3484  
645 0 0 7 623 3667 2506 0 152 /**
 * Returns a vector that is described by its right, forward, and up
 * components, in whatever way the coordinate system represents that vector.
 */ 4 5 right 1 3468  3 fwd 1 3468  2 up 1 3468  2 cs 1 3484  
646 0 0 6 624 3619 0 0 0 1 4 this 3 3668  
647 0 0 7 625 3630 0 0 0 0 
648 0 0 7 628 3670 2532 0 0 0 
649 0 0 7 628 3670 2532 0 10 /**
 *
 */ 2 4 copy 1 3635  1 z 1 3471  
650 0 0 7 628 3670 2532 0 10 /**
 *
 */ 1 4 copy 1 3662  
651 0 0 7 628 3670 2532 0 0 1 6 param0 0 3671  
652 0 0 7 628 3670 2532 0 10 /**
 *
 */ 1 10 fill_value 1 3471  
653 0 0 7 628 3670 2532 0 10 /**
 *
 */ 3 1 x 1 3471  1 y 1 3471  1 z 1 3471  
654 0 0 6 629 3616 0 0 0 2 4 this 3 3671  9 attr_name 1 3619  
655 0 0 6 630 3471 0 0 0 3 4 this 3 3670  9 attr_name 1 3619  6 assign 1 3616  
656 0 0 6 631 3671 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
657 0 0 6 632 3671 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
658 0 0 6 633 3671 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
659 0 0 6 634 3671 0 0 35 /**
 * Returns a unit Z vector.
 */ 0 
660 0 0 7 635 3643 2174 0 100 /**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */ 1 4 this 3 3671  
661 0 0 7 636 3643 2174 0 105 /**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */ 1 4 this 3 3671  
662 0 0 7 637 3643 2174 0 99 /**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */ 1 4 this 3 3671  
663 0 0 7 641 3670 2532 0 0 1 4 this 3 3671  
664 0 0 7 642 3661 2434 0 0 2 4 this 3 3671  5 other 1 3662  
665 0 0 7 642 3670 2532 0 0 2 4 this 3 3671  5 other 1 3671  
666 0 0 7 643 3661 2434 0 0 2 4 this 3 3671  5 other 1 3662  
667 0 0 7 643 3670 2532 0 0 2 4 this 3 3671  5 other 1 3671  
668 0 0 7 644 3670 2532 0 10 /**
 *
 */ 2 4 this 3 3671  5 other 1 3662  
669 0 0 7 645 3670 2532 0 0 2 4 this 3 3671  6 scalar 1 3471  
670 0 0 7 646 3670 2532 0 0 2 4 this 3 3671  6 scalar 1 3471  
671 0 0 7 647 3670 2532 0 65 /**
 * Returns the up vector for the given coordinate system.
 */ 1 2 cs 1 3484  
672 0 0 7 648 3670 2532 0 68 /**
 * Returns the right vector for the given coordinate system.
 */ 1 2 cs 1 3484  
673 0 0 7 649 3670 2532 0 70 /**
 * Returns the forward vector for the given coordinate system.
 */ 1 2 cs 1 3484  
674 0 0 7 650 3670 2532 0 67 /**
 * Returns the down vector for the given coordinate system.
 */ 1 2 cs 1 3484  
675 0 0 7 651 3670 2532 0 67 /**
 * Returns the left vector for the given coordinate system.
 */ 1 2 cs 1 3484  
676 0 0 7 652 3670 2532 0 67 /**
 * Returns the back vector for the given coordinate system.
 */ 1 2 cs 1 3484  
677 0 0 7 653 3670 2532 0 152 /**
 * Returns a vector that is described by its right, forward, and up
 * components, in whatever way the coordinate system represents that vector.
 */ 4 5 right 1 3471  3 fwd 1 3471  2 up 1 3471  2 cs 1 3484  
678 0 0 6 654 3619 0 0 0 1 4 this 3 3671  
679 0 0 7 655 3630 0 0 0 0 
680 0 0 7 658 3673 2555 0 0 0 
681 0 0 7 658 3673 2555 0 0 1 6 param0 0 3674  
682 0 0 7 658 3673 2555 0 10 /**
 *
 */ 2 4 copy 1 3611  1 z 1 3465  
683 0 0 7 658 3673 2555 0 10 /**
 *
 */ 1 4 copy 1 3656  
684 0 0 7 658 3673 2555 0 10 /**
 *
 */ 1 10 fill_value 1 3465  
685 0 0 7 658 3673 2555 0 10 /**
 *
 */ 3 1 x 1 3465  1 y 1 3465  1 z 1 3465  
686 0 0 6 659 3616 0 0 0 2 4 this 3 3674  9 attr_name 1 3619  
687 0 0 6 660 3471 0 0 0 3 4 this 3 3673  9 attr_name 1 3619  6 assign 1 3616  
688 0 0 6 661 3674 0 0 39 /**
 * Returns a zero-length point.
 */ 0 
689 0 0 6 662 3674 0 0 34 /**
 * Returns a unit X point.
 */ 0 
690 0 0 6 663 3674 0 0 34 /**
 * Returns a unit Y point.
 */ 0 
691 0 0 6 664 3674 0 0 34 /**
 * Returns a unit Z point.
 */ 0 
692 0 0 7 665 3646 2190 0 100 /**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */ 1 4 this 3 3674  
693 0 0 7 666 3646 2190 0 105 /**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */ 1 4 this 3 3674  
694 0 0 7 667 3646 2190 0 99 /**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */ 1 4 this 3 3674  
695 0 0 7 671 3673 2555 0 0 1 4 this 3 3674  
696 0 0 7 672 3655 2293 0 0 2 4 this 3 3674  5 other 1 3656  
697 0 0 7 672 3673 2555 0 0 2 4 this 3 3674  5 other 1 3665  
698 0 0 7 673 3664 2472 0 0 2 4 this 3 3674  5 other 1 3674  
699 0 0 7 673 3655 2293 0 0 2 4 this 3 3674  5 other 1 3656  
700 0 0 7 673 3673 2555 0 0 2 4 this 3 3674  5 other 1 3665  
701 0 0 7 674 3673 2555 0 10 /**
 *
 */ 2 4 this 3 3674  5 other 1 3656  
702 0 0 7 675 3673 2555 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3674  
703 0 0 7 676 3673 2555 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3674  4 onto 1 3656  
704 0 0 7 677 3673 2555 0 0 2 4 this 3 3674  6 scalar 1 3465  
705 0 0 7 678 3673 2555 0 0 2 4 this 3 3674  6 scalar 1 3465  
706 0 0 6 679 3674 0 0 186 /**
 * Returns the origin of the indicated coordinate system.  This is always 0,
 * 0, 0 with all of our existing coordinate systems; it's hard to imagine it
 * ever being different.
 */ 1 2 cs 1 3484  
707 0 0 7 680 3673 2555 0 146 /**
 * Returns a point described by right, forward, up displacements from the
 * origin, wherever that maps to in the given coordinate system.
 */ 4 5 right 1 3465  3 fwd 1 3465  2 up 1 3465  2 cs 1 3484  
708 0 0 6 681 3619 0 0 0 1 4 this 3 3674  
709 0 0 7 682 3630 0 0 0 0 
710 0 0 7 685 3676 2578 0 0 0 
711 0 0 7 685 3676 2578 0 0 1 6 param0 0 3677  
712 0 0 7 685 3676 2578 0 10 /**
 *
 */ 2 4 copy 1 3632  1 z 1 3468  
713 0 0 7 685 3676 2578 0 10 /**
 *
 */ 1 4 copy 1 3659  
714 0 0 7 685 3676 2578 0 10 /**
 *
 */ 1 10 fill_value 1 3468  
715 0 0 7 685 3676 2578 0 10 /**
 *
 */ 3 1 x 1 3468  1 y 1 3468  1 z 1 3468  
716 0 0 6 686 3616 0 0 0 2 4 this 3 3677  9 attr_name 1 3619  
717 0 0 6 687 3471 0 0 0 3 4 this 3 3676  9 attr_name 1 3619  6 assign 1 3616  
718 0 0 6 688 3677 0 0 39 /**
 * Returns a zero-length point.
 */ 0 
719 0 0 6 689 3677 0 0 34 /**
 * Returns a unit X point.
 */ 0 
720 0 0 6 690 3677 0 0 34 /**
 * Returns a unit Y point.
 */ 0 
721 0 0 6 691 3677 0 0 34 /**
 * Returns a unit Z point.
 */ 0 
722 0 0 7 692 3649 2206 0 100 /**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */ 1 4 this 3 3677  
723 0 0 7 693 3649 2206 0 105 /**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */ 1 4 this 3 3677  
724 0 0 7 694 3649 2206 0 99 /**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */ 1 4 this 3 3677  
725 0 0 7 698 3676 2578 0 0 1 4 this 3 3677  
726 0 0 7 699 3658 2366 0 0 2 4 this 3 3677  5 other 1 3659  
727 0 0 7 699 3676 2578 0 0 2 4 this 3 3677  5 other 1 3668  
728 0 0 7 700 3667 2506 0 0 2 4 this 3 3677  5 other 1 3677  
729 0 0 7 700 3658 2366 0 0 2 4 this 3 3677  5 other 1 3659  
730 0 0 7 700 3676 2578 0 0 2 4 this 3 3677  5 other 1 3668  
731 0 0 7 701 3676 2578 0 10 /**
 *
 */ 2 4 this 3 3677  5 other 1 3659  
732 0 0 7 702 3676 2578 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3677  
733 0 0 7 703 3676 2578 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3677  4 onto 1 3659  
734 0 0 7 704 3676 2578 0 0 2 4 this 3 3677  6 scalar 1 3468  
735 0 0 7 705 3676 2578 0 0 2 4 this 3 3677  6 scalar 1 3468  
736 0 0 6 706 3677 0 0 186 /**
 * Returns the origin of the indicated coordinate system.  This is always 0,
 * 0, 0 with all of our existing coordinate systems; it's hard to imagine it
 * ever being different.
 */ 1 2 cs 1 3484  
737 0 0 7 707 3676 2578 0 146 /**
 * Returns a point described by right, forward, up displacements from the
 * origin, wherever that maps to in the given coordinate system.
 */ 4 5 right 1 3468  3 fwd 1 3468  2 up 1 3468  2 cs 1 3484  
738 0 0 6 708 3619 0 0 0 1 4 this 3 3677  
739 0 0 7 709 3630 0 0 0 0 
740 0 0 7 712 3679 2599 0 0 0 
741 0 0 7 712 3679 2599 0 0 1 6 param0 0 3680  
742 0 0 7 712 3679 2599 0 10 /**
 *
 */ 2 4 copy 1 3635  1 z 1 3471  
743 0 0 7 712 3679 2599 0 10 /**
 *
 */ 1 4 copy 1 3662  
744 0 0 7 712 3679 2599 0 10 /**
 *
 */ 1 10 fill_value 1 3471  
745 0 0 7 712 3679 2599 0 10 /**
 *
 */ 3 1 x 1 3471  1 y 1 3471  1 z 1 3471  
746 0 0 6 713 3616 0 0 0 2 4 this 3 3680  9 attr_name 1 3619  
747 0 0 6 714 3471 0 0 0 3 4 this 3 3679  9 attr_name 1 3619  6 assign 1 3616  
748 0 0 6 715 3680 0 0 39 /**
 * Returns a zero-length point.
 */ 0 
749 0 0 6 716 3680 0 0 34 /**
 * Returns a unit X point.
 */ 0 
750 0 0 6 717 3680 0 0 34 /**
 * Returns a unit Y point.
 */ 0 
751 0 0 6 718 3680 0 0 34 /**
 * Returns a unit Z point.
 */ 0 
752 0 0 7 719 3652 2220 0 100 /**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */ 1 4 this 3 3680  
753 0 0 7 720 3652 2220 0 105 /**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */ 1 4 this 3 3680  
754 0 0 7 721 3652 2220 0 99 /**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */ 1 4 this 3 3680  
755 0 0 7 725 3679 2599 0 0 1 4 this 3 3680  
756 0 0 7 726 3661 2434 0 0 2 4 this 3 3680  5 other 1 3662  
757 0 0 7 726 3679 2599 0 0 2 4 this 3 3680  5 other 1 3671  
758 0 0 7 727 3670 2532 0 0 2 4 this 3 3680  5 other 1 3680  
759 0 0 7 727 3661 2434 0 0 2 4 this 3 3680  5 other 1 3662  
760 0 0 7 727 3679 2599 0 0 2 4 this 3 3680  5 other 1 3671  
761 0 0 7 728 3679 2599 0 10 /**
 *
 */ 2 4 this 3 3680  5 other 1 3662  
762 0 0 7 729 3679 2599 0 0 2 4 this 3 3680  6 scalar 1 3471  
763 0 0 7 730 3679 2599 0 0 2 4 this 3 3680  6 scalar 1 3471  
764 0 0 6 731 3680 0 0 186 /**
 * Returns the origin of the indicated coordinate system.  This is always 0,
 * 0, 0 with all of our existing coordinate systems; it's hard to imagine it
 * ever being different.
 */ 1 2 cs 1 3484  
765 0 0 7 732 3679 2599 0 146 /**
 * Returns a point described by right, forward, up displacements from the
 * origin, wherever that maps to in the given coordinate system.
 */ 4 5 right 1 3471  3 fwd 1 3471  2 up 1 3471  2 cs 1 3484  
766 0 0 6 733 3619 0 0 0 1 4 this 3 3680  
767 0 0 7 734 3630 0 0 0 0 
768 0 0 7 738 3682 2673 0 0 0 
769 0 0 7 738 3682 2673 0 84 /**
 * Constructs an LVecBase4 from an LPoint3.  The w coordinate is set to 1.0.
 */ 1 5 point 1 3674  
770 0 0 7 738 3682 2673 0 10 /**
 *
 */ 2 4 copy 1 3656  1 w 1 3465  
771 0 0 7 738 3682 2673 0 0 1 6 param0 0 3683  
772 0 0 7 738 3682 2673 0 85 /**
 * Constructs an LVecBase4 from an LVector3.  The w coordinate is set to 0.0.
 */ 1 6 vector 1 3665  
773 0 0 7 738 3682 2673 0 10 /**
 *
 */ 1 4 copy 1 3685  
774 0 0 7 738 3682 2673 0 10 /**
 *
 */ 1 10 fill_value 1 3465  
775 0 0 7 738 3682 2673 0 10 /**
 *
 */ 4 1 x 1 3465  1 y 1 3465  1 z 1 3465  1 w 1 3465  
776 0 0 4 739 3615 0 0 0 2 4 this 3 3682  4 size 1 3613  
777 0 0 6 742 3682 0 0 0 2 4 this 3 3682  4 copy 1 3683  
778 0 0 6 742 3682 0 0 0 2 4 this 3 3682  10 fill_value 1 3465  
779 0 0 6 743 3683 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
780 0 0 6 744 3683 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
781 0 0 6 745 3683 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
782 0 0 6 746 3683 0 0 35 /**
 * Returns a unit Z vector.
 */ 0 
783 0 0 6 747 3683 0 0 35 /**
 * Returns a unit W vector.
 */ 0 
784 0 0 6 748 3616 0 0 0 1 4 this 3 3683  
785 0 0 6 749 3616 0 0 0 2 4 this 3 3683  9 attr_name 1 3619  
786 0 0 6 750 3471 0 0 0 3 4 this 3 3682  9 attr_name 1 3619  6 assign 1 3616  
787 0 0 4 751 3615 0 0 10 /**
 *
 */ 3 4 this 3 3682  1 i 1 3471  10 assign_val 1 3465  
788 0 0 6 751 3465 0 0 0 2 4 this 3 3683  1 i 1 3471  
789 0 0 6 752 3471 0 0 0 0 
790 0 0 6 753 3620 0 0 91 /**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */ 1 4 this 3 3683  
791 0 0 6 754 3465 0 0 10 /**
 *
 */ 2 4 this 3 3683  1 i 1 3471  
792 0 0 4 755 3615 0 0 10 /**
 *
 */ 3 4 this 3 3682  1 i 1 3471  5 value 1 3465  
793 0 0 6 756 3465 0 0 10 /**
 *
 */ 1 4 this 3 3683  
794 0 0 6 757 3465 0 0 10 /**
 *
 */ 1 4 this 3 3683  
795 0 0 6 758 3465 0 0 10 /**
 *
 */ 1 4 this 3 3683  
796 0 0 6 759 3465 0 0 10 /**
 *
 */ 1 4 this 3 3683  
797 0 0 7 760 3655 2293 0 58 /**
 * Returns the x, y and z component of this vector
 */ 1 4 this 3 3683  
798 0 0 7 761 3610 2002 0 55 /**
 * Returns the x and y component of this vector
 */ 1 4 this 3 3683  
799 0 0 4 762 3615 0 0 10 /**
 *
 */ 2 4 this 3 3682  5 value 1 3465  
800 0 0 4 763 3615 0 0 10 /**
 *
 */ 2 4 this 3 3682  5 value 1 3465  
801 0 0 4 764 3615 0 0 10 /**
 *
 */ 2 4 this 3 3682  5 value 1 3465  
802 0 0 4 765 3615 0 0 10 /**
 *
 */ 2 4 this 3 3682  5 value 1 3465  
803 0 0 4 771 3615 0 0 152 // These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages: 3 4 this 3 3682  1 i 1 3471  5 value 1 3465  
804 0 0 4 772 3615 0 0 10 /**
 *
 */ 2 4 this 3 3682  5 value 1 3465  
805 0 0 4 773 3615 0 0 10 /**
 *
 */ 2 4 this 3 3682  5 value 1 3465  
806 0 0 4 774 3615 0 0 10 /**
 *
 */ 2 4 this 3 3682  5 value 1 3465  
807 0 0 4 775 3615 0 0 10 /**
 *
 */ 2 4 this 3 3682  5 value 1 3465  
808 0 0 4 776 3615 0 0 161 /**
 * Returns the address of the first of the four data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */ 1 4 this 3 3683  
809 0 0 6 777 3471 0 0 0 0 
810 0 0 4 779 3615 0 0 129 /**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */ 2 4 this 3 3682  10 fill_value 1 3465  
811 0 0 4 780 3615 0 0 10 /**
 *
 */ 5 4 this 3 3682  1 x 1 3465  1 y 1 3465  1 z 1 3465  1 w 1 3465  
812 0 0 6 781 3465 0 0 10 /**
 *
 */ 2 4 this 3 3683  5 other 1 3683  
813 0 0 6 782 3465 0 0 69 /**
 * Returns the square of the vector's length, cheap and easy.
 */ 1 4 this 3 3683  
814 0 0 6 783 3465 0 0 72 /**
 * Returns the length of the vector, by the Pythagorean theorem.
 */ 1 4 this 3 3683  
815 0 0 6 784 3620 0 0 127 /**
 * Normalizes the vector in place.  Returns true if the vector was normalized,
 * false if it was a zero-length vector.
 */ 1 4 this 3 3682  
816 0 0 7 785 3682 2673 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3683  
817 0 0 7 786 3682 2673 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3683  4 onto 1 3683  
818 0 0 6 787 3620 0 0 0 2 4 this 3 3683  5 other 1 3683  
819 0 0 6 788 3620 0 0 0 2 4 this 3 3683  5 other 1 3683  
820 0 0 6 789 3620 0 0 0 2 4 this 3 3683  5 other 1 3683  
821 0 0 6 790 3471 0 0 97 /**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */ 2 4 this 3 3683  5 other 1 3683  
822 0 0 6 790 3471 0 0 233 /**
 * Sorts vectors lexicographically, componentwise.  Returns a number less than
 * 0 if this vector sorts before the other one, greater than zero if it sorts
 * after, 0 if they are equivalent (within the indicated tolerance).
 */ 3 4 this 3 3683  5 other 1 3683  9 threshold 1 3465  
823 0 0 6 791 3613 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 1 4 this 3 3683  
824 0 0 6 791 3613 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 2 4 this 3 3683  9 threshold 1 3465  
825 0 0 6 792 3613 0 0 49 /**
 * Adds the vector into the running hash.
 */ 2 4 this 3 3683  4 hash 1 3613  
826 0 0 6 792 3613 0 0 49 /**
 * Adds the vector into the running hash.
 */ 3 4 this 3 3683  4 hash 1 3613  9 threshold 1 3465  
827 0 0 4 793 3615 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 2 4 this 3 3683  7 hashgen 1 3621  
828 0 0 4 793 3615 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 3 4 this 3 3683  7 hashgen 1 3621  9 threshold 1 3465  
829 0 0 7 794 3682 2673 0 0 1 4 this 3 3683  
830 0 0 7 795 3682 2673 0 0 2 4 this 3 3683  5 other 1 3683  
831 0 0 7 796 3682 2673 0 0 2 4 this 3 3683  5 other 1 3683  
832 0 0 7 797 3682 2673 0 0 2 4 this 3 3683  6 scalar 1 3465  
833 0 0 7 798 3682 2673 0 0 2 4 this 3 3683  6 scalar 1 3465  
834 0 0 6 799 3682 0 0 0 2 4 this 3 3682  5 other 1 3683  
835 0 0 6 800 3682 0 0 0 2 4 this 3 3682  5 other 1 3683  
836 0 0 6 801 3682 0 0 0 2 4 this 3 3682  6 scalar 1 3465  
837 0 0 6 802 3682 0 0 0 2 4 this 3 3682  6 scalar 1 3465  
838 0 0 4 803 3615 0 0 10 /**
 *
 */ 2 4 this 3 3682  5 other 1 3683  
839 0 0 7 804 3682 2673 0 0 2 4 this 3 3683  8 exponent 1 3465  
840 0 0 6 805 3616 0 0 0 2 4 this 3 3682  8 exponent 1 3465  
841 0 0 7 806 3682 2673 0 10 /**
 *
 */ 2 4 this 3 3683  5 other 1 3683  
842 0 0 7 807 3682 2673 0 10 /**
 *
 */ 2 4 this 3 3683  5 other 1 3683  
843 0 0 6 808 3620 0 0 116 /**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */ 2 4 this 3 3683  5 other 1 3683  
844 0 0 6 808 3620 0 0 92 /**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */ 3 4 this 3 3683  5 other 1 3683  9 threshold 1 3465  
845 0 0 4 809 3615 0 0 10 /**
 *
 */ 2 4 this 3 3683  3 out 1 3623  
846 0 0 6 810 3619 0 0 0 1 4 this 3 3683  
847 0 0 4 811 3615 0 0 332 /**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */ 2 4 this 3 3683  11 destination 1 3625  
848 0 0 4 812 3615 0 0 114 /**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */ 2 4 this 3 3682  6 source 1 3627  
849 0 0 4 813 3615 0 0 205 /**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */ 2 4 this 3 3683  11 destination 1 3625  
850 0 0 4 814 3615 0 0 67 /**
 * Reads the vector from the Datagram using get_stdfloat().
 */ 2 4 this 3 3682  6 source 1 3627  
851 0 0 7 815 3630 0 0 0 0 
852 0 0 7 819 3687 2681 0 0 0 
853 0 0 7 819 3687 2681 0 10 /**
 *
 */ 1 4 copy 1 3683  
854 0 0 7 819 3687 2681 0 0 1 6 param0 0 3685  
855 0 0 7 819 3687 2681 0 10 /**
 *
 */ 4 1 x 1 3465  1 y 1 3465  1 z 1 3465  1 w 1 3465  
856 0 0 4 820 3615 0 0 10 /**
 *
 */ 5 4 this 3 3687  1 x 1 3465  1 y 1 3465  1 z 1 3465  1 w 1 3465  
857 0 0 4 821 3615 0 0 10 /**
 *
 */ 3 4 this 3 3687  1 i 1 3471  10 assign_val 1 3465  
858 0 0 6 821 3465 0 0 0 2 4 this 3 3685  1 i 1 3471  
859 0 0 6 822 3471 0 0 0 0 
860 0 0 4 823 3615 0 0 162 /**
 * Returns the address of the first of the three data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */ 1 4 this 3 3685  
861 0 0 6 824 3471 0 0 0 0 
862 0 0 7 825 3630 0 0 0 0 
863 0 0 7 829 3688 2755 0 0 0 
864 0 0 7 829 3688 2755 0 84 /**
 * Constructs an LVecBase4 from an LPoint3.  The w coordinate is set to 1.0.
 */ 1 5 point 1 3677  
865 0 0 7 829 3688 2755 0 10 /**
 *
 */ 2 4 copy 1 3659  1 w 1 3468  
866 0 0 7 829 3688 2755 0 0 1 6 param0 0 3689  
867 0 0 7 829 3688 2755 0 85 /**
 * Constructs an LVecBase4 from an LVector3.  The w coordinate is set to 0.0.
 */ 1 6 vector 1 3668  
868 0 0 7 829 3688 2755 0 10 /**
 *
 */ 1 4 copy 1 3691  
869 0 0 7 829 3688 2755 0 10 /**
 *
 */ 1 10 fill_value 1 3468  
870 0 0 7 829 3688 2755 0 10 /**
 *
 */ 4 1 x 1 3468  1 y 1 3468  1 z 1 3468  1 w 1 3468  
871 0 0 4 830 3615 0 0 0 2 4 this 3 3688  4 size 1 3613  
872 0 0 6 833 3688 0 0 0 2 4 this 3 3688  4 copy 1 3689  
873 0 0 6 833 3688 0 0 0 2 4 this 3 3688  10 fill_value 1 3468  
874 0 0 6 834 3689 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
875 0 0 6 835 3689 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
876 0 0 6 836 3689 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
877 0 0 6 837 3689 0 0 35 /**
 * Returns a unit Z vector.
 */ 0 
878 0 0 6 838 3689 0 0 35 /**
 * Returns a unit W vector.
 */ 0 
879 0 0 6 839 3616 0 0 0 1 4 this 3 3689  
880 0 0 6 840 3616 0 0 0 2 4 this 3 3689  9 attr_name 1 3619  
881 0 0 6 841 3471 0 0 0 3 4 this 3 3688  9 attr_name 1 3619  6 assign 1 3616  
882 0 0 4 842 3615 0 0 10 /**
 *
 */ 3 4 this 3 3688  1 i 1 3471  10 assign_val 1 3468  
883 0 0 6 842 3468 0 0 0 2 4 this 3 3689  1 i 1 3471  
884 0 0 6 843 3471 0 0 0 0 
885 0 0 6 844 3620 0 0 91 /**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */ 1 4 this 3 3689  
886 0 0 6 845 3468 0 0 10 /**
 *
 */ 2 4 this 3 3689  1 i 1 3471  
887 0 0 4 846 3615 0 0 10 /**
 *
 */ 3 4 this 3 3688  1 i 1 3471  5 value 1 3468  
888 0 0 6 847 3468 0 0 10 /**
 *
 */ 1 4 this 3 3689  
889 0 0 6 848 3468 0 0 10 /**
 *
 */ 1 4 this 3 3689  
890 0 0 6 849 3468 0 0 10 /**
 *
 */ 1 4 this 3 3689  
891 0 0 6 850 3468 0 0 10 /**
 *
 */ 1 4 this 3 3689  
892 0 0 7 851 3658 2366 0 58 /**
 * Returns the x, y and z component of this vector
 */ 1 4 this 3 3689  
893 0 0 7 852 3631 2065 0 55 /**
 * Returns the x and y component of this vector
 */ 1 4 this 3 3689  
894 0 0 4 853 3615 0 0 10 /**
 *
 */ 2 4 this 3 3688  5 value 1 3468  
895 0 0 4 854 3615 0 0 10 /**
 *
 */ 2 4 this 3 3688  5 value 1 3468  
896 0 0 4 855 3615 0 0 10 /**
 *
 */ 2 4 this 3 3688  5 value 1 3468  
897 0 0 4 856 3615 0 0 10 /**
 *
 */ 2 4 this 3 3688  5 value 1 3468  
898 0 0 4 862 3615 0 0 152 // These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages: 3 4 this 3 3688  1 i 1 3471  5 value 1 3468  
899 0 0 4 863 3615 0 0 10 /**
 *
 */ 2 4 this 3 3688  5 value 1 3468  
900 0 0 4 864 3615 0 0 10 /**
 *
 */ 2 4 this 3 3688  5 value 1 3468  
901 0 0 4 865 3615 0 0 10 /**
 *
 */ 2 4 this 3 3688  5 value 1 3468  
902 0 0 4 866 3615 0 0 10 /**
 *
 */ 2 4 this 3 3688  5 value 1 3468  
903 0 0 4 867 3615 0 0 161 /**
 * Returns the address of the first of the four data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */ 1 4 this 3 3689  
904 0 0 6 868 3471 0 0 0 0 
905 0 0 4 870 3615 0 0 129 /**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */ 2 4 this 3 3688  10 fill_value 1 3468  
906 0 0 4 871 3615 0 0 10 /**
 *
 */ 5 4 this 3 3688  1 x 1 3468  1 y 1 3468  1 z 1 3468  1 w 1 3468  
907 0 0 6 872 3468 0 0 10 /**
 *
 */ 2 4 this 3 3689  5 other 1 3689  
908 0 0 6 873 3468 0 0 69 /**
 * Returns the square of the vector's length, cheap and easy.
 */ 1 4 this 3 3689  
909 0 0 6 874 3468 0 0 72 /**
 * Returns the length of the vector, by the Pythagorean theorem.
 */ 1 4 this 3 3689  
910 0 0 6 875 3620 0 0 127 /**
 * Normalizes the vector in place.  Returns true if the vector was normalized,
 * false if it was a zero-length vector.
 */ 1 4 this 3 3688  
911 0 0 7 876 3688 2755 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3689  
912 0 0 7 877 3688 2755 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3689  4 onto 1 3689  
913 0 0 6 878 3620 0 0 0 2 4 this 3 3689  5 other 1 3689  
914 0 0 6 879 3620 0 0 0 2 4 this 3 3689  5 other 1 3689  
915 0 0 6 880 3620 0 0 0 2 4 this 3 3689  5 other 1 3689  
916 0 0 6 881 3471 0 0 97 /**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */ 2 4 this 3 3689  5 other 1 3689  
917 0 0 6 881 3471 0 0 233 /**
 * Sorts vectors lexicographically, componentwise.  Returns a number less than
 * 0 if this vector sorts before the other one, greater than zero if it sorts
 * after, 0 if they are equivalent (within the indicated tolerance).
 */ 3 4 this 3 3689  5 other 1 3689  9 threshold 1 3468  
918 0 0 6 882 3613 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 1 4 this 3 3689  
919 0 0 6 882 3613 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 2 4 this 3 3689  9 threshold 1 3468  
920 0 0 6 883 3613 0 0 49 /**
 * Adds the vector into the running hash.
 */ 2 4 this 3 3689  4 hash 1 3613  
921 0 0 6 883 3613 0 0 49 /**
 * Adds the vector into the running hash.
 */ 3 4 this 3 3689  4 hash 1 3613  9 threshold 1 3468  
922 0 0 4 884 3615 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 2 4 this 3 3689  7 hashgen 1 3621  
923 0 0 4 884 3615 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 3 4 this 3 3689  7 hashgen 1 3621  9 threshold 1 3468  
924 0 0 7 885 3688 2755 0 0 1 4 this 3 3689  
925 0 0 7 886 3688 2755 0 0 2 4 this 3 3689  5 other 1 3689  
926 0 0 7 887 3688 2755 0 0 2 4 this 3 3689  5 other 1 3689  
927 0 0 7 888 3688 2755 0 0 2 4 this 3 3689  6 scalar 1 3468  
928 0 0 7 889 3688 2755 0 0 2 4 this 3 3689  6 scalar 1 3468  
929 0 0 6 890 3688 0 0 0 2 4 this 3 3688  5 other 1 3689  
930 0 0 6 891 3688 0 0 0 2 4 this 3 3688  5 other 1 3689  
931 0 0 6 892 3688 0 0 0 2 4 this 3 3688  6 scalar 1 3468  
932 0 0 6 893 3688 0 0 0 2 4 this 3 3688  6 scalar 1 3468  
933 0 0 4 894 3615 0 0 10 /**
 *
 */ 2 4 this 3 3688  5 other 1 3689  
934 0 0 7 895 3688 2755 0 0 2 4 this 3 3689  8 exponent 1 3468  
935 0 0 6 896 3616 0 0 0 2 4 this 3 3688  8 exponent 1 3468  
936 0 0 7 897 3688 2755 0 10 /**
 *
 */ 2 4 this 3 3689  5 other 1 3689  
937 0 0 7 898 3688 2755 0 10 /**
 *
 */ 2 4 this 3 3689  5 other 1 3689  
938 0 0 6 899 3620 0 0 116 /**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */ 2 4 this 3 3689  5 other 1 3689  
939 0 0 6 899 3620 0 0 92 /**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */ 3 4 this 3 3689  5 other 1 3689  9 threshold 1 3468  
940 0 0 4 900 3615 0 0 10 /**
 *
 */ 2 4 this 3 3689  3 out 1 3623  
941 0 0 6 901 3619 0 0 0 1 4 this 3 3689  
942 0 0 4 902 3615 0 0 332 /**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */ 2 4 this 3 3689  11 destination 1 3625  
943 0 0 4 903 3615 0 0 114 /**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */ 2 4 this 3 3688  6 source 1 3627  
944 0 0 4 904 3615 0 0 205 /**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */ 2 4 this 3 3689  11 destination 1 3625  
945 0 0 4 905 3615 0 0 67 /**
 * Reads the vector from the Datagram using get_stdfloat().
 */ 2 4 this 3 3688  6 source 1 3627  
946 0 0 7 906 3630 0 0 0 0 
947 0 0 7 910 3693 2763 0 0 0 
948 0 0 7 910 3693 2763 0 10 /**
 *
 */ 1 4 copy 1 3689  
949 0 0 7 910 3693 2763 0 0 1 6 param0 0 3691  
950 0 0 7 910 3693 2763 0 10 /**
 *
 */ 4 1 x 1 3468  1 y 1 3468  1 z 1 3468  1 w 1 3468  
951 0 0 4 911 3615 0 0 10 /**
 *
 */ 5 4 this 3 3693  1 x 1 3468  1 y 1 3468  1 z 1 3468  1 w 1 3468  
952 0 0 4 912 3615 0 0 10 /**
 *
 */ 3 4 this 3 3693  1 i 1 3471  10 assign_val 1 3468  
953 0 0 6 912 3468 0 0 0 2 4 this 3 3691  1 i 1 3471  
954 0 0 6 913 3471 0 0 0 0 
955 0 0 4 914 3615 0 0 162 /**
 * Returns the address of the first of the three data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */ 1 4 this 3 3691  
956 0 0 6 915 3471 0 0 0 0 
957 0 0 7 916 3630 0 0 0 0 
958 0 0 7 920 3694 2833 0 0 0 
959 0 0 7 920 3694 2833 0 84 /**
 * Constructs an LVecBase4 from an LPoint3.  The w coordinate is set to 1.0.
 */ 1 5 point 1 3680  
960 0 0 7 920 3694 2833 0 10 /**
 *
 */ 2 4 copy 1 3662  1 w 1 3471  
961 0 0 7 920 3694 2833 0 0 1 6 param0 0 3695  
962 0 0 7 920 3694 2833 0 85 /**
 * Constructs an LVecBase4 from an LVector3.  The w coordinate is set to 0.0.
 */ 1 6 vector 1 3671  
963 0 0 7 920 3694 2833 0 10 /**
 *
 */ 1 4 copy 1 3697  
964 0 0 7 920 3694 2833 0 10 /**
 *
 */ 1 10 fill_value 1 3471  
965 0 0 7 920 3694 2833 0 10 /**
 *
 */ 4 1 x 1 3471  1 y 1 3471  1 z 1 3471  1 w 1 3471  
966 0 0 4 921 3615 0 0 0 2 4 this 3 3694  4 size 1 3613  
967 0 0 6 924 3694 0 0 0 2 4 this 3 3694  4 copy 1 3695  
968 0 0 6 924 3694 0 0 0 2 4 this 3 3694  10 fill_value 1 3471  
969 0 0 6 925 3695 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
970 0 0 6 926 3695 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
971 0 0 6 927 3695 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
972 0 0 6 928 3695 0 0 35 /**
 * Returns a unit Z vector.
 */ 0 
973 0 0 6 929 3695 0 0 35 /**
 * Returns a unit W vector.
 */ 0 
974 0 0 6 930 3616 0 0 0 1 4 this 3 3695  
975 0 0 6 931 3616 0 0 0 2 4 this 3 3695  9 attr_name 1 3619  
976 0 0 6 932 3471 0 0 0 3 4 this 3 3694  9 attr_name 1 3619  6 assign 1 3616  
977 0 0 4 933 3615 0 0 10 /**
 *
 */ 3 4 this 3 3694  1 i 1 3471  10 assign_val 1 3471  
978 0 0 6 933 3471 0 0 0 2 4 this 3 3695  1 i 1 3471  
979 0 0 6 934 3471 0 0 0 0 
980 0 0 6 935 3620 0 0 91 /**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */ 1 4 this 3 3695  
981 0 0 6 936 3471 0 0 10 /**
 *
 */ 2 4 this 3 3695  1 i 1 3471  
982 0 0 4 937 3615 0 0 10 /**
 *
 */ 3 4 this 3 3694  1 i 1 3471  5 value 1 3471  
983 0 0 6 938 3471 0 0 10 /**
 *
 */ 1 4 this 3 3695  
984 0 0 6 939 3471 0 0 10 /**
 *
 */ 1 4 this 3 3695  
985 0 0 6 940 3471 0 0 10 /**
 *
 */ 1 4 this 3 3695  
986 0 0 6 941 3471 0 0 10 /**
 *
 */ 1 4 this 3 3695  
987 0 0 7 942 3661 2434 0 58 /**
 * Returns the x, y and z component of this vector
 */ 1 4 this 3 3695  
988 0 0 7 943 3634 2124 0 55 /**
 * Returns the x and y component of this vector
 */ 1 4 this 3 3695  
989 0 0 4 944 3615 0 0 10 /**
 *
 */ 2 4 this 3 3694  5 value 1 3471  
990 0 0 4 945 3615 0 0 10 /**
 *
 */ 2 4 this 3 3694  5 value 1 3471  
991 0 0 4 946 3615 0 0 10 /**
 *
 */ 2 4 this 3 3694  5 value 1 3471  
992 0 0 4 947 3615 0 0 10 /**
 *
 */ 2 4 this 3 3694  5 value 1 3471  
993 0 0 4 953 3615 0 0 152 // These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages: 3 4 this 3 3694  1 i 1 3471  5 value 1 3471  
994 0 0 4 954 3615 0 0 10 /**
 *
 */ 2 4 this 3 3694  5 value 1 3471  
995 0 0 4 955 3615 0 0 10 /**
 *
 */ 2 4 this 3 3694  5 value 1 3471  
996 0 0 4 956 3615 0 0 10 /**
 *
 */ 2 4 this 3 3694  5 value 1 3471  
997 0 0 4 957 3615 0 0 10 /**
 *
 */ 2 4 this 3 3694  5 value 1 3471  
998 0 0 4 958 3615 0 0 161 /**
 * Returns the address of the first of the four data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */ 1 4 this 3 3695  
999 0 0 6 959 3471 0 0 0 0 
1000 0 0 4 961 3615 0 0 129 /**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */ 2 4 this 3 3694  10 fill_value 1 3471  
1001 0 0 4 962 3615 0 0 10 /**
 *
 */ 5 4 this 3 3694  1 x 1 3471  1 y 1 3471  1 z 1 3471  1 w 1 3471  
1002 0 0 6 963 3471 0 0 10 /**
 *
 */ 2 4 this 3 3695  5 other 1 3695  
1003 0 0 6 964 3471 0 0 69 /**
 * Returns the square of the vector's length, cheap and easy.
 */ 1 4 this 3 3695  
1004 0 0 6 965 3620 0 0 0 2 4 this 3 3695  5 other 1 3695  
1005 0 0 6 966 3620 0 0 0 2 4 this 3 3695  5 other 1 3695  
1006 0 0 6 967 3620 0 0 0 2 4 this 3 3695  5 other 1 3695  
1007 0 0 6 968 3471 0 0 97 /**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */ 2 4 this 3 3695  5 other 1 3695  
1008 0 0 6 969 3613 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 1 4 this 3 3695  
1009 0 0 6 970 3613 0 0 49 /**
 * Adds the vector into the running hash.
 */ 2 4 this 3 3695  4 hash 1 3613  
1010 0 0 4 971 3615 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 2 4 this 3 3695  7 hashgen 1 3621  
1011 0 0 7 972 3694 2833 0 0 1 4 this 3 3695  
1012 0 0 7 973 3694 2833 0 0 2 4 this 3 3695  5 other 1 3695  
1013 0 0 7 974 3694 2833 0 0 2 4 this 3 3695  5 other 1 3695  
1014 0 0 7 975 3694 2833 0 0 2 4 this 3 3695  6 scalar 1 3471  
1015 0 0 7 976 3694 2833 0 0 2 4 this 3 3695  6 scalar 1 3471  
1016 0 0 6 977 3694 0 0 0 2 4 this 3 3694  5 other 1 3695  
1017 0 0 6 978 3694 0 0 0 2 4 this 3 3694  5 other 1 3695  
1018 0 0 6 979 3694 0 0 0 2 4 this 3 3694  6 scalar 1 3471  
1019 0 0 6 980 3694 0 0 0 2 4 this 3 3694  6 scalar 1 3471  
1020 0 0 4 981 3615 0 0 10 /**
 *
 */ 2 4 this 3 3694  5 other 1 3695  
1021 0 0 7 982 3694 2833 0 0 2 4 this 3 3695  8 exponent 1 3471  
1022 0 0 6 983 3616 0 0 0 2 4 this 3 3694  8 exponent 1 3471  
1023 0 0 7 984 3694 2833 0 10 /**
 *
 */ 2 4 this 3 3695  5 other 1 3695  
1024 0 0 7 985 3694 2833 0 10 /**
 *
 */ 2 4 this 3 3695  5 other 1 3695  
1025 0 0 6 986 3620 0 0 116 /**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */ 2 4 this 3 3695  5 other 1 3695  
1026 0 0 6 986 3620 0 0 92 /**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */ 3 4 this 3 3695  5 other 1 3695  9 threshold 1 3471  
1027 0 0 4 987 3615 0 0 10 /**
 *
 */ 2 4 this 3 3695  3 out 1 3623  
1028 0 0 6 988 3619 0 0 0 1 4 this 3 3695  
1029 0 0 4 989 3615 0 0 332 /**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */ 2 4 this 3 3695  11 destination 1 3625  
1030 0 0 4 990 3615 0 0 114 /**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */ 2 4 this 3 3694  6 source 1 3627  
1031 0 0 4 991 3615 0 0 205 /**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */ 2 4 this 3 3695  11 destination 1 3625  
1032 0 0 4 992 3615 0 0 67 /**
 * Reads the vector from the Datagram using get_stdfloat().
 */ 2 4 this 3 3694  6 source 1 3627  
1033 0 0 7 993 3630 0 0 0 0 
1034 0 0 7 997 3699 2841 0 0 0 
1035 0 0 7 997 3699 2841 0 10 /**
 *
 */ 1 4 copy 1 3695  
1036 0 0 7 997 3699 2841 0 0 1 6 param0 0 3697  
1037 0 0 7 997 3699 2841 0 10 /**
 *
 */ 4 1 x 1 3471  1 y 1 3471  1 z 1 3471  1 w 1 3471  
1038 0 0 4 998 3615 0 0 10 /**
 *
 */ 5 4 this 3 3699  1 x 1 3471  1 y 1 3471  1 z 1 3471  1 w 1 3471  
1039 0 0 4 999 3615 0 0 10 /**
 *
 */ 3 4 this 3 3699  1 i 1 3471  10 assign_val 1 3471  
1040 0 0 6 999 3471 0 0 0 2 4 this 3 3697  1 i 1 3471  
1041 0 0 6 1000 3471 0 0 0 0 
1042 0 0 4 1001 3615 0 0 162 /**
 * Returns the address of the first of the three data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */ 1 4 this 3 3697  
1043 0 0 6 1002 3471 0 0 0 0 
1044 0 0 7 1003 3630 0 0 0 0 
1045 0 0 7 1006 3700 2861 0 0 0 
1046 0 0 7 1006 3700 2861 0 10 /**
 *
 */ 2 4 copy 1 3656  1 w 1 3465  
1047 0 0 7 1006 3700 2861 0 10 /**
 *
 */ 1 4 copy 1 3683  
1048 0 0 7 1006 3700 2861 0 0 1 6 param0 0 3701  
1049 0 0 7 1006 3700 2861 0 10 /**
 *
 */ 1 10 fill_value 1 3465  
1050 0 0 7 1006 3700 2861 0 10 /**
 *
 */ 4 1 x 1 3465  1 y 1 3465  1 z 1 3465  1 w 1 3465  
1051 0 0 6 1007 3616 0 0 0 2 4 this 3 3701  9 attr_name 1 3619  
1052 0 0 6 1008 3471 0 0 0 3 4 this 3 3700  9 attr_name 1 3619  6 assign 1 3616  
1053 0 0 6 1009 3701 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
1054 0 0 6 1010 3701 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
1055 0 0 6 1011 3701 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
1056 0 0 6 1012 3701 0 0 35 /**
 * Returns a unit Z vector.
 */ 0 
1057 0 0 6 1013 3701 0 0 35 /**
 * Returns a unit W vector.
 */ 0 
1058 0 0 7 1014 3664 2472 0 58 /**
 * Returns the x, y and z component of this vector
 */ 1 4 this 3 3701  
1059 0 0 7 1015 3637 2142 0 55 /**
 * Returns the x and y component of this vector
 */ 1 4 this 3 3701  
1060 0 0 7 1018 3700 2861 0 0 1 4 this 3 3701  
1061 0 0 7 1019 3682 2673 0 0 2 4 this 3 3701  5 other 1 3683  
1062 0 0 7 1019 3700 2861 0 0 2 4 this 3 3701  5 other 1 3701  
1063 0 0 7 1020 3682 2673 0 0 2 4 this 3 3701  5 other 1 3683  
1064 0 0 7 1020 3700 2861 0 0 2 4 this 3 3701  5 other 1 3701  
1065 0 0 7 1021 3700 2861 0 0 2 4 this 3 3701  6 scalar 1 3465  
1066 0 0 7 1022 3700 2861 0 0 2 4 this 3 3701  6 scalar 1 3465  
1067 0 0 7 1023 3700 2861 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3701  
1068 0 0 7 1024 3700 2861 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3701  4 onto 1 3683  
1069 0 0 6 1025 3619 0 0 0 1 4 this 3 3701  
1070 0 0 7 1026 3630 0 0 0 0 
1071 0 0 7 1029 3703 2881 0 0 0 
1072 0 0 7 1029 3703 2881 0 10 /**
 *
 */ 2 4 copy 1 3659  1 w 1 3468  
1073 0 0 7 1029 3703 2881 0 10 /**
 *
 */ 1 4 copy 1 3689  
1074 0 0 7 1029 3703 2881 0 0 1 6 param0 0 3704  
1075 0 0 7 1029 3703 2881 0 10 /**
 *
 */ 1 10 fill_value 1 3468  
1076 0 0 7 1029 3703 2881 0 10 /**
 *
 */ 4 1 x 1 3468  1 y 1 3468  1 z 1 3468  1 w 1 3468  
1077 0 0 6 1030 3616 0 0 0 2 4 this 3 3704  9 attr_name 1 3619  
1078 0 0 6 1031 3471 0 0 0 3 4 this 3 3703  9 attr_name 1 3619  6 assign 1 3616  
1079 0 0 6 1032 3704 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
1080 0 0 6 1033 3704 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
1081 0 0 6 1034 3704 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
1082 0 0 6 1035 3704 0 0 35 /**
 * Returns a unit Z vector.
 */ 0 
1083 0 0 6 1036 3704 0 0 35 /**
 * Returns a unit W vector.
 */ 0 
1084 0 0 7 1037 3667 2506 0 58 /**
 * Returns the x, y and z component of this vector
 */ 1 4 this 3 3704  
1085 0 0 7 1038 3640 2160 0 55 /**
 * Returns the x and y component of this vector
 */ 1 4 this 3 3704  
1086 0 0 7 1041 3703 2881 0 0 1 4 this 3 3704  
1087 0 0 7 1042 3688 2755 0 0 2 4 this 3 3704  5 other 1 3689  
1088 0 0 7 1042 3703 2881 0 0 2 4 this 3 3704  5 other 1 3704  
1089 0 0 7 1043 3688 2755 0 0 2 4 this 3 3704  5 other 1 3689  
1090 0 0 7 1043 3703 2881 0 0 2 4 this 3 3704  5 other 1 3704  
1091 0 0 7 1044 3703 2881 0 0 2 4 this 3 3704  6 scalar 1 3468  
1092 0 0 7 1045 3703 2881 0 0 2 4 this 3 3704  6 scalar 1 3468  
1093 0 0 7 1046 3703 2881 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3704  
1094 0 0 7 1047 3703 2881 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3704  4 onto 1 3689  
1095 0 0 6 1048 3619 0 0 0 1 4 this 3 3704  
1096 0 0 7 1049 3630 0 0 0 0 
1097 0 0 7 1052 3706 2899 0 0 0 
1098 0 0 7 1052 3706 2899 0 10 /**
 *
 */ 2 4 copy 1 3662  1 w 1 3471  
1099 0 0 7 1052 3706 2899 0 10 /**
 *
 */ 1 4 copy 1 3695  
1100 0 0 7 1052 3706 2899 0 0 1 6 param0 0 3707  
1101 0 0 7 1052 3706 2899 0 10 /**
 *
 */ 1 10 fill_value 1 3471  
1102 0 0 7 1052 3706 2899 0 10 /**
 *
 */ 4 1 x 1 3471  1 y 1 3471  1 z 1 3471  1 w 1 3471  
1103 0 0 6 1053 3616 0 0 0 2 4 this 3 3707  9 attr_name 1 3619  
1104 0 0 6 1054 3471 0 0 0 3 4 this 3 3706  9 attr_name 1 3619  6 assign 1 3616  
1105 0 0 6 1055 3707 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
1106 0 0 6 1056 3707 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
1107 0 0 6 1057 3707 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
1108 0 0 6 1058 3707 0 0 35 /**
 * Returns a unit Z vector.
 */ 0 
1109 0 0 6 1059 3707 0 0 35 /**
 * Returns a unit W vector.
 */ 0 
1110 0 0 7 1060 3670 2532 0 58 /**
 * Returns the x, y and z component of this vector
 */ 1 4 this 3 3707  
1111 0 0 7 1061 3643 2174 0 55 /**
 * Returns the x and y component of this vector
 */ 1 4 this 3 3707  
1112 0 0 7 1064 3706 2899 0 0 1 4 this 3 3707  
1113 0 0 7 1065 3694 2833 0 0 2 4 this 3 3707  5 other 1 3695  
1114 0 0 7 1065 3706 2899 0 0 2 4 this 3 3707  5 other 1 3707  
1115 0 0 7 1066 3694 2833 0 0 2 4 this 3 3707  5 other 1 3695  
1116 0 0 7 1066 3706 2899 0 0 2 4 this 3 3707  5 other 1 3707  
1117 0 0 7 1067 3706 2899 0 0 2 4 this 3 3707  6 scalar 1 3471  
1118 0 0 7 1068 3706 2899 0 0 2 4 this 3 3707  6 scalar 1 3471  
1119 0 0 6 1069 3619 0 0 0 1 4 this 3 3707  
1120 0 0 7 1070 3630 0 0 0 0 
1121 0 0 7 1073 3709 2919 0 0 0 
1122 0 0 7 1073 3709 2919 0 0 1 6 param0 0 3710  
1123 0 0 7 1073 3709 2919 0 10 /**
 *
 */ 2 4 copy 1 3656  1 w 1 3465  
1124 0 0 7 1073 3709 2919 0 10 /**
 *
 */ 1 4 copy 1 3683  
1125 0 0 7 1073 3709 2919 0 10 /**
 *
 */ 1 10 fill_value 1 3465  
1126 0 0 7 1073 3709 2919 0 10 /**
 *
 */ 4 1 x 1 3465  1 y 1 3465  1 z 1 3465  1 w 1 3465  
1127 0 0 6 1074 3616 0 0 0 2 4 this 3 3710  9 attr_name 1 3619  
1128 0 0 6 1075 3471 0 0 0 3 4 this 3 3709  9 attr_name 1 3619  6 assign 1 3616  
1129 0 0 6 1076 3710 0 0 39 /**
 * Returns a zero-length point.
 */ 0 
1130 0 0 6 1077 3710 0 0 34 /**
 * Returns a unit X point.
 */ 0 
1131 0 0 6 1078 3710 0 0 34 /**
 * Returns a unit Y point.
 */ 0 
1132 0 0 6 1079 3710 0 0 34 /**
 * Returns a unit Z point.
 */ 0 
1133 0 0 6 1080 3710 0 0 34 /**
 * Returns a unit W point.
 */ 0 
1134 0 0 7 1081 3673 2555 0 58 /**
 * Returns the x, y and z component of this vector
 */ 1 4 this 3 3710  
1135 0 0 7 1082 3646 2190 0 55 /**
 * Returns the x and y component of this vector
 */ 1 4 this 3 3710  
1136 0 0 7 1085 3709 2919 0 0 1 4 this 3 3710  
1137 0 0 7 1086 3682 2673 0 0 2 4 this 3 3710  5 other 1 3683  
1138 0 0 7 1086 3709 2919 0 0 2 4 this 3 3710  5 other 1 3701  
1139 0 0 7 1087 3700 2861 0 0 2 4 this 3 3710  5 other 1 3710  
1140 0 0 7 1087 3682 2673 0 0 2 4 this 3 3710  5 other 1 3683  
1141 0 0 7 1087 3709 2919 0 0 2 4 this 3 3710  5 other 1 3701  
1142 0 0 7 1088 3709 2919 0 0 2 4 this 3 3710  6 scalar 1 3465  
1143 0 0 7 1089 3709 2919 0 0 2 4 this 3 3710  6 scalar 1 3465  
1144 0 0 7 1090 3709 2919 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3710  
1145 0 0 7 1091 3709 2919 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3710  4 onto 1 3683  
1146 0 0 6 1092 3619 0 0 0 1 4 this 3 3710  
1147 0 0 7 1093 3630 0 0 0 0 
1148 0 0 7 1096 3712 2939 0 0 0 
1149 0 0 7 1096 3712 2939 0 0 1 6 param0 0 3713  
1150 0 0 7 1096 3712 2939 0 10 /**
 *
 */ 2 4 copy 1 3659  1 w 1 3468  
1151 0 0 7 1096 3712 2939 0 10 /**
 *
 */ 1 4 copy 1 3689  
1152 0 0 7 1096 3712 2939 0 10 /**
 *
 */ 1 10 fill_value 1 3468  
1153 0 0 7 1096 3712 2939 0 10 /**
 *
 */ 4 1 x 1 3468  1 y 1 3468  1 z 1 3468  1 w 1 3468  
1154 0 0 6 1097 3616 0 0 0 2 4 this 3 3713  9 attr_name 1 3619  
1155 0 0 6 1098 3471 0 0 0 3 4 this 3 3712  9 attr_name 1 3619  6 assign 1 3616  
1156 0 0 6 1099 3713 0 0 39 /**
 * Returns a zero-length point.
 */ 0 
1157 0 0 6 1100 3713 0 0 34 /**
 * Returns a unit X point.
 */ 0 
1158 0 0 6 1101 3713 0 0 34 /**
 * Returns a unit Y point.
 */ 0 
1159 0 0 6 1102 3713 0 0 34 /**
 * Returns a unit Z point.
 */ 0 
1160 0 0 6 1103 3713 0 0 34 /**
 * Returns a unit W point.
 */ 0 
1161 0 0 7 1104 3676 2578 0 58 /**
 * Returns the x, y and z component of this vector
 */ 1 4 this 3 3713  
1162 0 0 7 1105 3649 2206 0 55 /**
 * Returns the x and y component of this vector
 */ 1 4 this 3 3713  
1163 0 0 7 1108 3712 2939 0 0 1 4 this 3 3713  
1164 0 0 7 1109 3688 2755 0 0 2 4 this 3 3713  5 other 1 3689  
1165 0 0 7 1109 3712 2939 0 0 2 4 this 3 3713  5 other 1 3704  
1166 0 0 7 1110 3703 2881 0 0 2 4 this 3 3713  5 other 1 3713  
1167 0 0 7 1110 3688 2755 0 0 2 4 this 3 3713  5 other 1 3689  
1168 0 0 7 1110 3712 2939 0 0 2 4 this 3 3713  5 other 1 3704  
1169 0 0 7 1111 3712 2939 0 0 2 4 this 3 3713  6 scalar 1 3468  
1170 0 0 7 1112 3712 2939 0 0 2 4 this 3 3713  6 scalar 1 3468  
1171 0 0 7 1113 3712 2939 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3713  
1172 0 0 7 1114 3712 2939 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3713  4 onto 1 3689  
1173 0 0 6 1115 3619 0 0 0 1 4 this 3 3713  
1174 0 0 7 1116 3630 0 0 0 0 
1175 0 0 7 1119 3715 2957 0 0 0 
1176 0 0 7 1119 3715 2957 0 0 1 6 param0 0 3716  
1177 0 0 7 1119 3715 2957 0 10 /**
 *
 */ 2 4 copy 1 3662  1 w 1 3471  
1178 0 0 7 1119 3715 2957 0 10 /**
 *
 */ 1 4 copy 1 3695  
1179 0 0 7 1119 3715 2957 0 10 /**
 *
 */ 1 10 fill_value 1 3471  
1180 0 0 7 1119 3715 2957 0 10 /**
 *
 */ 4 1 x 1 3471  1 y 1 3471  1 z 1 3471  1 w 1 3471  
1181 0 0 6 1120 3616 0 0 0 2 4 this 3 3716  9 attr_name 1 3619  
1182 0 0 6 1121 3471 0 0 0 3 4 this 3 3715  9 attr_name 1 3619  6 assign 1 3616  
1183 0 0 6 1122 3716 0 0 39 /**
 * Returns a zero-length point.
 */ 0 
1184 0 0 6 1123 3716 0 0 34 /**
 * Returns a unit X point.
 */ 0 
1185 0 0 6 1124 3716 0 0 34 /**
 * Returns a unit Y point.
 */ 0 
1186 0 0 6 1125 3716 0 0 34 /**
 * Returns a unit Z point.
 */ 0 
1187 0 0 6 1126 3716 0 0 34 /**
 * Returns a unit W point.
 */ 0 
1188 0 0 7 1127 3679 2599 0 58 /**
 * Returns the x, y and z component of this vector
 */ 1 4 this 3 3716  
1189 0 0 7 1128 3652 2220 0 55 /**
 * Returns the x and y component of this vector
 */ 1 4 this 3 3716  
1190 0 0 7 1131 3715 2957 0 0 1 4 this 3 3716  
1191 0 0 7 1132 3694 2833 0 0 2 4 this 3 3716  5 other 1 3695  
1192 0 0 7 1132 3715 2957 0 0 2 4 this 3 3716  5 other 1 3707  
1193 0 0 7 1133 3706 2899 0 0 2 4 this 3 3716  5 other 1 3716  
1194 0 0 7 1133 3694 2833 0 0 2 4 this 3 3716  5 other 1 3695  
1195 0 0 7 1133 3715 2957 0 0 2 4 this 3 3716  5 other 1 3707  
1196 0 0 7 1134 3715 2957 0 0 2 4 this 3 3716  6 scalar 1 3471  
1197 0 0 7 1135 3715 2957 0 0 2 4 this 3 3716  6 scalar 1 3471  
1198 0 0 6 1136 3619 0 0 0 1 4 this 3 3716  
1199 0 0 7 1137 3630 0 0 0 0 
1200 0 0 7 1151 3718 3041 0 10 /**
 *
 */ 0 
1201 0 0 7 1151 3718 3041 0 10 /**
 *
 */ 1 5 other 1 3719  
1202 0 0 7 1151 3718 3041 0 10 /**
 *
 */ 9 3 e00 1 3465  3 e01 1 3465  3 e02 1 3465  3 e10 1 3465  3 e11 1 3465  3 e12 1 3465  3 e20 1 3465  3 e21 1 3465  3 e22 1 3465  
1203 0 0 6 1152 3718 0 0 10 /**
 *
 */ 2 4 this 3 3718  5 other 1 3719  
1204 0 0 6 1152 3718 0 0 10 /**
 *
 */ 2 4 this 3 3718  10 fill_value 1 3465  
1205 0 0 4 1153 3615 0 0 0 2 4 this 3 3718  4 size 1 3613  
1206 0 0 6 1156 3616 0 0 0 1 4 this 3 3719  
1207 0 0 4 1157 3615 0 0 157 /**
 * Sets each element of the matrix to the indicated fill_value.  This is of
 * questionable value, but is sometimes useful when initializing to zero.
 */ 2 4 this 3 3718  10 fill_value 1 3465  
1208 0 0 4 1158 3615 0 0 10 /**
 *
 */ 10 4 this 3 3718  3 e00 1 3465  3 e01 1 3465  3 e02 1 3465  3 e10 1 3465  3 e11 1 3465  3 e12 1 3465  3 e20 1 3465  3 e21 1 3465  3 e22 1 3465  
1209 0 0 7 1159 3721 2961 0 0 2 4 this 3 3718  1 i 1 3471  
1210 0 0 7 1159 3722 2965 0 0 2 4 this 3 3719  1 i 1 3471  
1211 0 0 6 1160 3471 0 0 55 /**
 * Returns 3: the number of rows of a LMatrix3.
 */ 0 
1212 0 0 4 1161 3615 0 0 109 /**
 * Replaces the indicated row of the matrix from a two-component vector,
 * ignoring the last column.
 */ 3 4 this 3 3718  3 row 1 3471  1 v 1 3611  
1213 0 0 4 1161 3615 0 0 82 /**
 * Replaces the indicated row of the matrix from a three-component vector.
 */ 3 4 this 3 3718  3 row 1 3471  1 v 1 3656  
1214 0 0 4 1162 3615 0 0 109 /**
 * Replaces the indicated column of the matrix from a two-component vector,
 * ignoring the last row.
 */ 3 4 this 3 3718  3 col 1 3471  1 v 1 3611  
1215 0 0 4 1162 3615 0 0 85 /**
 * Replaces the indicated column of the matrix from a three-component vector.
 */ 3 4 this 3 3718  3 col 1 3471  1 v 1 3656  
1216 0 0 4 1163 3615 0 0 78 /**
 * Stores the indicated row of the matrix as a three-component vector.
 */ 3 4 this 3 3719  10 result_vec 1 3655  3 row 1 3471  
1217 0 0 7 1163 3655 2293 0 79 /**
 * Returns the indicated row of the matrix as a three-component vector.
 */ 2 4 this 3 3719  3 row 1 3471  
1218 0 0 7 1164 3655 2293 0 82 /**
 * Returns the indicated column of the matrix as a three-component vector.
 */ 2 4 this 3 3719  3 col 1 3471  
1219 0 0 7 1169 3610 2002 0 106 /**
 * Returns the indicated row of the matrix as a two-component vector, ignoring
 * the last column.
 */ 2 4 this 3 3719  3 row 1 3471  
1220 0 0 7 1170 3610 2002 0 106 /**
 * Returns the indicated column of the matrix as a two-component vector,
 * ignoring the last row.
 */ 2 4 this 3 3719  3 col 1 3471  
1221 0 0 4 1173 3615 0 0 10 /**
 *
 */ 3 4 this 3 3718  3 row 1 3471  3 col 1 3471  
1222 0 0 6 1173 3465 0 0 0 3 4 this 3 3719  3 row 1 3471  3 col 1 3471  
1223 0 0 6 1174 3620 0 0 91 /**
 * Returns true if any component of the matrix is not-a-number, false
 * otherwise.
 */ 1 4 this 3 3719  
1224 0 0 6 1175 3620 0 0 93 /**
 * Returns true if this is (close enough to) the identity matrix, false
 * otherwise.
 */ 1 4 this 3 3719  
1225 0 0 6 1176 3465 0 0 54 /**
 * Returns a particular element of the matrix.
 */ 3 4 this 3 3719  3 row 1 3471  3 col 1 3471  
1226 0 0 4 1177 3615 0 0 54 /**
 * Changes a particular element of the matrix.
 */ 4 4 this 3 3718  3 row 1 3471  3 col 1 3471  5 value 1 3465  
1227 0 0 4 1178 3615 0 0 162 /**
 * Returns the address of the first of the nine data elements in the matrix.
 * The remaining elements occupy the next eight positions in row-major order.
 */ 1 4 this 3 3719  
1228 0 0 6 1179 3471 0 0 62 /**
 * Returns the number of elements in the matrix, nine.
 */ 1 4 this 3 3719  
1229 0 0 6 1180 3620 0 0 0 2 4 this 3 3719  5 other 1 3719  
1230 0 0 6 1181 3620 0 0 0 2 4 this 3 3719  5 other 1 3719  
1231 0 0 6 1182 3620 0 0 0 2 4 this 3 3719  5 other 1 3719  
1232 0 0 6 1183 3471 0 0 97 /**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */ 2 4 this 3 3719  5 other 1 3719  
1233 0 0 6 1183 3471 0 0 234 /**
 * Sorts matrices lexicographically, componentwise.  Returns a number less
 * than 0 if this matrix sorts before the other one, greater than zero if it
 * sorts after, 0 if they are equivalent (within the indicated tolerance).
 */ 3 4 this 3 3719  5 other 1 3719  9 threshold 1 3465  
1234 0 0 6 1184 3613 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 1 4 this 3 3719  
1235 0 0 6 1184 3613 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 2 4 this 3 3719  9 threshold 1 3465  
1236 0 0 6 1185 3613 0 0 49 /**
 * Adds the vector into the running hash.
 */ 2 4 this 3 3719  4 hash 1 3613  
1237 0 0 6 1185 3613 0 0 49 /**
 * Adds the vector into the running hash.
 */ 3 4 this 3 3719  4 hash 1 3613  9 threshold 1 3465  
1238 0 0 7 1186 3655 2293 0 52 /**
 * 3-component vector or point times matrix.
 */ 2 4 this 3 3719  1 v 1 3656  
1239 0 0 7 1187 3610 2002 0 162 /**
 * The matrix transforms a 2-component point (including translation component)
 * and returns the result.  This assumes the matrix is an affine transform.
 */ 2 4 this 3 3719  1 v 1 3611  
1240 0 0 7 1188 3610 2002 0 161 /**
 * The matrix transforms a 2-component vector (without translation component)
 * and returns the result.  This assumes the matrix is an affine transform.
 */ 2 4 this 3 3719  1 v 1 3611  
1241 0 0 7 1188 3655 2293 0 194 /**
 * The matrix transforms a 3-component vector and returns the result.  This
 * assumes the matrix is an orthonormal transform.
 *
 * In practice, this is the same computation as xform().
 */ 2 4 this 3 3719  1 v 1 3656  
1242 0 0 7 1189 3655 2293 0 142 /**
 * The matrix transforms a 3-component vector (without translation component)
 * and returns the result, as a fully general operation.
 */ 2 4 this 3 3719  1 v 1 3656  
1243 0 0 4 1190 3615 0 0 52 /**
 * 3-component vector or point times matrix.
 */ 2 4 this 3 3719  1 v 1 3655  
1244 0 0 4 1191 3615 0 0 139 /**
 * The matrix transforms a 2-component point (including translation
 * component).  This assumes the matrix is an affine transform.
 */ 2 4 this 3 3719  1 v 1 3610  
1245 0 0 4 1192 3615 0 0 137 /**
 * The matrix transforms a 2-component vector (without translation component).
 * This assumes the matrix is an affine transform.
 */ 2 4 this 3 3719  1 v 1 3610  
1246 0 0 4 1192 3615 0 0 171 /**
 * The matrix transforms a 3-component vector.  This assumes the matrix is an
 * orthonormal transform.
 *
 * In practice, this is the same computation as xform().
 */ 2 4 this 3 3719  1 v 1 3655  
1247 0 0 4 1193 3615 0 0 119 /**
 * The matrix transforms a 3-component vector (without translation component),
 * as a fully general operation.
 */ 2 4 this 3 3719  1 v 1 3655  
1248 0 0 4 1194 3615 0 0 25 // this = other1 * other2 3 4 this 3 3718  6 other1 1 3719  6 other2 1 3719  
1249 0 0 7 1195 3718 3041 0 0 2 4 this 3 3719  5 other 1 3719  
1250 0 0 7 1195 3718 3041 0 0 2 4 this 3 3719  6 scalar 1 3465  
1251 0 0 7 1196 3718 3041 0 0 2 4 this 3 3719  6 scalar 1 3465  
1252 0 0 6 1197 3718 0 0 63 /**
 * Performs a memberwise addition between two matrices.
 */ 2 4 this 3 3718  5 other 1 3719  
1253 0 0 6 1198 3718 0 0 66 /**
 * Performs a memberwise subtraction between two matrices.
 */ 2 4 this 3 3718  5 other 1 3719  
1254 0 0 6 1199 3718 0 0 10 /**
 *
 */ 2 4 this 3 3718  5 other 1 3719  
1255 0 0 6 1199 3718 0 0 39 /**
 * Performs a memberwise scale.
 */ 2 4 this 3 3718  6 scalar 1 3465  
1256 0 0 6 1200 3718 0 0 39 /**
 * Performs a memberwise scale.
 */ 2 4 this 3 3718  6 scalar 1 3465  
1257 0 0 4 1201 3615 0 0 10 /**
 *
 */ 2 4 this 3 3718  5 other 1 3719  
1258 0 0 6 1202 3465 0 0 49 /**
 * Returns the determinant of the matrix.
 */ 1 4 this 3 3719  
1259 0 0 4 1203 3615 0 0 10 /**
 *
 */ 2 4 this 3 3718  5 other 1 3719  
1260 0 0 4 1204 3615 0 0 10 /**
 *
 */ 1 4 this 3 3718  
1261 0 0 6 1205 3620 0 0 463 /**
 * Computes the inverse of the other matrix, and stores the result in this
 * matrix.  This is a fully general operation and makes no assumptions about
 * the type of transform represented by the matrix.
 *
 * The other matrix must be a different object than this matrix.  However, if
 * you need to invert a matrix in place, see invert_in_place.
 *
 * The return value is true if the matrix was successfully inverted, false if
 * there was a singularity.
 */ 2 4 this 3 3718  5 other 1 3719  
1262 0 0 6 1206 3620 0 0 119 /**
 * Inverts the current matrix.  Returns true if the inverse is successful,
 * false if the matrix was singular.
 */ 1 4 this 3 3718  
1263 0 0 6 1207 3620 0 0 114 /**
 * Simultaneously computes the inverse of the indicated matrix, and then the
 * transpose of that inverse.
 */ 2 4 this 3 3718  5 other 1 3719  
1264 0 0 6 1207 3620 0 0 114 /**
 * Simultaneously computes the inverse of the indicated matrix, and then the
 * transpose of that inverse.
 */ 2 4 this 3 3718  5 other 1 3723  
1265 0 0 6 1208 3719 0 0 147 /**
 * Returns an identity matrix.
 *
 * This function definition must appear first, since some inline functions
 * below take advantage of it.
 */ 0 
1266 0 0 4 1209 3615 0 0 74 /**
 * Fills mat with a matrix that applies the indicated translation.
 */ 2 4 this 3 3718  5 trans 1 3611  
1267 0 0 4 1210 3615 0 0 98 /**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise.
 */ 2 4 this 3 3718  5 angle 1 3465  
1268 0 0 4 1210 3615 0 0 125 /**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */ 4 4 this 3 3718  5 angle 1 3465  4 axis 1 3656  2 cs 1 3484  
1269 0 0 4 1211 3615 0 0 95 /**
 * Fills mat with a matrix that applies the indicated scale in each of the two
 * axes.
 */ 2 4 this 3 3718  5 scale 1 3611  
1270 0 0 4 1211 3615 0 0 97 /**
 * Fills mat with a matrix that applies the indicated scale in each of the
 * three axes.
 */ 2 4 this 3 3718  5 scale 1 3656  
1271 0 0 7 1212 3718 3041 0 67 /**
 * Returns a matrix that applies the indicated translation.
 */ 1 5 trans 1 3611  
1272 0 0 7 1212 3718 3041 0 67 /**
 * Returns a matrix that applies the indicated translation.
 */ 2 2 tx 1 3465  2 ty 1 3465  
1273 0 0 7 1213 3718 3041 0 91 /**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise.
 */ 1 5 angle 1 3465  
1274 0 0 7 1213 3718 3041 0 118 /**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */ 3 5 angle 1 3465  4 axis 1 3656  2 cs 1 3484  
1275 0 0 7 1214 3718 3041 0 85 /**
 * Returns a matrix that applies the indicated scale in each of the two axes.
 */ 1 5 scale 1 3611  
1276 0 0 7 1214 3718 3041 0 90 /**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */ 1 5 scale 1 3656  
1277 0 0 7 1214 3718 3041 0 85 /**
 * Returns a matrix that applies the indicated scale in each of the two axes.
 */ 2 2 sx 1 3465  2 sy 1 3465  
1278 0 0 7 1214 3718 3041 0 90 /**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */ 3 2 sx 1 3465  2 sy 1 3465  2 sz 1 3465  
1279 0 0 4 1215 3615 0 0 163 /**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * normalized.
 */ 4 4 this 3 3718  5 angle 1 3465  4 axis 1 3656  2 cs 1 3484  
1280 0 0 7 1216 3718 3041 0 156 /**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * normalized.
 */ 3 5 angle 1 3465  4 axis 1 3656  2 cs 1 3484  
1281 0 0 4 1217 3615 0 0 99 /**
 * Fills mat with a matrix that applies the indicated shear in each of the
 * three planes.
 */ 3 4 this 3 3718  5 shear 1 3656  2 cs 1 3484  
1282 0 0 7 1218 3718 3041 0 92 /**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */ 2 5 shear 1 3656  2 cs 1 3484  
1283 0 0 7 1218 3718 3041 0 92 /**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */ 4 4 shxy 1 3465  4 shxz 1 3465  4 shyz 1 3465  2 cs 1 3484  
1284 0 0 4 1219 3615 0 0 78 /**
 * Fills mat with a matrix that applies the indicated scale and shear.
 */ 4 4 this 3 3718  5 scale 1 3656  5 shear 1 3656  2 cs 1 3484  
1285 0 0 7 1220 3718 3041 0 71 /**
 * Returns a matrix that applies the indicated scale and shear.
 */ 3 5 scale 1 3656  5 shear 1 3656  2 cs 1 3484  
1286 0 0 7 1220 3718 3041 0 71 /**
 * Returns a matrix that applies the indicated scale and shear.
 */ 7 2 sx 1 3465  2 sy 1 3465  2 sz 1 3465  4 shxy 1 3465  4 shxz 1 3465  4 shyz 1 3465  2 cs 1 3484  
1287 0 0 6 1221 3719 0 0 119 /**
 * Returns a matrix that transforms from the indicated coordinate system to
 * the indicated coordinate system.
 */ 2 4 from 1 3484  2 to 1 3484  
1288 0 0 6 1222 3620 0 0 117 /**
 * Returns true if two matrices are memberwise equal within a default
 * tolerance based on the numeric type.
 */ 2 4 this 3 3719  5 other 1 3719  
1289 0 0 6 1222 3620 0 0 93 /**
 * Returns true if two matrices are memberwise equal within a specified
 * tolerance.
 */ 3 4 this 3 3719  5 other 1 3719  9 threshold 1 3465  
1290 0 0 4 1223 3615 0 0 10 /**
 *
 */ 2 4 this 3 3719  3 out 1 3623  
1291 0 0 4 1224 3615 0 0 10 /**
 *
 */ 3 4 this 3 3719  3 out 1 3623  12 indent_level 1 3471  
1292 0 0 6 1225 3619 0 0 0 1 4 this 3 3719  
1293 0 0 4 1226 3615 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 2 4 this 3 3719  7 hashgen 1 3621  
1294 0 0 4 1226 3615 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 3 4 this 3 3719  7 hashgen 1 3621  9 threshold 1 3465  
1295 0 0 4 1227 3615 0 0 332 /**
 * Writes the matrix to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the matrix, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */ 2 4 this 3 3719  11 destination 1 3625  
1296 0 0 4 1228 3615 0 0 114 /**
 * Reads the matrix from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */ 2 4 this 3 3718  4 scan 1 3627  
1297 0 0 4 1229 3615 0 0 205 /**
 * Writes the matrix to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the matrix using the standard width
 * setting, especially when you are writing a bam file.
 */ 2 4 this 3 3719  11 destination 1 3625  
1298 0 0 4 1230 3615 0 0 67 /**
 * Reads the matrix from the Datagram using get_stdfloat().
 */ 2 4 this 3 3718  6 source 1 3627  
1299 0 0 7 1231 3630 0 0 0 0 
1300 0 0 7 1144 3721 2961 0 0 1 6 param0 0 3725  
1301 0 0 4 1142 3615 0 0 10 /**
 *
 */ 3 4 this 3 3721  1 i 1 3471  10 assign_val 1 3465  
1302 0 0 6 1142 3465 0 0 0 2 4 this 3 3725  1 i 1 3471  
1303 0 0 6 1143 3471 0 0 58 /**
 * Returns 3: the number of columns of a LMatrix3.
 */ 0 
1304 0 0 7 1149 3722 2965 0 0 1 6 param0 0 3727  
1305 0 0 6 1147 3465 0 0 0 2 4 this 3 3727  1 i 1 3471  
1306 0 0 6 1148 3471 0 0 58 /**
 * Returns 3: the number of columns of a LMatrix3.
 */ 0 
1307 0 0 7 1247 3729 3137 0 10 /**
 *
 */ 0 
1308 0 0 7 1247 3729 3137 0 95 // Construct a 4x4 matrix given a 3x3 rotation matrix and an optional
// translation component. 1 6 upper3 1 3719  
1309 0 0 7 1247 3729 3137 0 10 /**
 *
 */ 2 6 upper3 1 3719  5 trans 1 3656  
1310 0 0 7 1247 3729 3137 0 10 /**
 *
 */ 1 5 other 1 3723  
1311 0 0 7 1247 3729 3137 0 10 /**
 *
 */ 1 5 other 1 3730  
1312 0 0 7 1247 3729 3137 0 10 /**
 *
 */ 16 3 e00 1 3465  3 e01 1 3465  3 e02 1 3465  3 e03 1 3465  3 e10 1 3465  3 e11 1 3465  3 e12 1 3465  3 e13 1 3465  3 e20 1 3465  3 e21 1 3465  3 e22 1 3465  3 e23 1 3465  3 e30 1 3465  3 e31 1 3465  3 e32 1 3465  3 e33 1 3465  
1313 0 0 6 1248 3729 0 0 10 /**
 *
 */ 2 4 this 3 3729  5 other 1 3723  
1314 0 0 6 1248 3729 0 0 10 /**
 *
 */ 2 4 this 3 3729  5 other 1 3730  
1315 0 0 6 1248 3729 0 0 10 /**
 *
 */ 2 4 this 3 3729  10 fill_value 1 3465  
1316 0 0 4 1249 3615 0 0 0 2 4 this 3 3729  4 size 1 3613  
1317 0 0 6 1252 3616 0 0 0 1 4 this 3 3723  
1318 0 0 4 1253 3615 0 0 157 /**
 * Sets each element of the matrix to the indicated fill_value.  This is of
 * questionable value, but is sometimes useful when initializing to zero.
 */ 2 4 this 3 3729  10 fill_value 1 3465  
1319 0 0 4 1254 3615 0 0 10 /**
 *
 */ 17 4 this 3 3729  3 e00 1 3465  3 e01 1 3465  3 e02 1 3465  3 e03 1 3465  3 e10 1 3465  3 e11 1 3465  3 e12 1 3465  3 e13 1 3465  3 e20 1 3465  3 e21 1 3465  3 e22 1 3465  3 e23 1 3465  3 e30 1 3465  3 e31 1 3465  3 e32 1 3465  3 e33 1 3465  
1320 0 0 4 1255 3615 0 0 45 // Get and set the upper 3x3 rotation matrix. 2 4 this 3 3729  6 upper3 1 3719  
1321 0 0 7 1256 3718 3041 0 45 /**
 * Retrieves the upper 3x3 submatrix.
 */ 1 4 this 3 3723  
1322 0 0 7 1257 3732 3047 0 0 2 4 this 3 3729  1 i 1 3471  
1323 0 0 7 1257 3733 3051 0 0 2 4 this 3 3723  1 i 1 3471  
1324 0 0 6 1258 3471 0 0 55 /**
 * Returns 4: the number of rows of a LMatrix4.
 */ 0 
1325 0 0 4 1259 3615 0 0 119 /**
 * Replaces the indicated row of the matrix with the indicated 3-component
 * vector, ignoring the last column.
 */ 3 4 this 3 3729  3 row 1 3471  1 v 1 3656  
1326 0 0 4 1259 3615 0 0 52 /**
 * Replaces the indicated row of the matrix.
 */ 3 4 this 3 3729  3 row 1 3471  1 v 1 3683  
1327 0 0 4 1260 3615 0 0 119 /**
 * Replaces the indicated column of the matrix with the indicated 3-component
 * vector, ignoring the last row.
 */ 3 4 this 3 3729  3 col 1 3471  1 v 1 3656  
1328 0 0 4 1260 3615 0 0 55 /**
 * Replaces the indicated column of the matrix.
 */ 3 4 this 3 3729  3 col 1 3471  1 v 1 3683  
1329 0 0 4 1261 3615 0 0 74 /**
 * Stores the indicated row of the matrix as a 4-component vector.
 */ 3 4 this 3 3723  10 result_vec 1 3682  3 row 1 3471  
1330 0 0 7 1261 3682 2673 0 77 /**
 * Retrieves the indicated row of the matrix as a 4-component vector.
 */ 2 4 this 3 3723  3 row 1 3471  
1331 0 0 7 1262 3682 2673 0 80 /**
 * Retrieves the indicated column of the matrix as a 4-component vector.
 */ 2 4 this 3 3723  3 col 1 3471  
1332 0 0 4 1263 3615 0 0 100 /**
 * Stores the row column of the matrix as a 3-component vector, ignoring the
 * last column.
 */ 3 4 this 3 3723  10 result_vec 1 3655  3 row 1 3471  
1333 0 0 7 1263 3655 2293 0 103 /**
 * Retrieves the row column of the matrix as a 3-component vector, ignoring
 * the last column.
 */ 2 4 this 3 3723  3 row 1 3471  
1334 0 0 7 1269 3655 2293 0 106 /**
 * Retrieves the indicated column of the matrix as a 3-component vector,
 * ignoring the last row.
 */ 2 4 this 3 3723  3 col 1 3471  
1335 0 0 4 1270 3615 0 0 10 /**
 *
 */ 3 4 this 3 3729  3 row 1 3471  3 col 1 3471  
1336 0 0 6 1270 3465 0 0 0 3 4 this 3 3723  3 row 1 3471  3 col 1 3471  
1337 0 0 6 1271 3620 0 0 91 /**
 * Returns true if any component of the matrix is not-a-number, false
 * otherwise.
 */ 1 4 this 3 3723  
1338 0 0 6 1272 3620 0 0 93 /**
 * Returns true if this is (close enough to) the identity matrix, false
 * otherwise.
 */ 1 4 this 3 3723  
1339 0 0 6 1273 3465 0 0 54 /**
 * Returns a particular element of the matrix.
 */ 3 4 this 3 3723  3 row 1 3471  3 col 1 3471  
1340 0 0 4 1274 3615 0 0 54 /**
 * Changes a particular element of the matrix.
 */ 4 4 this 3 3729  3 row 1 3471  3 col 1 3471  5 value 1 3465  
1341 0 0 4 1275 3615 0 0 162 /**
 * Returns the address of the first of the nine data elements in the matrix.
 * The remaining elements occupy the next eight positions in row-major order.
 */ 1 4 this 3 3723  
1342 0 0 6 1276 3471 0 0 60 /**
 * Returns the number of elements in the matrix, 16.
 */ 1 4 this 3 3723  
1343 0 0 4 1277 3615 0 0 101 /**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */ 1 4 this 3 3729  
1344 0 0 4 1277 3615 0 0 101 /**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */ 1 4 this 3 3723  
1345 0 0 4 1278 3615 0 0 101 /**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */ 1 4 this 3 3729  
1346 0 0 4 1278 3615 0 0 101 /**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */ 1 4 this 3 3723  
1347 0 0 6 1279 3620 0 0 0 2 4 this 3 3723  5 other 1 3723  
1348 0 0 6 1280 3620 0 0 0 2 4 this 3 3723  5 other 1 3723  
1349 0 0 6 1281 3620 0 0 0 2 4 this 3 3723  5 other 1 3723  
1350 0 0 6 1282 3471 0 0 97 /**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */ 2 4 this 3 3723  5 other 1 3723  
1351 0 0 6 1282 3471 0 0 234 /**
 * Sorts matrices lexicographically, componentwise.  Returns a number less
 * than 0 if this matrix sorts before the other one, greater than zero if it
 * sorts after, 0 if they are equivalent (within the indicated tolerance).
 */ 3 4 this 3 3723  5 other 1 3723  9 threshold 1 3465  
1352 0 0 6 1283 3613 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 1 4 this 3 3723  
1353 0 0 6 1283 3613 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 2 4 this 3 3723  9 threshold 1 3465  
1354 0 0 6 1284 3613 0 0 49 /**
 * Adds the vector into the running hash.
 */ 2 4 this 3 3723  4 hash 1 3613  
1355 0 0 6 1284 3613 0 0 49 /**
 * Adds the vector into the running hash.
 */ 3 4 this 3 3723  4 hash 1 3613  9 threshold 1 3465  
1356 0 0 7 1285 3682 2673 0 91 /**
 * 4-component vector or point times matrix.  This is a fully general
 * operation.
 */ 2 4 this 3 3723  1 v 1 3683  
1357 0 0 7 1286 3655 2293 0 162 /**
 * The matrix transforms a 3-component point (including translation component)
 * and returns the result.  This assumes the matrix is an affine transform.
 */ 2 4 this 3 3723  1 v 1 3656  
1358 0 0 7 1287 3655 2293 0 143 /**
 * The matrix transforms a 3-component point (including translation component)
 * and returns the result, as a fully general operation.
 */ 2 4 this 3 3723  1 v 1 3656  
1359 0 0 7 1288 3655 2293 0 169 /**
 * The matrix transforms a 3-component vector (without translation component)
 * and returns the result.  This assumes the matrix is an orthonormal
 * transform.
 */ 2 4 this 3 3723  1 v 1 3656  
1360 0 0 7 1289 3655 2293 0 142 /**
 * The matrix transforms a 3-component vector (without translation component)
 * and returns the result, as a fully general operation.
 */ 2 4 this 3 3723  1 v 1 3656  
1361 0 0 4 1290 3615 0 0 91 /**
 * 4-component vector or point times matrix.  This is a fully general
 * operation.
 */ 2 4 this 3 3723  1 v 1 3682  
1362 0 0 4 1291 3615 0 0 139 /**
 * The matrix transforms a 3-component point (including translation
 * component).  This assumes the matrix is an affine transform.
 */ 2 4 this 3 3723  1 v 1 3655  
1363 0 0 4 1292 3615 0 0 120 /**
 * The matrix transforms a 3-component point (including translation
 * component), as a fully general operation.
 */ 2 4 this 3 3723  1 v 1 3655  
1364 0 0 4 1293 3615 0 0 142 /**
 * The matrix transforms a 3-component vector (without translation component).
 * This assumes the matrix is an orthonormal transform.
 */ 2 4 this 3 3723  1 v 1 3655  
1365 0 0 4 1294 3615 0 0 119 /**
 * The matrix transforms a 3-component vector (without translation component),
 * as a fully general operation.
 */ 2 4 this 3 3723  1 v 1 3655  
1366 0 0 4 1295 3615 0 0 25 // this = other1 * other2 3 4 this 3 3729  6 other1 1 3723  6 other2 1 3723  
1367 0 0 7 1296 3729 3137 0 0 2 4 this 3 3723  5 other 1 3723  
1368 0 0 7 1296 3729 3137 0 0 2 4 this 3 3723  6 scalar 1 3465  
1369 0 0 7 1297 3729 3137 0 0 2 4 this 3 3723  6 scalar 1 3465  
1370 0 0 6 1298 3729 0 0 63 /**
 * Performs a memberwise addition between two matrices.
 */ 2 4 this 3 3729  5 other 1 3723  
1371 0 0 6 1299 3729 0 0 63 /**
 * Performs a memberwise addition between two matrices.
 */ 2 4 this 3 3729  5 other 1 3723  
1372 0 0 6 1300 3729 0 0 10 /**
 *
 */ 2 4 this 3 3729  5 other 1 3723  
1373 0 0 6 1300 3729 0 0 10 /**
 *
 */ 2 4 this 3 3729  6 scalar 1 3465  
1374 0 0 6 1301 3729 0 0 10 /**
 *
 */ 2 4 this 3 3729  6 scalar 1 3465  
1375 0 0 4 1302 3615 0 0 10 /**
 *
 */ 2 4 this 3 3729  5 other 1 3723  
1376 0 0 4 1303 3615 0 0 10 /**
 *
 */ 2 4 this 3 3729  5 other 1 3723  
1377 0 0 4 1304 3615 0 0 10 /**
 *
 */ 1 4 this 3 3729  
1378 0 0 6 1305 3620 0 0 461 /**
 * Computes the inverse of the other matrix, and stores the result in this
 * matrix.  This is a fully general operation and makes no assumptions about
 * the type of transform represented by the matrix.
 *
 * The other matrix must be a different object than this matrix.  However, if
 * you need to invert a matrix in place, see invert_in_place.
 *
 * The return value is true if the matrix was successfully inverted, false if
 * the was a singularity.
 */ 2 4 this 3 3729  5 other 1 3723  
1379 0 0 6 1306 3620 0 0 139 // bugbug: we could optimize this for rotationscaletranslation matrices
// (transpose upper 3x3 and take negative of translation component) 2 4 this 3 3729  5 other 1 3723  
1380 0 0 6 1307 3620 0 0 119 /**
 * Inverts the current matrix.  Returns true if the inverse is successful,
 * false if the matrix was singular.
 */ 1 4 this 3 3729  
1381 0 0 4 1308 3615 0 0 46 /**
 * Computes (*this) += other * weight.
 */ 3 4 this 3 3729  5 other 1 3723  6 weight 1 3465  
1382 0 0 6 1309 3723 0 0 147 /**
 * Returns an identity matrix.
 *
 * This function definition must appear first, since some inline functions
 * below take advantage of it.
 */ 0 
1383 0 0 6 1310 3723 0 0 46 /**
 * Returns an matrix filled with ones.
 */ 0 
1384 0 0 6 1311 3723 0 0 47 /**
 * Returns an matrix filled with zeros.
 */ 0 
1385 0 0 4 1312 3615 0 0 74 /**
 * Fills mat with a matrix that applies the indicated translation.
 */ 2 4 this 3 3729  5 trans 1 3656  
1386 0 0 4 1313 3615 0 0 122 /**
 * Sets mat to a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */ 4 4 this 3 3729  5 angle 1 3465  4 axis 1 3656  2 cs 1 3484  
1387 0 0 4 1314 3615 0 0 166 /**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * prenormalized.
 */ 4 4 this 3 3729  5 angle 1 3465  4 axis 1 3656  2 cs 1 3484  
1388 0 0 4 1315 3615 0 0 97 /**
 * Fills mat with a matrix that applies the indicated scale in each of the
 * three axes.
 */ 2 4 this 3 3729  5 scale 1 3656  
1389 0 0 4 1316 3615 0 0 99 /**
 * Fills mat with a matrix that applies the indicated shear in each of the
 * three planes.
 */ 3 4 this 3 3729  5 shear 1 3656  2 cs 1 3484  
1390 0 0 4 1317 3615 0 0 78 /**
 * Fills mat with a matrix that applies the indicated scale and shear.
 */ 4 4 this 3 3729  5 scale 1 3656  5 shear 1 3656  2 cs 1 3484  
1391 0 0 7 1318 3729 3137 0 67 /**
 * Returns a matrix that applies the indicated translation.
 */ 1 5 trans 1 3656  
1392 0 0 7 1318 3729 3137 0 67 /**
 * Returns a matrix that applies the indicated translation.
 */ 3 2 tx 1 3465  2 ty 1 3465  2 tz 1 3465  
1393 0 0 7 1319 3729 3137 0 118 /**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */ 3 5 angle 1 3465  4 axis 1 3656  2 cs 1 3484  
1394 0 0 7 1320 3729 3137 0 159 /**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * prenormalized.
 */ 3 5 angle 1 3465  4 axis 1 3656  2 cs 1 3484  
1395 0 0 7 1321 3729 3137 0 90 /**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */ 1 5 scale 1 3656  
1396 0 0 7 1321 3729 3137 0 69 /**
 * Returns a matrix that applies the indicated uniform scale.
 */ 1 5 scale 1 3465  
1397 0 0 7 1321 3729 3137 0 90 /**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */ 3 2 sx 1 3465  2 sy 1 3465  2 sz 1 3465  
1398 0 0 7 1322 3729 3137 0 92 /**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */ 2 5 shear 1 3656  2 cs 1 3484  
1399 0 0 7 1322 3729 3137 0 92 /**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */ 4 4 shxy 1 3465  4 shxz 1 3465  4 shyz 1 3465  2 cs 1 3484  
1400 0 0 7 1323 3729 3137 0 71 /**
 * Returns a matrix that applies the indicated scale and shear.
 */ 3 5 scale 1 3656  5 shear 1 3656  2 cs 1 3484  
1401 0 0 7 1323 3729 3137 0 71 /**
 * Returns a matrix that applies the indicated scale and shear.
 */ 7 2 sx 1 3465  2 sy 1 3465  2 sz 1 3465  4 shxy 1 3465  4 shxz 1 3465  4 shyz 1 3465  2 cs 1 3484  
1402 0 0 6 1324 3723 0 0 109 /**
 * Returns a matrix that transforms from the Y-up coordinate system to the
 * Z-up coordinate system.
 */ 0 
1403 0 0 6 1325 3723 0 0 109 /**
 * Returns a matrix that transforms from the Y-up coordinate system to the
 * Z-up coordinate system.
 */ 0 
1404 0 0 6 1326 3723 0 0 119 /**
 * Returns a matrix that transforms from the indicated coordinate system to
 * the indicated coordinate system.
 */ 2 4 from 1 3484  2 to 1 3484  
1405 0 0 6 1327 3620 0 0 117 /**
 * Returns true if two matrices are memberwise equal within a default
 * tolerance based on the numeric type.
 */ 2 4 this 3 3723  5 other 1 3723  
1406 0 0 6 1327 3620 0 0 199 /**
 * Returns true if two matrices are memberwise equal within a specified
 * tolerance.  This is faster than the equivalence operator as this doesn't
 * have to guarantee that it is transitive.
 */ 3 4 this 3 3723  5 other 1 3723  9 threshold 1 3465  
1407 0 0 4 1328 3615 0 0 10 /**
 *
 */ 2 4 this 3 3723  3 out 1 3623  
1408 0 0 4 1329 3615 0 0 10 /**
 *
 */ 3 4 this 3 3723  3 out 1 3623  12 indent_level 1 3471  
1409 0 0 6 1330 3619 0 0 0 1 4 this 3 3723  
1410 0 0 4 1331 3615 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 2 4 this 3 3723  7 hashgen 1 3621  
1411 0 0 4 1331 3615 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 3 4 this 3 3723  7 hashgen 1 3621  5 scale 1 3465  
1412 0 0 4 1332 3615 0 0 332 /**
 * Writes the matrix to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the matrix, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */ 2 4 this 3 3723  11 destination 1 3625  
1413 0 0 4 1333 3615 0 0 114 /**
 * Reads the matrix from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */ 2 4 this 3 3729  4 scan 1 3627  
1414 0 0 4 1334 3615 0 0 205 /**
 * Writes the matrix to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the matrix using the standard width
 * setting, especially when you are writing a bam file.
 */ 2 4 this 3 3723  11 destination 1 3625  
1415 0 0 4 1335 3615 0 0 67 /**
 * Reads the matrix from the Datagram using get_stdfloat().
 */ 2 4 this 3 3729  6 source 1 3627  
1416 0 0 7 1336 3630 0 0 0 0 
1417 0 0 7 1240 3732 3047 0 0 1 6 param0 0 3734  
1418 0 0 4 1238 3615 0 0 10 /**
 *
 */ 3 4 this 3 3732  1 i 1 3471  10 assign_val 1 3465  
1419 0 0 6 1238 3465 0 0 0 2 4 this 3 3734  1 i 1 3471  
1420 0 0 6 1239 3471 0 0 58 /**
 * Returns 4: the number of columns of a LMatrix4.
 */ 0 
1421 0 0 7 1245 3733 3051 0 0 1 6 param0 0 3736  
1422 0 0 6 1243 3465 0 0 0 2 4 this 3 3736  1 i 1 3471  
1423 0 0 6 1244 3471 0 0 58 /**
 * Returns 4: the number of columns of a LMatrix4.
 */ 0 
1424 0 0 7 1340 3738 3145 0 10 /**
 *
 */ 0 
1425 0 0 7 1340 3738 3145 0 10 /**
 *
 */ 1 4 copy 1 3723  
1426 0 0 7 1340 3738 3145 0 10 /**
 *
 */ 1 4 copy 1 3730  
1427 0 0 7 1340 3738 3145 0 10 /**
 *
 */ 16 3 e00 1 3465  3 e01 1 3465  3 e02 1 3465  3 e03 1 3465  3 e10 1 3465  3 e11 1 3465  3 e12 1 3465  3 e13 1 3465  3 e20 1 3465  3 e21 1 3465  3 e22 1 3465  3 e23 1 3465  3 e30 1 3465  3 e31 1 3465  3 e32 1 3465  3 e33 1 3465  
1428 0 0 6 1341 3738 0 0 10 /**
 *
 */ 2 4 this 3 3738  4 copy 1 3723  
1429 0 0 6 1341 3738 0 0 10 /**
 *
 */ 2 4 this 3 3738  4 copy 1 3730  
1430 0 0 4 1342 3615 0 0 10 /**
 *
 */ 17 4 this 3 3738  3 e00 1 3465  3 e01 1 3465  3 e02 1 3465  3 e03 1 3465  3 e10 1 3465  3 e11 1 3465  3 e12 1 3465  3 e13 1 3465  3 e20 1 3465  3 e21 1 3465  3 e22 1 3465  3 e23 1 3465  3 e30 1 3465  3 e31 1 3465  3 e32 1 3465  3 e33 1 3465  
1431 0 0 4 1343 3615 0 0 10 /**
 *
 */ 3 4 this 3 3738  3 row 1 3471  3 col 1 3471  
1432 0 0 6 1343 3465 0 0 0 3 4 this 3 3730  3 row 1 3471  3 col 1 3471  
1433 0 0 4 1344 3615 0 0 162 /**
 * Returns the address of the first of the nine data elements in the matrix.
 * The remaining elements occupy the next eight positions in row-major order.
 */ 1 4 this 3 3730  
1434 0 0 6 1345 3471 0 0 65 /**
 * Returns the number of elements in the matrix, sixteen.
 */ 1 4 this 3 3730  
1435 0 0 7 1346 3630 0 0 0 0 
1436 0 0 7 1360 3739 3229 0 10 /**
 *
 */ 0 
1437 0 0 7 1360 3739 3229 0 10 /**
 *
 */ 1 5 other 1 3740  
1438 0 0 7 1360 3739 3229 0 10 /**
 *
 */ 9 3 e00 1 3468  3 e01 1 3468  3 e02 1 3468  3 e10 1 3468  3 e11 1 3468  3 e12 1 3468  3 e20 1 3468  3 e21 1 3468  3 e22 1 3468  
1439 0 0 6 1361 3739 0 0 10 /**
 *
 */ 2 4 this 3 3739  5 other 1 3740  
1440 0 0 6 1361 3739 0 0 10 /**
 *
 */ 2 4 this 3 3739  10 fill_value 1 3468  
1441 0 0 4 1362 3615 0 0 0 2 4 this 3 3739  4 size 1 3613  
1442 0 0 6 1365 3616 0 0 0 1 4 this 3 3740  
1443 0 0 4 1366 3615 0 0 157 /**
 * Sets each element of the matrix to the indicated fill_value.  This is of
 * questionable value, but is sometimes useful when initializing to zero.
 */ 2 4 this 3 3739  10 fill_value 1 3468  
1444 0 0 4 1367 3615 0 0 10 /**
 *
 */ 10 4 this 3 3739  3 e00 1 3468  3 e01 1 3468  3 e02 1 3468  3 e10 1 3468  3 e11 1 3468  3 e12 1 3468  3 e20 1 3468  3 e21 1 3468  3 e22 1 3468  
1445 0 0 7 1368 3742 3149 0 0 2 4 this 3 3739  1 i 1 3471  
1446 0 0 7 1368 3743 3153 0 0 2 4 this 3 3740  1 i 1 3471  
1447 0 0 6 1369 3471 0 0 55 /**
 * Returns 3: the number of rows of a LMatrix3.
 */ 0 
1448 0 0 4 1370 3615 0 0 109 /**
 * Replaces the indicated row of the matrix from a two-component vector,
 * ignoring the last column.
 */ 3 4 this 3 3739  3 row 1 3471  1 v 1 3632  
1449 0 0 4 1370 3615 0 0 82 /**
 * Replaces the indicated row of the matrix from a three-component vector.
 */ 3 4 this 3 3739  3 row 1 3471  1 v 1 3659  
1450 0 0 4 1371 3615 0 0 109 /**
 * Replaces the indicated column of the matrix from a two-component vector,
 * ignoring the last row.
 */ 3 4 this 3 3739  3 col 1 3471  1 v 1 3632  
1451 0 0 4 1371 3615 0 0 85 /**
 * Replaces the indicated column of the matrix from a three-component vector.
 */ 3 4 this 3 3739  3 col 1 3471  1 v 1 3659  
1452 0 0 4 1372 3615 0 0 78 /**
 * Stores the indicated row of the matrix as a three-component vector.
 */ 3 4 this 3 3740  10 result_vec 1 3658  3 row 1 3471  
1453 0 0 7 1372 3658 2366 0 79 /**
 * Returns the indicated row of the matrix as a three-component vector.
 */ 2 4 this 3 3740  3 row 1 3471  
1454 0 0 7 1373 3658 2366 0 82 /**
 * Returns the indicated column of the matrix as a three-component vector.
 */ 2 4 this 3 3740  3 col 1 3471  
1455 0 0 7 1378 3631 2065 0 106 /**
 * Returns the indicated row of the matrix as a two-component vector, ignoring
 * the last column.
 */ 2 4 this 3 3740  3 row 1 3471  
1456 0 0 7 1379 3631 2065 0 106 /**
 * Returns the indicated column of the matrix as a two-component vector,
 * ignoring the last row.
 */ 2 4 this 3 3740  3 col 1 3471  
1457 0 0 4 1382 3615 0 0 10 /**
 *
 */ 3 4 this 3 3739  3 row 1 3471  3 col 1 3471  
1458 0 0 6 1382 3468 0 0 0 3 4 this 3 3740  3 row 1 3471  3 col 1 3471  
1459 0 0 6 1383 3620 0 0 91 /**
 * Returns true if any component of the matrix is not-a-number, false
 * otherwise.
 */ 1 4 this 3 3740  
1460 0 0 6 1384 3620 0 0 93 /**
 * Returns true if this is (close enough to) the identity matrix, false
 * otherwise.
 */ 1 4 this 3 3740  
1461 0 0 6 1385 3468 0 0 54 /**
 * Returns a particular element of the matrix.
 */ 3 4 this 3 3740  3 row 1 3471  3 col 1 3471  
1462 0 0 4 1386 3615 0 0 54 /**
 * Changes a particular element of the matrix.
 */ 4 4 this 3 3739  3 row 1 3471  3 col 1 3471  5 value 1 3468  
1463 0 0 4 1387 3615 0 0 162 /**
 * Returns the address of the first of the nine data elements in the matrix.
 * The remaining elements occupy the next eight positions in row-major order.
 */ 1 4 this 3 3740  
1464 0 0 6 1388 3471 0 0 62 /**
 * Returns the number of elements in the matrix, nine.
 */ 1 4 this 3 3740  
1465 0 0 6 1389 3620 0 0 0 2 4 this 3 3740  5 other 1 3740  
1466 0 0 6 1390 3620 0 0 0 2 4 this 3 3740  5 other 1 3740  
1467 0 0 6 1391 3620 0 0 0 2 4 this 3 3740  5 other 1 3740  
1468 0 0 6 1392 3471 0 0 97 /**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */ 2 4 this 3 3740  5 other 1 3740  
1469 0 0 6 1392 3471 0 0 234 /**
 * Sorts matrices lexicographically, componentwise.  Returns a number less
 * than 0 if this matrix sorts before the other one, greater than zero if it
 * sorts after, 0 if they are equivalent (within the indicated tolerance).
 */ 3 4 this 3 3740  5 other 1 3740  9 threshold 1 3468  
1470 0 0 6 1393 3613 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 1 4 this 3 3740  
1471 0 0 6 1393 3613 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 2 4 this 3 3740  9 threshold 1 3468  
1472 0 0 6 1394 3613 0 0 49 /**
 * Adds the vector into the running hash.
 */ 2 4 this 3 3740  4 hash 1 3613  
1473 0 0 6 1394 3613 0 0 49 /**
 * Adds the vector into the running hash.
 */ 3 4 this 3 3740  4 hash 1 3613  9 threshold 1 3468  
1474 0 0 7 1395 3658 2366 0 52 /**
 * 3-component vector or point times matrix.
 */ 2 4 this 3 3740  1 v 1 3659  
1475 0 0 7 1396 3631 2065 0 162 /**
 * The matrix transforms a 2-component point (including translation component)
 * and returns the result.  This assumes the matrix is an affine transform.
 */ 2 4 this 3 3740  1 v 1 3632  
1476 0 0 7 1397 3631 2065 0 161 /**
 * The matrix transforms a 2-component vector (without translation component)
 * and returns the result.  This assumes the matrix is an affine transform.
 */ 2 4 this 3 3740  1 v 1 3632  
1477 0 0 7 1397 3658 2366 0 194 /**
 * The matrix transforms a 3-component vector and returns the result.  This
 * assumes the matrix is an orthonormal transform.
 *
 * In practice, this is the same computation as xform().
 */ 2 4 this 3 3740  1 v 1 3659  
1478 0 0 7 1398 3658 2366 0 142 /**
 * The matrix transforms a 3-component vector (without translation component)
 * and returns the result, as a fully general operation.
 */ 2 4 this 3 3740  1 v 1 3659  
1479 0 0 4 1399 3615 0 0 52 /**
 * 3-component vector or point times matrix.
 */ 2 4 this 3 3740  1 v 1 3658  
1480 0 0 4 1400 3615 0 0 139 /**
 * The matrix transforms a 2-component point (including translation
 * component).  This assumes the matrix is an affine transform.
 */ 2 4 this 3 3740  1 v 1 3631  
1481 0 0 4 1401 3615 0 0 137 /**
 * The matrix transforms a 2-component vector (without translation component).
 * This assumes the matrix is an affine transform.
 */ 2 4 this 3 3740  1 v 1 3631  
1482 0 0 4 1401 3615 0 0 171 /**
 * The matrix transforms a 3-component vector.  This assumes the matrix is an
 * orthonormal transform.
 *
 * In practice, this is the same computation as xform().
 */ 2 4 this 3 3740  1 v 1 3658  
1483 0 0 4 1402 3615 0 0 119 /**
 * The matrix transforms a 3-component vector (without translation component),
 * as a fully general operation.
 */ 2 4 this 3 3740  1 v 1 3658  
1484 0 0 4 1403 3615 0 0 25 // this = other1 * other2 3 4 this 3 3739  6 other1 1 3740  6 other2 1 3740  
1485 0 0 7 1404 3739 3229 0 0 2 4 this 3 3740  5 other 1 3740  
1486 0 0 7 1404 3739 3229 0 0 2 4 this 3 3740  6 scalar 1 3468  
1487 0 0 7 1405 3739 3229 0 0 2 4 this 3 3740  6 scalar 1 3468  
1488 0 0 6 1406 3739 0 0 63 /**
 * Performs a memberwise addition between two matrices.
 */ 2 4 this 3 3739  5 other 1 3740  
1489 0 0 6 1407 3739 0 0 66 /**
 * Performs a memberwise subtraction between two matrices.
 */ 2 4 this 3 3739  5 other 1 3740  
1490 0 0 6 1408 3739 0 0 10 /**
 *
 */ 2 4 this 3 3739  5 other 1 3740  
1491 0 0 6 1408 3739 0 0 39 /**
 * Performs a memberwise scale.
 */ 2 4 this 3 3739  6 scalar 1 3468  
1492 0 0 6 1409 3739 0 0 39 /**
 * Performs a memberwise scale.
 */ 2 4 this 3 3739  6 scalar 1 3468  
1493 0 0 4 1410 3615 0 0 10 /**
 *
 */ 2 4 this 3 3739  5 other 1 3740  
1494 0 0 6 1411 3468 0 0 49 /**
 * Returns the determinant of the matrix.
 */ 1 4 this 3 3740  
1495 0 0 4 1412 3615 0 0 10 /**
 *
 */ 2 4 this 3 3739  5 other 1 3740  
1496 0 0 4 1413 3615 0 0 10 /**
 *
 */ 1 4 this 3 3739  
1497 0 0 6 1414 3620 0 0 463 /**
 * Computes the inverse of the other matrix, and stores the result in this
 * matrix.  This is a fully general operation and makes no assumptions about
 * the type of transform represented by the matrix.
 *
 * The other matrix must be a different object than this matrix.  However, if
 * you need to invert a matrix in place, see invert_in_place.
 *
 * The return value is true if the matrix was successfully inverted, false if
 * there was a singularity.
 */ 2 4 this 3 3739  5 other 1 3740  
1498 0 0 6 1415 3620 0 0 119 /**
 * Inverts the current matrix.  Returns true if the inverse is successful,
 * false if the matrix was singular.
 */ 1 4 this 3 3739  
1499 0 0 6 1416 3620 0 0 114 /**
 * Simultaneously computes the inverse of the indicated matrix, and then the
 * transpose of that inverse.
 */ 2 4 this 3 3739  5 other 1 3740  
1500 0 0 6 1416 3620 0 0 114 /**
 * Simultaneously computes the inverse of the indicated matrix, and then the
 * transpose of that inverse.
 */ 2 4 this 3 3739  5 other 1 3744  
1501 0 0 6 1417 3740 0 0 147 /**
 * Returns an identity matrix.
 *
 * This function definition must appear first, since some inline functions
 * below take advantage of it.
 */ 0 
1502 0 0 4 1418 3615 0 0 74 /**
 * Fills mat with a matrix that applies the indicated translation.
 */ 2 4 this 3 3739  5 trans 1 3632  
1503 0 0 4 1419 3615 0 0 98 /**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise.
 */ 2 4 this 3 3739  5 angle 1 3468  
1504 0 0 4 1419 3615 0 0 125 /**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */ 4 4 this 3 3739  5 angle 1 3468  4 axis 1 3659  2 cs 1 3484  
1505 0 0 4 1420 3615 0 0 95 /**
 * Fills mat with a matrix that applies the indicated scale in each of the two
 * axes.
 */ 2 4 this 3 3739  5 scale 1 3632  
1506 0 0 4 1420 3615 0 0 97 /**
 * Fills mat with a matrix that applies the indicated scale in each of the
 * three axes.
 */ 2 4 this 3 3739  5 scale 1 3659  
1507 0 0 7 1421 3739 3229 0 67 /**
 * Returns a matrix that applies the indicated translation.
 */ 1 5 trans 1 3632  
1508 0 0 7 1421 3739 3229 0 67 /**
 * Returns a matrix that applies the indicated translation.
 */ 2 2 tx 1 3468  2 ty 1 3468  
1509 0 0 7 1422 3739 3229 0 91 /**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise.
 */ 1 5 angle 1 3468  
1510 0 0 7 1422 3739 3229 0 118 /**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */ 3 5 angle 1 3468  4 axis 1 3659  2 cs 1 3484  
1511 0 0 7 1423 3739 3229 0 85 /**
 * Returns a matrix that applies the indicated scale in each of the two axes.
 */ 1 5 scale 1 3632  
1512 0 0 7 1423 3739 3229 0 90 /**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */ 1 5 scale 1 3659  
1513 0 0 7 1423 3739 3229 0 85 /**
 * Returns a matrix that applies the indicated scale in each of the two axes.
 */ 2 2 sx 1 3468  2 sy 1 3468  
1514 0 0 7 1423 3739 3229 0 90 /**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */ 3 2 sx 1 3468  2 sy 1 3468  2 sz 1 3468  
1515 0 0 4 1424 3615 0 0 163 /**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * normalized.
 */ 4 4 this 3 3739  5 angle 1 3468  4 axis 1 3659  2 cs 1 3484  
1516 0 0 7 1425 3739 3229 0 156 /**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * normalized.
 */ 3 5 angle 1 3468  4 axis 1 3659  2 cs 1 3484  
1517 0 0 4 1426 3615 0 0 99 /**
 * Fills mat with a matrix that applies the indicated shear in each of the
 * three planes.
 */ 3 4 this 3 3739  5 shear 1 3659  2 cs 1 3484  
1518 0 0 7 1427 3739 3229 0 92 /**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */ 2 5 shear 1 3659  2 cs 1 3484  
1519 0 0 7 1427 3739 3229 0 92 /**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */ 4 4 shxy 1 3468  4 shxz 1 3468  4 shyz 1 3468  2 cs 1 3484  
1520 0 0 4 1428 3615 0 0 78 /**
 * Fills mat with a matrix that applies the indicated scale and shear.
 */ 4 4 this 3 3739  5 scale 1 3659  5 shear 1 3659  2 cs 1 3484  
1521 0 0 7 1429 3739 3229 0 71 /**
 * Returns a matrix that applies the indicated scale and shear.
 */ 3 5 scale 1 3659  5 shear 1 3659  2 cs 1 3484  
1522 0 0 7 1429 3739 3229 0 71 /**
 * Returns a matrix that applies the indicated scale and shear.
 */ 7 2 sx 1 3468  2 sy 1 3468  2 sz 1 3468  4 shxy 1 3468  4 shxz 1 3468  4 shyz 1 3468  2 cs 1 3484  
1523 0 0 6 1430 3740 0 0 119 /**
 * Returns a matrix that transforms from the indicated coordinate system to
 * the indicated coordinate system.
 */ 2 4 from 1 3484  2 to 1 3484  
1524 0 0 6 1431 3620 0 0 117 /**
 * Returns true if two matrices are memberwise equal within a default
 * tolerance based on the numeric type.
 */ 2 4 this 3 3740  5 other 1 3740  
1525 0 0 6 1431 3620 0 0 93 /**
 * Returns true if two matrices are memberwise equal within a specified
 * tolerance.
 */ 3 4 this 3 3740  5 other 1 3740  9 threshold 1 3468  
1526 0 0 4 1432 3615 0 0 10 /**
 *
 */ 2 4 this 3 3740  3 out 1 3623  
1527 0 0 4 1433 3615 0 0 10 /**
 *
 */ 3 4 this 3 3740  3 out 1 3623  12 indent_level 1 3471  
1528 0 0 6 1434 3619 0 0 0 1 4 this 3 3740  
1529 0 0 4 1435 3615 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 2 4 this 3 3740  7 hashgen 1 3621  
1530 0 0 4 1435 3615 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 3 4 this 3 3740  7 hashgen 1 3621  9 threshold 1 3468  
1531 0 0 4 1436 3615 0 0 332 /**
 * Writes the matrix to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the matrix, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */ 2 4 this 3 3740  11 destination 1 3625  
1532 0 0 4 1437 3615 0 0 114 /**
 * Reads the matrix from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */ 2 4 this 3 3739  4 scan 1 3627  
1533 0 0 4 1438 3615 0 0 205 /**
 * Writes the matrix to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the matrix using the standard width
 * setting, especially when you are writing a bam file.
 */ 2 4 this 3 3740  11 destination 1 3625  
1534 0 0 4 1439 3615 0 0 67 /**
 * Reads the matrix from the Datagram using get_stdfloat().
 */ 2 4 this 3 3739  6 source 1 3627  
1535 0 0 7 1440 3630 0 0 0 0 
1536 0 0 7 1353 3742 3149 0 0 1 6 param0 0 3746  
1537 0 0 4 1351 3615 0 0 10 /**
 *
 */ 3 4 this 3 3742  1 i 1 3471  10 assign_val 1 3468  
1538 0 0 6 1351 3468 0 0 0 2 4 this 3 3746  1 i 1 3471  
1539 0 0 6 1352 3471 0 0 58 /**
 * Returns 3: the number of columns of a LMatrix3.
 */ 0 
1540 0 0 7 1358 3743 3153 0 0 1 6 param0 0 3748  
1541 0 0 6 1356 3468 0 0 0 2 4 this 3 3748  1 i 1 3471  
1542 0 0 6 1357 3471 0 0 58 /**
 * Returns 3: the number of columns of a LMatrix3.
 */ 0 
1543 0 0 7 1454 3750 3323 0 10 /**
 *
 */ 0 
1544 0 0 7 1454 3750 3323 0 95 // Construct a 4x4 matrix given a 3x3 rotation matrix and an optional
// translation component. 1 6 upper3 1 3740  
1545 0 0 7 1454 3750 3323 0 10 /**
 *
 */ 2 6 upper3 1 3740  5 trans 1 3659  
1546 0 0 7 1454 3750 3323 0 10 /**
 *
 */ 1 5 other 1 3744  
1547 0 0 7 1454 3750 3323 0 10 /**
 *
 */ 1 5 other 1 3751  
1548 0 0 7 1454 3750 3323 0 10 /**
 *
 */ 16 3 e00 1 3468  3 e01 1 3468  3 e02 1 3468  3 e03 1 3468  3 e10 1 3468  3 e11 1 3468  3 e12 1 3468  3 e13 1 3468  3 e20 1 3468  3 e21 1 3468  3 e22 1 3468  3 e23 1 3468  3 e30 1 3468  3 e31 1 3468  3 e32 1 3468  3 e33 1 3468  
1549 0 0 6 1455 3750 0 0 10 /**
 *
 */ 2 4 this 3 3750  5 other 1 3744  
1550 0 0 6 1455 3750 0 0 10 /**
 *
 */ 2 4 this 3 3750  5 other 1 3751  
1551 0 0 6 1455 3750 0 0 10 /**
 *
 */ 2 4 this 3 3750  10 fill_value 1 3468  
1552 0 0 4 1456 3615 0 0 0 2 4 this 3 3750  4 size 1 3613  
1553 0 0 6 1459 3616 0 0 0 1 4 this 3 3744  
1554 0 0 4 1460 3615 0 0 157 /**
 * Sets each element of the matrix to the indicated fill_value.  This is of
 * questionable value, but is sometimes useful when initializing to zero.
 */ 2 4 this 3 3750  10 fill_value 1 3468  
1555 0 0 4 1461 3615 0 0 10 /**
 *
 */ 17 4 this 3 3750  3 e00 1 3468  3 e01 1 3468  3 e02 1 3468  3 e03 1 3468  3 e10 1 3468  3 e11 1 3468  3 e12 1 3468  3 e13 1 3468  3 e20 1 3468  3 e21 1 3468  3 e22 1 3468  3 e23 1 3468  3 e30 1 3468  3 e31 1 3468  3 e32 1 3468  3 e33 1 3468  
1556 0 0 4 1462 3615 0 0 45 // Get and set the upper 3x3 rotation matrix. 2 4 this 3 3750  6 upper3 1 3740  
1557 0 0 7 1463 3739 3229 0 45 /**
 * Retrieves the upper 3x3 submatrix.
 */ 1 4 this 3 3744  
1558 0 0 7 1464 3753 3233 0 0 2 4 this 3 3750  1 i 1 3471  
1559 0 0 7 1464 3754 3237 0 0 2 4 this 3 3744  1 i 1 3471  
1560 0 0 6 1465 3471 0 0 55 /**
 * Returns 4: the number of rows of a LMatrix4.
 */ 0 
1561 0 0 4 1466 3615 0 0 119 /**
 * Replaces the indicated row of the matrix with the indicated 3-component
 * vector, ignoring the last column.
 */ 3 4 this 3 3750  3 row 1 3471  1 v 1 3659  
1562 0 0 4 1466 3615 0 0 52 /**
 * Replaces the indicated row of the matrix.
 */ 3 4 this 3 3750  3 row 1 3471  1 v 1 3689  
1563 0 0 4 1467 3615 0 0 119 /**
 * Replaces the indicated column of the matrix with the indicated 3-component
 * vector, ignoring the last row.
 */ 3 4 this 3 3750  3 col 1 3471  1 v 1 3659  
1564 0 0 4 1467 3615 0 0 55 /**
 * Replaces the indicated column of the matrix.
 */ 3 4 this 3 3750  3 col 1 3471  1 v 1 3689  
1565 0 0 4 1468 3615 0 0 74 /**
 * Stores the indicated row of the matrix as a 4-component vector.
 */ 3 4 this 3 3744  10 result_vec 1 3688  3 row 1 3471  
1566 0 0 7 1468 3688 2755 0 77 /**
 * Retrieves the indicated row of the matrix as a 4-component vector.
 */ 2 4 this 3 3744  3 row 1 3471  
1567 0 0 7 1469 3688 2755 0 80 /**
 * Retrieves the indicated column of the matrix as a 4-component vector.
 */ 2 4 this 3 3744  3 col 1 3471  
1568 0 0 4 1470 3615 0 0 100 /**
 * Stores the row column of the matrix as a 3-component vector, ignoring the
 * last column.
 */ 3 4 this 3 3744  10 result_vec 1 3658  3 row 1 3471  
1569 0 0 7 1470 3658 2366 0 103 /**
 * Retrieves the row column of the matrix as a 3-component vector, ignoring
 * the last column.
 */ 2 4 this 3 3744  3 row 1 3471  
1570 0 0 7 1476 3658 2366 0 106 /**
 * Retrieves the indicated column of the matrix as a 3-component vector,
 * ignoring the last row.
 */ 2 4 this 3 3744  3 col 1 3471  
1571 0 0 4 1477 3615 0 0 10 /**
 *
 */ 3 4 this 3 3750  3 row 1 3471  3 col 1 3471  
1572 0 0 6 1477 3468 0 0 0 3 4 this 3 3744  3 row 1 3471  3 col 1 3471  
1573 0 0 6 1478 3620 0 0 91 /**
 * Returns true if any component of the matrix is not-a-number, false
 * otherwise.
 */ 1 4 this 3 3744  
1574 0 0 6 1479 3620 0 0 93 /**
 * Returns true if this is (close enough to) the identity matrix, false
 * otherwise.
 */ 1 4 this 3 3744  
1575 0 0 6 1480 3468 0 0 54 /**
 * Returns a particular element of the matrix.
 */ 3 4 this 3 3744  3 row 1 3471  3 col 1 3471  
1576 0 0 4 1481 3615 0 0 54 /**
 * Changes a particular element of the matrix.
 */ 4 4 this 3 3750  3 row 1 3471  3 col 1 3471  5 value 1 3468  
1577 0 0 4 1482 3615 0 0 162 /**
 * Returns the address of the first of the nine data elements in the matrix.
 * The remaining elements occupy the next eight positions in row-major order.
 */ 1 4 this 3 3744  
1578 0 0 6 1483 3471 0 0 60 /**
 * Returns the number of elements in the matrix, 16.
 */ 1 4 this 3 3744  
1579 0 0 4 1484 3615 0 0 101 /**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */ 1 4 this 3 3750  
1580 0 0 4 1484 3615 0 0 101 /**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */ 1 4 this 3 3744  
1581 0 0 4 1485 3615 0 0 101 /**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */ 1 4 this 3 3750  
1582 0 0 4 1485 3615 0 0 101 /**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */ 1 4 this 3 3744  
1583 0 0 6 1486 3620 0 0 0 2 4 this 3 3744  5 other 1 3744  
1584 0 0 6 1487 3620 0 0 0 2 4 this 3 3744  5 other 1 3744  
1585 0 0 6 1488 3620 0 0 0 2 4 this 3 3744  5 other 1 3744  
1586 0 0 6 1489 3471 0 0 97 /**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */ 2 4 this 3 3744  5 other 1 3744  
1587 0 0 6 1489 3471 0 0 234 /**
 * Sorts matrices lexicographically, componentwise.  Returns a number less
 * than 0 if this matrix sorts before the other one, greater than zero if it
 * sorts after, 0 if they are equivalent (within the indicated tolerance).
 */ 3 4 this 3 3744  5 other 1 3744  9 threshold 1 3468  
1588 0 0 6 1490 3613 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 1 4 this 3 3744  
1589 0 0 6 1490 3613 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 2 4 this 3 3744  9 threshold 1 3468  
1590 0 0 6 1491 3613 0 0 49 /**
 * Adds the vector into the running hash.
 */ 2 4 this 3 3744  4 hash 1 3613  
1591 0 0 6 1491 3613 0 0 49 /**
 * Adds the vector into the running hash.
 */ 3 4 this 3 3744  4 hash 1 3613  9 threshold 1 3468  
1592 0 0 7 1492 3688 2755 0 91 /**
 * 4-component vector or point times matrix.  This is a fully general
 * operation.
 */ 2 4 this 3 3744  1 v 1 3689  
1593 0 0 7 1493 3658 2366 0 162 /**
 * The matrix transforms a 3-component point (including translation component)
 * and returns the result.  This assumes the matrix is an affine transform.
 */ 2 4 this 3 3744  1 v 1 3659  
1594 0 0 7 1494 3658 2366 0 143 /**
 * The matrix transforms a 3-component point (including translation component)
 * and returns the result, as a fully general operation.
 */ 2 4 this 3 3744  1 v 1 3659  
1595 0 0 7 1495 3658 2366 0 169 /**
 * The matrix transforms a 3-component vector (without translation component)
 * and returns the result.  This assumes the matrix is an orthonormal
 * transform.
 */ 2 4 this 3 3744  1 v 1 3659  
1596 0 0 7 1496 3658 2366 0 142 /**
 * The matrix transforms a 3-component vector (without translation component)
 * and returns the result, as a fully general operation.
 */ 2 4 this 3 3744  1 v 1 3659  
1597 0 0 4 1497 3615 0 0 91 /**
 * 4-component vector or point times matrix.  This is a fully general
 * operation.
 */ 2 4 this 3 3744  1 v 1 3688  
1598 0 0 4 1498 3615 0 0 139 /**
 * The matrix transforms a 3-component point (including translation
 * component).  This assumes the matrix is an affine transform.
 */ 2 4 this 3 3744  1 v 1 3658  
1599 0 0 4 1499 3615 0 0 120 /**
 * The matrix transforms a 3-component point (including translation
 * component), as a fully general operation.
 */ 2 4 this 3 3744  1 v 1 3658  
1600 0 0 4 1500 3615 0 0 142 /**
 * The matrix transforms a 3-component vector (without translation component).
 * This assumes the matrix is an orthonormal transform.
 */ 2 4 this 3 3744  1 v 1 3658  
1601 0 0 4 1501 3615 0 0 119 /**
 * The matrix transforms a 3-component vector (without translation component),
 * as a fully general operation.
 */ 2 4 this 3 3744  1 v 1 3658  
1602 0 0 4 1502 3615 0 0 25 // this = other1 * other2 3 4 this 3 3750  6 other1 1 3744  6 other2 1 3744  
1603 0 0 7 1503 3750 3323 0 0 2 4 this 3 3744  5 other 1 3744  
1604 0 0 7 1503 3750 3323 0 0 2 4 this 3 3744  6 scalar 1 3468  
1605 0 0 7 1504 3750 3323 0 0 2 4 this 3 3744  6 scalar 1 3468  
1606 0 0 6 1505 3750 0 0 63 /**
 * Performs a memberwise addition between two matrices.
 */ 2 4 this 3 3750  5 other 1 3744  
1607 0 0 6 1506 3750 0 0 63 /**
 * Performs a memberwise addition between two matrices.
 */ 2 4 this 3 3750  5 other 1 3744  
1608 0 0 6 1507 3750 0 0 10 /**
 *
 */ 2 4 this 3 3750  5 other 1 3744  
1609 0 0 6 1507 3750 0 0 10 /**
 *
 */ 2 4 this 3 3750  6 scalar 1 3468  
1610 0 0 6 1508 3750 0 0 10 /**
 *
 */ 2 4 this 3 3750  6 scalar 1 3468  
1611 0 0 4 1509 3615 0 0 10 /**
 *
 */ 2 4 this 3 3750  5 other 1 3744  
1612 0 0 4 1510 3615 0 0 10 /**
 *
 */ 2 4 this 3 3750  5 other 1 3744  
1613 0 0 4 1511 3615 0 0 10 /**
 *
 */ 1 4 this 3 3750  
1614 0 0 6 1512 3620 0 0 461 /**
 * Computes the inverse of the other matrix, and stores the result in this
 * matrix.  This is a fully general operation and makes no assumptions about
 * the type of transform represented by the matrix.
 *
 * The other matrix must be a different object than this matrix.  However, if
 * you need to invert a matrix in place, see invert_in_place.
 *
 * The return value is true if the matrix was successfully inverted, false if
 * the was a singularity.
 */ 2 4 this 3 3750  5 other 1 3744  
1615 0 0 6 1513 3620 0 0 139 // bugbug: we could optimize this for rotationscaletranslation matrices
// (transpose upper 3x3 and take negative of translation component) 2 4 this 3 3750  5 other 1 3744  
1616 0 0 6 1514 3620 0 0 119 /**
 * Inverts the current matrix.  Returns true if the inverse is successful,
 * false if the matrix was singular.
 */ 1 4 this 3 3750  
1617 0 0 4 1515 3615 0 0 46 /**
 * Computes (*this) += other * weight.
 */ 3 4 this 3 3750  5 other 1 3744  6 weight 1 3468  
1618 0 0 6 1516 3744 0 0 147 /**
 * Returns an identity matrix.
 *
 * This function definition must appear first, since some inline functions
 * below take advantage of it.
 */ 0 
1619 0 0 6 1517 3744 0 0 46 /**
 * Returns an matrix filled with ones.
 */ 0 
1620 0 0 6 1518 3744 0 0 47 /**
 * Returns an matrix filled with zeros.
 */ 0 
1621 0 0 4 1519 3615 0 0 74 /**
 * Fills mat with a matrix that applies the indicated translation.
 */ 2 4 this 3 3750  5 trans 1 3659  
1622 0 0 4 1520 3615 0 0 122 /**
 * Sets mat to a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */ 4 4 this 3 3750  5 angle 1 3468  4 axis 1 3659  2 cs 1 3484  
1623 0 0 4 1521 3615 0 0 166 /**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * prenormalized.
 */ 4 4 this 3 3750  5 angle 1 3468  4 axis 1 3659  2 cs 1 3484  
1624 0 0 4 1522 3615 0 0 97 /**
 * Fills mat with a matrix that applies the indicated scale in each of the
 * three axes.
 */ 2 4 this 3 3750  5 scale 1 3659  
1625 0 0 4 1523 3615 0 0 99 /**
 * Fills mat with a matrix that applies the indicated shear in each of the
 * three planes.
 */ 3 4 this 3 3750  5 shear 1 3659  2 cs 1 3484  
1626 0 0 4 1524 3615 0 0 78 /**
 * Fills mat with a matrix that applies the indicated scale and shear.
 */ 4 4 this 3 3750  5 scale 1 3659  5 shear 1 3659  2 cs 1 3484  
1627 0 0 7 1525 3750 3323 0 67 /**
 * Returns a matrix that applies the indicated translation.
 */ 1 5 trans 1 3659  
1628 0 0 7 1525 3750 3323 0 67 /**
 * Returns a matrix that applies the indicated translation.
 */ 3 2 tx 1 3468  2 ty 1 3468  2 tz 1 3468  
1629 0 0 7 1526 3750 3323 0 118 /**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */ 3 5 angle 1 3468  4 axis 1 3659  2 cs 1 3484  
1630 0 0 7 1527 3750 3323 0 159 /**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * prenormalized.
 */ 3 5 angle 1 3468  4 axis 1 3659  2 cs 1 3484  
1631 0 0 7 1528 3750 3323 0 90 /**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */ 1 5 scale 1 3659  
1632 0 0 7 1528 3750 3323 0 69 /**
 * Returns a matrix that applies the indicated uniform scale.
 */ 1 5 scale 1 3468  
1633 0 0 7 1528 3750 3323 0 90 /**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */ 3 2 sx 1 3468  2 sy 1 3468  2 sz 1 3468  
1634 0 0 7 1529 3750 3323 0 92 /**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */ 2 5 shear 1 3659  2 cs 1 3484  
1635 0 0 7 1529 3750 3323 0 92 /**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */ 4 4 shxy 1 3468  4 shxz 1 3468  4 shyz 1 3468  2 cs 1 3484  
1636 0 0 7 1530 3750 3323 0 71 /**
 * Returns a matrix that applies the indicated scale and shear.
 */ 3 5 scale 1 3659  5 shear 1 3659  2 cs 1 3484  
1637 0 0 7 1530 3750 3323 0 71 /**
 * Returns a matrix that applies the indicated scale and shear.
 */ 7 2 sx 1 3468  2 sy 1 3468  2 sz 1 3468  4 shxy 1 3468  4 shxz 1 3468  4 shyz 1 3468  2 cs 1 3484  
1638 0 0 6 1531 3744 0 0 109 /**
 * Returns a matrix that transforms from the Y-up coordinate system to the
 * Z-up coordinate system.
 */ 0 
1639 0 0 6 1532 3744 0 0 109 /**
 * Returns a matrix that transforms from the Y-up coordinate system to the
 * Z-up coordinate system.
 */ 0 
1640 0 0 6 1533 3744 0 0 119 /**
 * Returns a matrix that transforms from the indicated coordinate system to
 * the indicated coordinate system.
 */ 2 4 from 1 3484  2 to 1 3484  
1641 0 0 6 1534 3620 0 0 117 /**
 * Returns true if two matrices are memberwise equal within a default
 * tolerance based on the numeric type.
 */ 2 4 this 3 3744  5 other 1 3744  
1642 0 0 6 1534 3620 0 0 199 /**
 * Returns true if two matrices are memberwise equal within a specified
 * tolerance.  This is faster than the equivalence operator as this doesn't
 * have to guarantee that it is transitive.
 */ 3 4 this 3 3744  5 other 1 3744  9 threshold 1 3468  
1643 0 0 4 1535 3615 0 0 10 /**
 *
 */ 2 4 this 3 3744  3 out 1 3623  
1644 0 0 4 1536 3615 0 0 10 /**
 *
 */ 3 4 this 3 3744  3 out 1 3623  12 indent_level 1 3471  
1645 0 0 6 1537 3619 0 0 0 1 4 this 3 3744  
1646 0 0 4 1538 3615 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 2 4 this 3 3744  7 hashgen 1 3621  
1647 0 0 4 1538 3615 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 3 4 this 3 3744  7 hashgen 1 3621  5 scale 1 3468  
1648 0 0 4 1539 3615 0 0 332 /**
 * Writes the matrix to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the matrix, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */ 2 4 this 3 3744  11 destination 1 3625  
1649 0 0 4 1540 3615 0 0 114 /**
 * Reads the matrix from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */ 2 4 this 3 3750  4 scan 1 3627  
1650 0 0 4 1541 3615 0 0 205 /**
 * Writes the matrix to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the matrix using the standard width
 * setting, especially when you are writing a bam file.
 */ 2 4 this 3 3744  11 destination 1 3625  
1651 0 0 4 1542 3615 0 0 67 /**
 * Reads the matrix from the Datagram using get_stdfloat().
 */ 2 4 this 3 3750  6 source 1 3627  
1652 0 0 7 1543 3630 0 0 0 0 
1653 0 0 7 1447 3753 3233 0 0 1 6 param0 0 3755  
1654 0 0 4 1445 3615 0 0 10 /**
 *
 */ 3 4 this 3 3753  1 i 1 3471  10 assign_val 1 3468  
1655 0 0 6 1445 3468 0 0 0 2 4 this 3 3755  1 i 1 3471  
1656 0 0 6 1446 3471 0 0 58 /**
 * Returns 4: the number of columns of a LMatrix4.
 */ 0 
1657 0 0 7 1452 3754 3237 0 0 1 6 param0 0 3757  
1658 0 0 6 1450 3468 0 0 0 2 4 this 3 3757  1 i 1 3471  
1659 0 0 6 1451 3471 0 0 58 /**
 * Returns 4: the number of columns of a LMatrix4.
 */ 0 
1660 0 0 7 1547 3759 3331 0 10 /**
 *
 */ 0 
1661 0 0 7 1547 3759 3331 0 10 /**
 *
 */ 1 4 copy 1 3744  
1662 0 0 7 1547 3759 3331 0 10 /**
 *
 */ 1 4 copy 1 3751  
1663 0 0 7 1547 3759 3331 0 10 /**
 *
 */ 16 3 e00 1 3468  3 e01 1 3468  3 e02 1 3468  3 e03 1 3468  3 e10 1 3468  3 e11 1 3468  3 e12 1 3468  3 e13 1 3468  3 e20 1 3468  3 e21 1 3468  3 e22 1 3468  3 e23 1 3468  3 e30 1 3468  3 e31 1 3468  3 e32 1 3468  3 e33 1 3468  
1664 0 0 6 1548 3759 0 0 10 /**
 *
 */ 2 4 this 3 3759  4 copy 1 3744  
1665 0 0 6 1548 3759 0 0 10 /**
 *
 */ 2 4 this 3 3759  4 copy 1 3751  
1666 0 0 4 1549 3615 0 0 10 /**
 *
 */ 17 4 this 3 3759  3 e00 1 3468  3 e01 1 3468  3 e02 1 3468  3 e03 1 3468  3 e10 1 3468  3 e11 1 3468  3 e12 1 3468  3 e13 1 3468  3 e20 1 3468  3 e21 1 3468  3 e22 1 3468  3 e23 1 3468  3 e30 1 3468  3 e31 1 3468  3 e32 1 3468  3 e33 1 3468  
1667 0 0 4 1550 3615 0 0 10 /**
 *
 */ 3 4 this 3 3759  3 row 1 3471  3 col 1 3471  
1668 0 0 6 1550 3468 0 0 0 3 4 this 3 3751  3 row 1 3471  3 col 1 3471  
1669 0 0 4 1551 3615 0 0 162 /**
 * Returns the address of the first of the nine data elements in the matrix.
 * The remaining elements occupy the next eight positions in row-major order.
 */ 1 4 this 3 3751  
1670 0 0 6 1552 3471 0 0 65 /**
 * Returns the number of elements in the matrix, sixteen.
 */ 1 4 this 3 3751  
1671 0 0 7 1553 3630 0 0 0 0 
1672 0 0 7 1564 3760 3387 0 10 /**
 *
 */ 0 
1673 0 0 7 1564 3760 3387 0 0 1 6 param0 0 3761  
1674 0 0 7 1564 3760 3387 0 10 /**
 *
 */ 1 4 copy 1 3683  
1675 0 0 7 1564 3760 3387 0 10 /**
 *
 */ 2 1 r 1 3465  4 copy 1 3656  
1676 0 0 7 1564 3760 3387 0 10 /**
 *
 */ 4 1 r 1 3465  1 i 1 3465  1 j 1 3465  1 k 1 3465  
1677 0 0 7 1565 3760 3387 0 10 /**
 *
 */ 1 1 v 1 3665  
1678 0 0 7 1566 3760 3387 0 54 /**
 * Returns the complex conjugate of this quat.
 */ 1 4 this 3 3761  
1679 0 0 7 1567 3655 2293 0 60 /**
 * Transforms a 3-d vector by the indicated rotation
 */ 2 4 this 3 3761  1 v 1 3656  
1680 0 0 7 1567 3682 2673 0 60 /**
 * Transforms a 4-d vector by the indicated rotation
 */ 2 4 this 3 3761  1 v 1 3683  
1681 0 0 7 1568 3760 3387 0 45 /**
 * actual multiply call (non virtual)
 */ 2 4 this 3 3761  3 rhs 1 3761  
1682 0 0 7 1569 3760 3387 0 0 1 4 this 3 3761  
1683 0 0 7 1570 3760 3387 0 0 2 4 this 3 3761  5 other 1 3761  
1684 0 0 7 1571 3760 3387 0 0 2 4 this 3 3761  5 other 1 3761  
1685 0 0 6 1572 3465 0 0 127 /**
 * Returns the angle between the orientation represented by this quaternion
 * and the other one, expressed in radians.
 */ 2 4 this 3 3761  5 other 1 3761  
1686 0 0 6 1573 3465 0 0 127 /**
 * Returns the angle between the orientation represented by this quaternion
 * and the other one, expressed in degrees.
 */ 2 4 this 3 3761  5 other 1 3761  
1687 0 0 7 1574 3718 3041 0 0 2 4 this 3 3760  6 param0 0 3719  
1688 0 0 7 1574 3729 3137 0 0 2 4 this 3 3760  6 param0 0 3723  
1689 0 0 7 1574 3760 3387 0 0 2 4 this 3 3761  6 param0 0 3761  
1690 0 0 7 1574 3760 3387 0 0 2 4 this 3 3761  6 scalar 1 3465  
1691 0 0 7 1575 3760 3387 0 0 2 4 this 3 3761  6 scalar 1 3465  
1692 0 0 6 1576 3760 0 0 10 /**
 *
 */ 2 4 this 3 3760  6 param0 0 3761  
1693 0 0 6 1577 3620 0 0 120 /**
 * Returns true if two quaternions are memberwise equal within a default
 * tolerance based on the numeric type.
 */ 2 4 this 3 3761  5 other 1 3761  
1694 0 0 6 1577 3620 0 0 96 /**
 * Returns true if two quaternions are memberwise equal within a specified
 * tolerance.
 */ 3 4 this 3 3761  5 other 1 3761  9 threshold 1 3465  
1695 0 0 6 1578 3620 0 0 127 /**
 * Returns true if two quaternions represent the same rotation within a
 * default tolerance based on the numeric type.
 */ 2 4 this 3 3761  5 other 1 3761  
1696 0 0 6 1579 3620 0 0 103 /**
 * Returns true if two quaternions represent the same rotation within a
 * specified tolerance.
 */ 3 4 this 3 3761  5 other 1 3761  9 threshold 1 3465  
1697 0 0 4 1580 3615 0 0 10 /**
 *
 */ 2 4 this 3 3761  6 param0 0 3623  
1698 0 0 4 1581 3615 0 0 43 /**
 * Based on the quat lib from VRPN.
 */ 2 4 this 3 3761  1 m 1 3718  
1699 0 0 4 1581 3615 0 0 43 /**
 * Based on the quat lib from VRPN.
 */ 2 4 this 3 3761  1 m 1 3729  
1700 0 0 4 1582 3615 0 0 226 /**
 * Sets the quaternion according to the rotation represented by the matrix.
 * Originally we tried an algorithm presented by Do-While Jones, but that
 * turned out to be broken.  This is based on the quat lib from UNC.
 */ 2 4 this 3 3760  1 m 1 3719  
1701 0 0 4 1582 3615 0 0 10 /**
 *
 */ 2 4 this 3 3760  1 m 1 3723  
1702 0 0 4 1583 3615 0 0 132 /**
 * Sets the quaternion as the unit quaternion that is equivalent to these
 * Euler angles.  (from Real-time Rendering, p.49)
 */ 3 4 this 3 3760  3 hpr 1 3656  2 cs 1 3484  
1703 0 0 7 1584 3655 2293 0 73 /**
 * Extracts the equivalent Euler angles from the unit quaternion.
 */ 2 4 this 3 3761  2 cs 1 3484  
1704 0 0 7 1585 3664 2472 0 180 /**
 * This, along with get_angle(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the axis; it
 * is not normalized.
 */ 1 4 this 3 3761  
1705 0 0 7 1586 3664 2472 0 169 /**
 * This, along with get_angle(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the
 * normalized axis.
 */ 1 4 this 3 3761  
1706 0 0 6 1587 3465 0 0 343 /**
 * This, along with get_axis(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the angle, in
 * radians counterclockwise about the axis.
 *
 * It is necessary to ensure the quaternion has been normalized (for instance,
 * with a call to normalize()) before calling this method.
 */ 1 4 this 3 3761  
1707 0 0 6 1588 3465 0 0 343 /**
 * This, along with get_axis(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the angle, in
 * degrees counterclockwise about the axis.
 *
 * It is necessary to ensure the quaternion has been normalized (for instance,
 * with a call to normalize()) before calling this method.
 */ 1 4 this 3 3761  
1708 0 0 4 1589 3615 0 0 86 /**
 * angle_rad is the angle about the axis in radians.  axis must be normalized.
 */ 3 4 this 3 3760  9 angle_rad 1 3465  4 axis 1 3665  
1709 0 0 4 1590 3615 0 0 86 /**
 * angle_deg is the angle about the axis in degrees.  axis must be normalized.
 */ 3 4 this 3 3760  9 angle_deg 1 3465  4 axis 1 3665  
1710 0 0 7 1591 3664 2472 0 96 /**
 * Returns the orientation represented by this quaternion, expressed as an up
 * vector.
 */ 2 4 this 3 3761  2 cs 1 3484  
1711 0 0 7 1592 3664 2472 0 98 /**
 * Returns the orientation represented by this quaternion, expressed as a
 * right vector.
 */ 2 4 this 3 3761  2 cs 1 3484  
1712 0 0 7 1593 3664 2472 0 100 /**
 * Returns the orientation represented by this quaternion, expressed as a
 * forward vector.
 */ 2 4 this 3 3761  2 cs 1 3484  
1713 0 0 6 1594 3465 0 0 10 /**
 *
 */ 1 4 this 3 3761  
1714 0 0 6 1595 3465 0 0 10 /**
 *
 */ 1 4 this 3 3761  
1715 0 0 6 1596 3465 0 0 10 /**
 *
 */ 1 4 this 3 3761  
1716 0 0 6 1597 3465 0 0 10 /**
 *
 */ 1 4 this 3 3761  
1717 0 0 4 1598 3615 0 0 10 /**
 *
 */ 2 4 this 3 3760  1 r 1 3465  
1718 0 0 4 1599 3615 0 0 10 /**
 *
 */ 2 4 this 3 3760  1 i 1 3465  
1719 0 0 4 1600 3615 0 0 10 /**
 *
 */ 2 4 this 3 3760  1 j 1 3465  
1720 0 0 4 1601 3615 0 0 10 /**
 *
 */ 2 4 this 3 3760  1 k 1 3465  
1721 0 0 6 1602 3620 0 0 10 /**
 *
 */ 1 4 this 3 3760  
1722 0 0 6 1603 3620 0 0 466 /**
 * Computes the conjugate of the other quat, and stores the result in this
 * quat.  This is a fully general operation and makes no assumptions about the
 * type of transform represented by the quat.
 *
 * The other quat must be a different object than this quat.  However, if you
 * need to get a conjugate of a quat in place, see conjugate_in_place.
 *
 * The return value is true if the quat was successfully inverted, false if
 * there was a singularity.
 */ 2 4 this 3 3760  5 other 1 3761  
1723 0 0 6 1604 3620 0 0 129 /**
 * Sets this to be the conjugate of the current quat.  Returns true if the
 * successful, false if the quat was singular.
 */ 1 4 this 3 3760  
1724 0 0 6 1605 3620 0 0 448 /**
 * Computes the inverse of the other quat, and stores the result in this quat.
 * This is a fully general operation and makes no assumptions about the type
 * of transform represented by the quat.
 *
 * The other quat must be a different object than this quat.  However, if you
 * need to invert a quat in place, see invert_in_place.
 *
 * The return value is true if the quat was successfully inverted, false if
 * there was a singularity.
 */ 2 4 this 3 3760  5 other 1 3761  
1725 0 0 6 1606 3620 0 0 115 /**
 * Inverts the current quat.  Returns true if the inverse is successful, false
 * if the quat was singular.
 */ 1 4 this 3 3760  
1726 0 0 6 1607 3620 0 0 98 /**
 * Returns true if this quaternion represents the identity transformation: no
 * rotation.
 */ 1 4 this 3 3761  
1727 0 0 6 1608 3620 0 0 110 /**
 * Returns true if this quaternion represents the identity transformation
 * within a given tolerance.
 */ 2 4 this 3 3761  9 tolerance 1 3465  
1728 0 0 6 1609 3761 0 0 42 /**
 * Returns an identity quaternion.
 */ 0 
1729 0 0 7 1610 3630 0 0 0 0 
1730 0 0 7 1613 3763 3435 0 10 /**
 *
 */ 0 
1731 0 0 7 1613 3763 3435 0 0 1 6 param0 0 3764  
1732 0 0 7 1613 3763 3435 0 10 /**
 *
 */ 1 4 copy 1 3689  
1733 0 0 7 1613 3763 3435 0 10 /**
 *
 */ 2 1 r 1 3468  4 copy 1 3659  
1734 0 0 7 1613 3763 3435 0 10 /**
 *
 */ 4 1 r 1 3468  1 i 1 3468  1 j 1 3468  1 k 1 3468  
1735 0 0 7 1614 3763 3435 0 10 /**
 *
 */ 1 1 v 1 3668  
1736 0 0 7 1615 3763 3435 0 54 /**
 * Returns the complex conjugate of this quat.
 */ 1 4 this 3 3764  
1737 0 0 7 1616 3658 2366 0 60 /**
 * Transforms a 3-d vector by the indicated rotation
 */ 2 4 this 3 3764  1 v 1 3659  
1738 0 0 7 1616 3688 2755 0 60 /**
 * Transforms a 4-d vector by the indicated rotation
 */ 2 4 this 3 3764  1 v 1 3689  
1739 0 0 7 1617 3763 3435 0 45 /**
 * actual multiply call (non virtual)
 */ 2 4 this 3 3764  3 rhs 1 3764  
1740 0 0 7 1618 3763 3435 0 0 1 4 this 3 3764  
1741 0 0 7 1619 3763 3435 0 0 2 4 this 3 3764  5 other 1 3764  
1742 0 0 7 1620 3763 3435 0 0 2 4 this 3 3764  5 other 1 3764  
1743 0 0 6 1621 3468 0 0 127 /**
 * Returns the angle between the orientation represented by this quaternion
 * and the other one, expressed in radians.
 */ 2 4 this 3 3764  5 other 1 3764  
1744 0 0 6 1622 3468 0 0 127 /**
 * Returns the angle between the orientation represented by this quaternion
 * and the other one, expressed in degrees.
 */ 2 4 this 3 3764  5 other 1 3764  
1745 0 0 7 1623 3739 3229 0 0 2 4 this 3 3763  6 param0 0 3740  
1746 0 0 7 1623 3750 3323 0 0 2 4 this 3 3763  6 param0 0 3744  
1747 0 0 7 1623 3763 3435 0 0 2 4 this 3 3764  6 param0 0 3764  
1748 0 0 7 1623 3763 3435 0 0 2 4 this 3 3764  6 scalar 1 3468  
1749 0 0 7 1624 3763 3435 0 0 2 4 this 3 3764  6 scalar 1 3468  
1750 0 0 6 1625 3763 0 0 10 /**
 *
 */ 2 4 this 3 3763  6 param0 0 3764  
1751 0 0 6 1626 3620 0 0 120 /**
 * Returns true if two quaternions are memberwise equal within a default
 * tolerance based on the numeric type.
 */ 2 4 this 3 3764  5 other 1 3764  
1752 0 0 6 1626 3620 0 0 96 /**
 * Returns true if two quaternions are memberwise equal within a specified
 * tolerance.
 */ 3 4 this 3 3764  5 other 1 3764  9 threshold 1 3468  
1753 0 0 6 1627 3620 0 0 127 /**
 * Returns true if two quaternions represent the same rotation within a
 * default tolerance based on the numeric type.
 */ 2 4 this 3 3764  5 other 1 3764  
1754 0 0 6 1628 3620 0 0 103 /**
 * Returns true if two quaternions represent the same rotation within a
 * specified tolerance.
 */ 3 4 this 3 3764  5 other 1 3764  9 threshold 1 3468  
1755 0 0 4 1629 3615 0 0 10 /**
 *
 */ 2 4 this 3 3764  6 param0 0 3623  
1756 0 0 4 1630 3615 0 0 43 /**
 * Based on the quat lib from VRPN.
 */ 2 4 this 3 3764  1 m 1 3739  
1757 0 0 4 1630 3615 0 0 43 /**
 * Based on the quat lib from VRPN.
 */ 2 4 this 3 3764  1 m 1 3750  
1758 0 0 4 1631 3615 0 0 226 /**
 * Sets the quaternion according to the rotation represented by the matrix.
 * Originally we tried an algorithm presented by Do-While Jones, but that
 * turned out to be broken.  This is based on the quat lib from UNC.
 */ 2 4 this 3 3763  1 m 1 3740  
1759 0 0 4 1631 3615 0 0 10 /**
 *
 */ 2 4 this 3 3763  1 m 1 3744  
1760 0 0 4 1632 3615 0 0 132 /**
 * Sets the quaternion as the unit quaternion that is equivalent to these
 * Euler angles.  (from Real-time Rendering, p.49)
 */ 3 4 this 3 3763  3 hpr 1 3659  2 cs 1 3484  
1761 0 0 7 1633 3658 2366 0 73 /**
 * Extracts the equivalent Euler angles from the unit quaternion.
 */ 2 4 this 3 3764  2 cs 1 3484  
1762 0 0 7 1634 3667 2506 0 180 /**
 * This, along with get_angle(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the axis; it
 * is not normalized.
 */ 1 4 this 3 3764  
1763 0 0 7 1635 3667 2506 0 169 /**
 * This, along with get_angle(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the
 * normalized axis.
 */ 1 4 this 3 3764  
1764 0 0 6 1636 3468 0 0 343 /**
 * This, along with get_axis(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the angle, in
 * radians counterclockwise about the axis.
 *
 * It is necessary to ensure the quaternion has been normalized (for instance,
 * with a call to normalize()) before calling this method.
 */ 1 4 this 3 3764  
1765 0 0 6 1637 3468 0 0 343 /**
 * This, along with get_axis(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the angle, in
 * degrees counterclockwise about the axis.
 *
 * It is necessary to ensure the quaternion has been normalized (for instance,
 * with a call to normalize()) before calling this method.
 */ 1 4 this 3 3764  
1766 0 0 4 1638 3615 0 0 86 /**
 * angle_rad is the angle about the axis in radians.  axis must be normalized.
 */ 3 4 this 3 3763  9 angle_rad 1 3468  4 axis 1 3668  
1767 0 0 4 1639 3615 0 0 86 /**
 * angle_deg is the angle about the axis in degrees.  axis must be normalized.
 */ 3 4 this 3 3763  9 angle_deg 1 3468  4 axis 1 3668  
1768 0 0 7 1640 3667 2506 0 96 /**
 * Returns the orientation represented by this quaternion, expressed as an up
 * vector.
 */ 2 4 this 3 3764  2 cs 1 3484  
1769 0 0 7 1641 3667 2506 0 98 /**
 * Returns the orientation represented by this quaternion, expressed as a
 * right vector.
 */ 2 4 this 3 3764  2 cs 1 3484  
1770 0 0 7 1642 3667 2506 0 100 /**
 * Returns the orientation represented by this quaternion, expressed as a
 * forward vector.
 */ 2 4 this 3 3764  2 cs 1 3484  
1771 0 0 6 1643 3468 0 0 10 /**
 *
 */ 1 4 this 3 3764  
1772 0 0 6 1644 3468 0 0 10 /**
 *
 */ 1 4 this 3 3764  
1773 0 0 6 1645 3468 0 0 10 /**
 *
 */ 1 4 this 3 3764  
1774 0 0 6 1646 3468 0 0 10 /**
 *
 */ 1 4 this 3 3764  
1775 0 0 4 1647 3615 0 0 10 /**
 *
 */ 2 4 this 3 3763  1 r 1 3468  
1776 0 0 4 1648 3615 0 0 10 /**
 *
 */ 2 4 this 3 3763  1 i 1 3468  
1777 0 0 4 1649 3615 0 0 10 /**
 *
 */ 2 4 this 3 3763  1 j 1 3468  
1778 0 0 4 1650 3615 0 0 10 /**
 *
 */ 2 4 this 3 3763  1 k 1 3468  
1779 0 0 6 1651 3620 0 0 10 /**
 *
 */ 1 4 this 3 3763  
1780 0 0 6 1652 3620 0 0 466 /**
 * Computes the conjugate of the other quat, and stores the result in this
 * quat.  This is a fully general operation and makes no assumptions about the
 * type of transform represented by the quat.
 *
 * The other quat must be a different object than this quat.  However, if you
 * need to get a conjugate of a quat in place, see conjugate_in_place.
 *
 * The return value is true if the quat was successfully inverted, false if
 * there was a singularity.
 */ 2 4 this 3 3763  5 other 1 3764  
1781 0 0 6 1653 3620 0 0 129 /**
 * Sets this to be the conjugate of the current quat.  Returns true if the
 * successful, false if the quat was singular.
 */ 1 4 this 3 3763  
1782 0 0 6 1654 3620 0 0 448 /**
 * Computes the inverse of the other quat, and stores the result in this quat.
 * This is a fully general operation and makes no assumptions about the type
 * of transform represented by the quat.
 *
 * The other quat must be a different object than this quat.  However, if you
 * need to invert a quat in place, see invert_in_place.
 *
 * The return value is true if the quat was successfully inverted, false if
 * there was a singularity.
 */ 2 4 this 3 3763  5 other 1 3764  
1783 0 0 6 1655 3620 0 0 115 /**
 * Inverts the current quat.  Returns true if the inverse is successful, false
 * if the quat was singular.
 */ 1 4 this 3 3763  
1784 0 0 6 1656 3620 0 0 98 /**
 * Returns true if this quaternion represents the identity transformation: no
 * rotation.
 */ 1 4 this 3 3764  
1785 0 0 6 1657 3620 0 0 110 /**
 * Returns true if this quaternion represents the identity transformation
 * within a given tolerance.
 */ 2 4 this 3 3764  9 tolerance 1 3468  
1786 0 0 6 1658 3764 0 0 42 /**
 * Returns an identity quaternion.
 */ 0 
1787 0 0 7 1659 3630 0 0 0 0 
1788 0 0 7 1662 3766 3440 0 10 /**
 *
 */ 0 
1789 0 0 7 1662 3766 3440 0 19 /**
 * lmatrix3
 */ 1 1 m 1 3719  
1790 0 0 7 1662 3766 3440 0 19 /**
 * lmatrix4
 */ 1 1 m 1 3723  
1791 0 0 7 1662 3766 3440 0 10 /**
 *
 */ 1 1 c 1 3761  
1792 0 0 7 1662 3766 3440 0 0 1 6 param0 0 3767  
1793 0 0 7 1662 3766 3440 0 10 /**
 *
 */ 1 4 copy 1 3683  
1794 0 0 7 1662 3766 3440 0 36 /**
 * axis + angle (in degrees)
 */ 2 4 axis 1 3665  5 angle 1 3465  
1795 0 0 7 1662 3766 3440 0 57 /**
 * Sets the rotation from the given Euler angles.
 */ 3 1 h 1 3465  1 p 1 3465  1 r 1 3465  
1796 0 0 7 1662 3766 3440 0 10 /**
 *
 */ 4 1 r 1 3465  1 i 1 3465  1 j 1 3465  1 k 1 3465  
1797 0 0 7 1663 3760 3387 0 0 2 4 this 3 3767  5 other 1 3761  
1798 0 0 7 1663 3766 3440 0 0 2 4 this 3 3767  5 other 1 3767  
1799 0 0 7 1663 3766 3440 0 0 2 4 this 3 3767  6 scalar 1 3465  
1800 0 0 7 1664 3766 3440 0 0 2 4 this 3 3767  6 scalar 1 3465  
1801 0 0 7 1665 3630 0 0 0 0 
1802 0 0 7 1668 3769 3445 0 10 /**
 *
 */ 0 
1803 0 0 7 1668 3769 3445 0 19 /**
 * lmatrix3
 */ 1 1 m 1 3740  
1804 0 0 7 1668 3769 3445 0 19 /**
 * lmatrix4
 */ 1 1 m 1 3744  
1805 0 0 7 1668 3769 3445 0 10 /**
 *
 */ 1 1 c 1 3764  
1806 0 0 7 1668 3769 3445 0 0 1 6 param0 0 3770  
1807 0 0 7 1668 3769 3445 0 10 /**
 *
 */ 1 4 copy 1 3689  
1808 0 0 7 1668 3769 3445 0 36 /**
 * axis + angle (in degrees)
 */ 2 4 axis 1 3668  5 angle 1 3468  
1809 0 0 7 1668 3769 3445 0 57 /**
 * Sets the rotation from the given Euler angles.
 */ 3 1 h 1 3468  1 p 1 3468  1 r 1 3468  
1810 0 0 7 1668 3769 3445 0 10 /**
 *
 */ 4 1 r 1 3468  1 i 1 3468  1 j 1 3468  1 k 1 3468  
1811 0 0 7 1669 3763 3435 0 0 2 4 this 3 3770  5 other 1 3764  
1812 0 0 7 1669 3769 3445 0 0 2 4 this 3 3770  5 other 1 3770  
1813 0 0 7 1669 3769 3445 0 0 2 4 this 3 3770  6 scalar 1 3468  
1814 0 0 7 1670 3769 3445 0 0 2 4 this 3 3770  6 scalar 1 3468  
1815 0 0 7 1671 3630 0 0 0 0 
1816 0 0 7 1674 3772 3449 0 10 /**
 *
 */ 0 
1817 0 0 7 1674 3772 3449 0 18 /**
 * matrix3
 */ 1 1 m 1 3719  
1818 0 0 7 1674 3772 3449 0 18 /**
 * matrix4
 */ 1 1 m 1 3723  
1819 0 0 7 1674 3772 3449 0 0 1 6 param0 0 3773  
1820 0 0 7 1674 3772 3449 0 10 /**
 *
 */ 1 1 c 1 3761  
1821 0 0 7 1674 3772 3449 0 25 /**
 * vector + twist
 */ 2 8 point_at 1 3665  5 twist 1 3465  
1822 0 0 7 1674 3772 3449 0 10 /**
 *
 */ 4 1 r 1 3465  1 i 1 3465  1 j 1 3465  1 k 1 3465  
1823 0 0 7 1675 3772 3449 0 0 2 4 this 3 3773  5 other 1 3761  
1824 0 0 7 1675 3772 3449 0 0 2 4 this 3 3773  5 other 1 3767  
1825 0 0 7 1676 3630 0 0 0 0 
1826 0 0 7 1679 3775 3453 0 10 /**
 *
 */ 0 
1827 0 0 7 1679 3775 3453 0 18 /**
 * matrix3
 */ 1 1 m 1 3740  
1828 0 0 7 1679 3775 3453 0 18 /**
 * matrix4
 */ 1 1 m 1 3744  
1829 0 0 7 1679 3775 3453 0 0 1 6 param0 0 3776  
1830 0 0 7 1679 3775 3453 0 10 /**
 *
 */ 1 1 c 1 3764  
1831 0 0 7 1679 3775 3453 0 25 /**
 * vector + twist
 */ 2 8 point_at 1 3668  5 twist 1 3468  
1832 0 0 7 1679 3775 3453 0 10 /**
 *
 */ 4 1 r 1 3468  1 i 1 3468  1 j 1 3468  1 k 1 3468  
1833 0 0 7 1680 3775 3453 0 0 2 4 this 3 3776  5 other 1 3764  
1834 0 0 7 1680 3775 3453 0 0 2 4 this 3 3776  5 other 1 3770  
1835 0 0 7 1681 3630 0 0 0 0 
1836 0 0 7 1755 3780 3461 0 0 1 6 param0 0 3778  
1837 0 0 7 1755 3780 3461 0 10 /**
 *
 */ 1 4 name 1 3619  
1838 0 0 7 1755 3780 3461 0 10 /**
 *
 */ 4 4 name 1 3619  13 default_value 1 3781  11 description 1 3619  5 flags 1 3471  
1839 0 0 7 1755 3780 3461 0 10 /**
 *
 */ 4 4 name 1 3619  13 default_value 1 3619  11 description 1 3619  5 flags 1 3471  
1840 0 0 6 1756 3780 0 0 0 2 4 this 3 3780  5 value 1 3781  
1841 0 0 6 1758 3783 0 0 0 2 4 this 3 3778  1 n 1 3471  
1842 0 0 4 1759 3615 0 0 48 /**
 * Reassigns the variable's local value.
 */ 2 4 this 3 3780  5 value 1 3781  
1843 0 0 6 1760 3781 0 0 40 /**
 * Returns the variable's value.
 */ 1 4 this 3 3778  
1844 0 0 7 1761 3784 0 0 48 /**
 * Returns the variable's default value.
 */ 1 4 this 3 3778  
1845 0 0 6 1757 3781 0 0 0 1 4 this 3 3778  
1846 0 0 6 4 3468 0 0 0 1 1 f 1 3468  
1847 0 0 6 4 3465 0 0 0 1 1 f 1 3465  
1848 0 0 6 5 3468 0 0 0 1 1 f 1 3468  
1849 0 0 6 5 3465 0 0 0 1 1 f 1 3465  
1850 0 0 6 547 3484 0 0 0 0 
1851 0 0 6 548 3484 0 0 0 1 3 str 1 3619  
1852 0 0 6 549 3619 0 0 0 1 2 cs 1 3484  
1853 0 0 6 550 3620 0 0 0 1 2 cs 1 3484  
1854 0 0 7 1233 3739 3229 0 0 1 1 a 1 3740  
1855 0 0 7 1233 3718 3041 0 0 1 1 a 1 3719  
1856 0 0 7 1233 3750 3323 0 0 1 1 a 1 3744  
1857 0 0 7 1233 3729 3137 0 0 1 1 a 1 3723  
1858 0 0 7 1234 3739 3229 0 0 1 1 a 1 3740  
1859 0 0 7 1234 3718 3041 0 0 1 1 a 1 3719  
1860 0 0 7 1234 3750 3323 0 0 1 1 a 1 3744  
1861 0 0 7 1234 3729 3137 0 0 1 1 a 1 3723  
1862 0 0 7 1234 3763 3435 0 0 1 1 a 1 3764  
1863 0 0 7 1234 3760 3387 0 0 1 1 a 1 3761  
1864 0 0 7 1555 3739 3229 0 0 2 1 m 1 3740  1 q 1 3764  
1865 0 0 7 1555 3718 3041 0 0 2 1 m 1 3719  1 q 1 3761  
1866 0 0 7 1555 3750 3323 0 0 2 1 m 1 3744  1 q 1 3764  
1867 0 0 7 1555 3729 3137 0 0 2 1 m 1 3723  1 q 1 3761  
1868 0 0 7 1555 3649 2206 0 0 2 1 v 1 3650  1 m 1 3740  
1869 0 0 7 1555 3646 2190 0 0 2 1 v 1 3647  1 m 1 3719  
1870 0 0 7 1555 3676 2578 0 0 2 1 v 1 3677  1 m 1 3740  
1871 0 0 7 1555 3676 2578 0 0 2 1 v 1 3677  1 m 1 3744  
1872 0 0 7 1555 3673 2555 0 0 2 1 v 1 3674  1 m 1 3719  
1873 0 0 7 1555 3673 2555 0 0 2 1 v 1 3674  1 m 1 3723  
1874 0 0 7 1555 3712 2939 0 0 2 1 v 1 3713  1 m 1 3744  
1875 0 0 7 1555 3709 2919 0 0 2 1 v 1 3710  1 m 1 3723  
1876 0 0 7 1555 3658 2366 0 0 2 1 v 1 3659  1 m 1 3740  
1877 0 0 7 1555 3655 2293 0 0 2 1 v 1 3656  1 m 1 3719  
1878 0 0 7 1555 3688 2755 0 0 2 1 v 1 3689  1 m 1 3744  
1879 0 0 7 1555 3682 2673 0 0 2 1 v 1 3683  1 m 1 3723  
1880 0 0 7 1555 3640 2160 0 0 2 1 v 1 3641  1 m 1 3740  
1881 0 0 7 1555 3637 2142 0 0 2 1 v 1 3638  1 m 1 3719  
1882 0 0 7 1555 3667 2506 0 0 2 1 v 1 3668  1 m 1 3740  
1883 0 0 7 1555 3667 2506 0 0 2 1 v 1 3668  1 m 1 3744  
1884 0 0 7 1555 3664 2472 0 0 2 1 v 1 3665  1 m 1 3719  
1885 0 0 7 1555 3664 2472 0 0 2 1 v 1 3665  1 m 1 3723  
1886 0 0 7 1555 3703 2881 0 0 2 1 v 1 3704  1 m 1 3744  
1887 0 0 7 1555 3700 2861 0 0 2 1 v 1 3701  1 m 1 3723  
1888 0 0 4 1556 3615 0 0 0 2 1 v 1 3649  1 m 1 3740  
1889 0 0 4 1556 3615 0 0 0 2 1 v 1 3646  1 m 1 3719  
1890 0 0 4 1556 3615 0 0 0 2 1 v 1 3676  1 m 1 3740  
1891 0 0 4 1556 3615 0 0 0 2 1 v 1 3676  1 m 1 3744  
1892 0 0 4 1556 3615 0 0 0 2 1 v 1 3673  1 m 1 3719  
1893 0 0 4 1556 3615 0 0 0 2 1 v 1 3673  1 m 1 3723  
1894 0 0 4 1556 3615 0 0 0 2 1 v 1 3658  1 m 1 3740  
1895 0 0 4 1556 3615 0 0 0 2 1 v 1 3655  1 m 1 3719  
1896 0 0 4 1556 3615 0 0 0 2 1 v 1 3688  1 m 1 3744  
1897 0 0 4 1556 3615 0 0 0 2 1 v 1 3682  1 m 1 3723  
1898 0 0 4 1556 3615 0 0 0 2 1 v 1 3640  1 m 1 3740  
1899 0 0 4 1556 3615 0 0 0 2 1 v 1 3637  1 m 1 3719  
1900 0 0 4 1556 3615 0 0 0 2 1 v 1 3667  1 m 1 3740  
1901 0 0 4 1556 3615 0 0 0 2 1 v 1 3667  1 m 1 3744  
1902 0 0 4 1556 3615 0 0 0 2 1 v 1 3664  1 m 1 3719  
1903 0 0 4 1556 3615 0 0 0 2 1 v 1 3664  1 m 1 3723  
1904 0 0 4 1557 3615 0 0 0 2 4 dest 1 3625  5 value 1 3740  
1905 0 0 4 1557 3615 0 0 0 2 4 dest 1 3625  5 value 1 3719  
1906 0 0 4 1557 3615 0 0 0 2 4 dest 1 3625  5 value 1 3744  
1907 0 0 4 1557 3615 0 0 0 2 4 dest 1 3625  5 value 1 3723  
1908 0 0 4 1558 3615 0 0 0 2 6 result 1 3739  6 source 1 3627  
1909 0 0 4 1558 3615 0 0 0 2 6 result 1 3718  6 source 1 3627  
1910 0 0 4 1558 3615 0 0 0 2 6 result 1 3750  6 source 1 3627  
1911 0 0 4 1558 3615 0 0 0 2 6 result 1 3729  6 source 1 3627  
1912 0 0 4 1559 3615 0 0 0 4 3 mat 1 3739  5 scale 1 3659  3 hpr 1 3659  2 cs 1 3484  
1913 0 0 4 1559 3615 0 0 0 5 3 mat 1 3739  5 scale 1 3659  5 shear 1 3659  3 hpr 1 3659  2 cs 1 3484  
1914 0 0 4 1559 3615 0 0 0 4 3 mat 1 3718  5 scale 1 3656  3 hpr 1 3656  2 cs 1 3484  
1915 0 0 4 1559 3615 0 0 0 5 3 mat 1 3718  5 scale 1 3656  5 shear 1 3656  3 hpr 1 3656  2 cs 1 3484  
1916 0 0 4 1559 3615 0 0 0 5 3 mat 1 3750  5 scale 1 3659  3 hpr 1 3659  9 translate 1 3659  2 cs 1 3484  
1917 0 0 4 1559 3615 0 0 0 6 3 mat 1 3750  5 scale 1 3659  5 shear 1 3659  3 hpr 1 3659  9 translate 1 3659  2 cs 1 3484  
1918 0 0 4 1559 3615 0 0 0 3 3 mat 1 3750  10 components 1 3785  2 cs 1 3484  
1919 0 0 4 1559 3615 0 0 0 5 3 mat 1 3729  5 scale 1 3656  3 hpr 1 3656  9 translate 1 3656  2 cs 1 3484  
1920 0 0 4 1559 3615 0 0 0 6 3 mat 1 3729  5 scale 1 3656  5 shear 1 3656  3 hpr 1 3656  9 translate 1 3656  2 cs 1 3484  
1921 0 0 4 1559 3615 0 0 0 3 3 mat 1 3729  10 components 1 3787  2 cs 1 3484  
1922 0 0 6 1560 3620 0 0 0 4 3 mat 1 3740  5 scale 1 3658  3 hpr 1 3658  2 cs 1 3484  
1923 0 0 6 1560 3620 0 0 0 5 3 mat 1 3740  5 scale 1 3658  5 shear 1 3658  3 hpr 1 3658  2 cs 1 3484  
1924 0 0 6 1560 3620 0 0 0 4 3 mat 1 3719  5 scale 1 3655  3 hpr 1 3655  2 cs 1 3484  
1925 0 0 6 1560 3620 0 0 0 5 3 mat 1 3719  5 scale 1 3655  5 shear 1 3655  3 hpr 1 3655  2 cs 1 3484  
1926 0 0 6 1560 3620 0 0 0 5 3 mat 1 3744  5 scale 1 3658  3 hpr 1 3658  9 translate 1 3658  2 cs 1 3484  
1927 0 0 6 1560 3620 0 0 0 6 3 mat 1 3744  5 scale 1 3658  5 shear 1 3658  3 hpr 1 3658  9 translate 1 3658  2 cs 1 3484  
1928 0 0 6 1560 3620 0 0 0 3 3 mat 1 3744  10 components 1 3789  2 CS 1 3484  
1929 0 0 6 1560 3620 0 0 0 5 3 mat 1 3723  5 scale 1 3655  3 hpr 1 3655  9 translate 1 3655  2 cs 1 3484  
1930 0 0 6 1560 3620 0 0 0 6 3 mat 1 3723  5 scale 1 3655  5 shear 1 3655  3 hpr 1 3655  9 translate 1 3655  2 cs 1 3484  
1931 0 0 6 1560 3620 0 0 0 3 3 mat 1 3723  10 components 1 3790  2 CS 1 3484  
1932 0 0 6 1561 3620 0 0 0 5 3 mat 1 3740  5 scale 1 3658  5 shear 1 3658  3 hpr 1 3658  2 cs 1 3484  
1933 0 0 6 1561 3620 0 0 0 5 3 mat 1 3719  5 scale 1 3655  5 shear 1 3655  3 hpr 1 3655  2 cs 1 3484  
1934 0 0 7 1562 3658 2366 0 0 1 7 old_hpr 1 3659  
1935 0 0 7 1562 3655 2293 0 0 1 7 old_hpr 1 3656  
329
3462 11 MathNumbers 0 141313 11 MathNumbers 11 MathNumbers 0 0 0 1 1936 1937 0 0 0 0 0 0 0 0

3463 10 LVecBase2f 0 141313 10 LVecBase2f 10 LVecBase2f 0 0 0 1 1940 2002 2 3791 3792 61 1941 1942 1943 1944 1945 1946 1947 1948 1949 1950 1951 1952 1953 1954 1955 1956 1957 1958 1959 1960 1961 1962 1963 1964 1965 1966 1967 1968 1969 1970 1971 1972 1973 1974 1975 1976 1977 1978 1979 1980 1981 1982 1983 1984 1985 1986 1987 1988 1989 1990 1991 1992 1993 1994 1995 1996 1997 1998 1999 2000 2001 0 0 0 0 1 3464 75
/**
 * This is the base class for all two-component vectors and points.
 */

3464 0 0 794624 12 LVecBase2f:: 0 3463 0 0 0 0 0 0 0 0 0 2 14 num_components 26 LVecBase2f::num_components 0
2 6 is_int 18 LVecBase2f::is_int 0
0 0 0

3465 5 float 0 8194 5 float 5 float 0 2 0 0 0 0 0 0 0 0 0 0 0

3466 10 LVecBase2d 0 141313 10 LVecBase2d 10 LVecBase2d 0 0 0 1 2003 2065 2 3793 3794 61 2004 2005 2006 2007 2008 2009 2010 2011 2012 2013 2014 2015 2016 2017 2018 2019 2020 2021 2022 2023 2024 2025 2026 2027 2028 2029 2030 2031 2032 2033 2034 2035 2036 2037 2038 2039 2040 2041 2042 2043 2044 2045 2046 2047 2048 2049 2050 2051 2052 2053 2054 2055 2056 2057 2058 2059 2060 2061 2062 2063 2064 0 0 0 0 1 3467 75
/**
 * This is the base class for all two-component vectors and points.
 */

3467 0 0 794624 12 LVecBase2d:: 0 3466 0 0 0 0 0 0 0 0 0 2 14 num_components 26 LVecBase2d::num_components 0
2 6 is_int 18 LVecBase2d::is_int 0
0 0 0

3468 6 double 0 8194 6 double 6 double 0 3 0 0 0 0 0 0 0 0 0 0 0

3469 10 LVecBase2i 0 141313 10 LVecBase2i 10 LVecBase2i 0 0 0 1 2066 2124 2 3795 3796 57 2067 2068 2069 2070 2071 2072 2073 2074 2075 2076 2077 2078 2079 2080 2081 2082 2083 2084 2085 2086 2087 2088 2089 2090 2091 2092 2093 2094 2095 2096 2097 2098 2099 2100 2101 2102 2103 2104 2105 2106 2107 2108 2109 2110 2111 2112 2113 2114 2115 2116 2117 2118 2119 2120 2121 2122 2123 0 0 0 0 1 3470 75
/**
 * This is the base class for all two-component vectors and points.
 */

3470 0 0 794624 12 LVecBase2i:: 0 3469 0 0 0 0 0 0 0 0 0 2 14 num_components 26 LVecBase2i::num_components 0
2 6 is_int 18 LVecBase2i::is_int 0
1 0 0

3471 3 int 0 8194 3 int 3 int 0 1 0 0 0 0 0 0 0 0 0 0 0

3472 9 LVector2f 0 141313 9 LVector2f 9 LVector2f 0 0 0 1 2125 2142 0 16 2126 2127 2128 2129 2130 2131 2132 2133 2134 2135 2136 2137 2138 2139 2140 2141 0 0 1 0 3463 0 0 0 0 49
/**
 * This is a two-component vector offset.
 */

3473 9 LVector2d 0 141313 9 LVector2d 9 LVector2d 0 0 0 1 2143 2160 0 16 2144 2145 2146 2147 2148 2149 2150 2151 2152 2153 2154 2155 2156 2157 2158 2159 0 0 1 0 3466 0 0 0 0 49
/**
 * This is a two-component vector offset.
 */

3474 9 LVector2i 0 141313 9 LVector2i 9 LVector2i 0 0 0 1 2161 2174 0 12 2162 2163 2164 2165 2166 2167 2168 2169 2170 2171 2172 2173 0 0 1 0 3469 0 0 0 0 49
/**
 * This is a two-component vector offset.
 */

3475 8 LPoint2f 0 141313 8 LPoint2f 8 LPoint2f 0 0 0 1 2175 2190 0 14 2176 2177 2178 2179 2180 2181 2182 2183 2184 2185 2186 2187 2188 2189 0 0 1 0 3463 0 0 0 0 50
/**
 * This is a two-component point in space.
 */

3476 8 LPoint2d 0 141313 8 LPoint2d 8 LPoint2d 0 0 0 1 2191 2206 0 14 2192 2193 2194 2195 2196 2197 2198 2199 2200 2201 2202 2203 2204 2205 0 0 1 0 3466 0 0 0 0 50
/**
 * This is a two-component point in space.
 */

3477 8 LPoint2i 0 141313 8 LPoint2i 8 LPoint2i 0 0 0 1 2207 2220 0 12 2208 2209 2210 2211 2212 2213 2214 2215 2216 2217 2218 2219 0 0 1 0 3469 0 0 0 0 50
/**
 * This is a two-component point in space.
 */

3478 10 LVecBase3f 0 141313 10 LVecBase3f 10 LVecBase3f 0 0 0 1 2221 2293 6 3797 3798 3799 3800 3801 3802 71 2222 2223 2224 2225 2226 2227 2228 2229 2230 2231 2232 2233 2234 2235 2236 2237 2238 2239 2240 2241 2242 2243 2244 2245 2246 2247 2248 2249 2250 2251 2252 2253 2254 2255 2256 2257 2258 2259 2260 2261 2262 2263 2264 2265 2266 2267 2268 2269 2270 2271 2272 2273 2274 2275 2276 2277 2278 2279 2280 2281 2282 2283 2284 2285 2286 2287 2288 2289 2290 2291 2292 0 0 0 0 1 3479 77
/**
 * This is the base class for all three-component vectors and points.
 */

3479 0 0 794624 12 LVecBase3f:: 0 3478 0 0 0 0 0 0 0 0 0 2 14 num_components 26 LVecBase3f::num_components 0
3 6 is_int 18 LVecBase3f::is_int 0
0 0 0

3480 10 LVecBase3d 0 141313 10 LVecBase3d 10 LVecBase3d 0 0 0 1 2294 2366 6 3803 3804 3805 3806 3807 3808 71 2295 2296 2297 2298 2299 2300 2301 2302 2303 2304 2305 2306 2307 2308 2309 2310 2311 2312 2313 2314 2315 2316 2317 2318 2319 2320 2321 2322 2323 2324 2325 2326 2327 2328 2329 2330 2331 2332 2333 2334 2335 2336 2337 2338 2339 2340 2341 2342 2343 2344 2345 2346 2347 2348 2349 2350 2351 2352 2353 2354 2355 2356 2357 2358 2359 2360 2361 2362 2363 2364 2365 0 0 0 0 1 3481 77
/**
 * This is the base class for all three-component vectors and points.
 */

3481 0 0 794624 12 LVecBase3d:: 0 3480 0 0 0 0 0 0 0 0 0 2 14 num_components 26 LVecBase3d::num_components 0
3 6 is_int 18 LVecBase3d::is_int 0
0 0 0

3482 10 LVecBase3i 0 141313 10 LVecBase3i 10 LVecBase3i 0 0 0 1 2367 2434 6 3809 3810 3811 3812 3813 3814 66 2368 2369 2370 2371 2372 2373 2374 2375 2376 2377 2378 2379 2380 2381 2382 2383 2384 2385 2386 2387 2388 2389 2390 2391 2392 2393 2394 2395 2396 2397 2398 2399 2400 2401 2402 2403 2404 2405 2406 2407 2408 2409 2410 2411 2412 2413 2414 2415 2416 2417 2418 2419 2420 2421 2422 2423 2424 2425 2426 2427 2428 2429 2430 2431 2432 2433 0 0 0 0 1 3483 77
/**
 * This is the base class for all three-component vectors and points.
 */

3483 0 0 794624 12 LVecBase3i:: 0 3482 0 0 0 0 0 0 0 0 0 2 14 num_components 26 LVecBase3i::num_components 0
3 6 is_int 18 LVecBase3i::is_int 0
1 0 0

3484 16 CoordinateSystem 0 532481 16 CoordinateSystem 16 CoordinateSystem 0 0 0 0 0 0 0 0 0 0 6 10 CS_default 10 CS_default 210
// The CS_default entry does not refer to a particular coordinate system,
// but rather to the value stored in default_coordinate_system, which in
// turn is loaded from the config variable "coordinate-system".
0 12 CS_zup_right 12 CS_zup_right 0
1 12 CS_yup_right 12 CS_yup_right 0
2 11 CS_zup_left 11 CS_zup_left 0
3 11 CS_yup_left 11 CS_yup_left 0
4 10 CS_invalid 10 CS_invalid 156
// CS_invalid is not a coordinate system at all.  It can be used in user-
// input processing code to indicate a contradictory coordinate system
// request.
5 0 0

3485 9 LVector3f 0 141313 9 LVector3f 9 LVector3f 0 0 0 1 2439 2472 3 3815 3816 3817 32 2440 2441 2442 2443 2444 2445 2446 2447 2448 2449 2450 2451 2452 2453 2454 2455 2456 2457 2458 2459 2460 2461 2462 2463 2464 2465 2466 2467 2468 2469 2470 2471 0 0 1 0 3478 0 0 0 0 338
/**
 * This is a three-component vector distance (as opposed to a three-component
 * point, which represents a particular point in space).  Some of the methods
 * are slightly different between LPoint3 and LVector3; in particular,
 * subtraction of two points yields a vector, while addition of a vector and a
 * point yields a point.
 */

3486 9 LVector3d 0 141313 9 LVector3d 9 LVector3d 0 0 0 1 2473 2506 3 3818 3819 3820 32 2474 2475 2476 2477 2478 2479 2480 2481 2482 2483 2484 2485 2486 2487 2488 2489 2490 2491 2492 2493 2494 2495 2496 2497 2498 2499 2500 2501 2502 2503 2504 2505 0 0 1 0 3480 0 0 0 0 338
/**
 * This is a three-component vector distance (as opposed to a three-component
 * point, which represents a particular point in space).  Some of the methods
 * are slightly different between LPoint3 and LVector3; in particular,
 * subtraction of two points yields a vector, while addition of a vector and a
 * point yields a point.
 */

3487 9 LVector3i 0 141313 9 LVector3i 9 LVector3i 0 0 0 1 2507 2532 3 3821 3822 3823 24 2508 2509 2510 2511 2512 2513 2514 2515 2516 2517 2518 2519 2520 2521 2522 2523 2524 2525 2526 2527 2528 2529 2530 2531 0 0 1 0 3482 0 0 0 0 338
/**
 * This is a three-component vector distance (as opposed to a three-component
 * point, which represents a particular point in space).  Some of the methods
 * are slightly different between LPoint3 and LVector3; in particular,
 * subtraction of two points yields a vector, while addition of a vector and a
 * point yields a point.
 */

3488 8 LPoint3f 0 141313 8 LPoint3f 8 LPoint3f 0 0 0 1 2533 2555 3 3824 3825 3826 21 2534 2535 2536 2537 2538 2539 2540 2541 2542 2543 2544 2545 2546 2547 2548 2549 2550 2551 2552 2553 2554 0 0 1 0 3478 0 0 0 0 337
/**
 * This is a three-component point in space (as opposed to a three-component
 * vector, which represents a direction and a distance).  Some of the methods
 * are slightly different between LPoint3 and LVector3; in particular,
 * subtraction of two points yields a vector, while addition of a vector and a
 * point yields a point.
 */

3489 8 LPoint3d 0 141313 8 LPoint3d 8 LPoint3d 0 0 0 1 2556 2578 3 3827 3828 3829 21 2557 2558 2559 2560 2561 2562 2563 2564 2565 2566 2567 2568 2569 2570 2571 2572 2573 2574 2575 2576 2577 0 0 1 0 3480 0 0 0 0 337
/**
 * This is a three-component point in space (as opposed to a three-component
 * vector, which represents a direction and a distance).  Some of the methods
 * are slightly different between LPoint3 and LVector3; in particular,
 * subtraction of two points yields a vector, while addition of a vector and a
 * point yields a point.
 */

3490 8 LPoint3i 0 141313 8 LPoint3i 8 LPoint3i 0 0 0 1 2579 2599 3 3830 3831 3832 19 2580 2581 2582 2583 2584 2585 2586 2587 2588 2589 2590 2591 2592 2593 2594 2595 2596 2597 2598 0 0 1 0 3482 0 0 0 0 337
/**
 * This is a three-component point in space (as opposed to a three-component
 * vector, which represents a direction and a distance).  Some of the methods
 * are slightly different between LPoint3 and LVector3; in particular,
 * subtraction of two points yields a vector, while addition of a vector and a
 * point yields a point.
 */

3491 10 LVecBase4f 0 141313 10 LVecBase4f 10 LVecBase4f 0 0 0 1 2600 2673 5 3833 3834 3835 3836 3837 72 2601 2602 2603 2604 2605 2606 2607 2608 2609 2610 2611 2612 2613 2614 2615 2616 2617 2618 2619 2620 2621 2622 2623 2624 2625 2626 2627 2628 2629 2630 2631 2632 2633 2634 2635 2636 2637 2638 2639 2640 2641 2642 2643 2644 2645 2646 2647 2648 2649 2650 2651 2652 2653 2654 2655 2656 2657 2658 2659 2660 2661 2662 2663 2664 2665 2666 2667 2668 2669 2670 2671 2672 0 0 0 0 1 3492 77
/**
 * This is the base class for all three-component vectors and points.
 */

3492 0 0 794624 12 LVecBase4f:: 0 3491 0 0 0 0 0 0 0 0 0 2 14 num_components 26 LVecBase4f::num_components 0
4 6 is_int 18 LVecBase4f::is_int 0
0 0 0

3493 19 UnalignedLVecBase4f 0 141313 19 UnalignedLVecBase4f 19 UnalignedLVecBase4f 0 0 0 1 2674 2681 0 6 2675 2676 2677 2678 2679 2680 0 0 0 0 1 3494 391
/**
 * This is an "unaligned" LVecBase4.  It has no functionality other than to
 * store numbers, and it will pack them in as tightly as possible, avoiding
 * any SSE2 alignment requirements shared by the primary LVecBase4 class.
 *
 * Use it only when you need to pack numbers tightly without respect to
 * alignment, and then copy it to a proper LVecBase4 to get actual use from
 * it.
 */

3494 0 0 794624 21 UnalignedLVecBase4f:: 0 3493 0 0 0 0 0 0 0 0 0 2 14 num_components 35 UnalignedLVecBase4f::num_components 0
4 6 is_int 27 UnalignedLVecBase4f::is_int 0
0 0 0

3495 10 LVecBase4d 0 141313 10 LVecBase4d 10 LVecBase4d 0 0 0 1 2682 2755 5 3838 3839 3840 3841 3842 72 2683 2684 2685 2686 2687 2688 2689 2690 2691 2692 2693 2694 2695 2696 2697 2698 2699 2700 2701 2702 2703 2704 2705 2706 2707 2708 2709 2710 2711 2712 2713 2714 2715 2716 2717 2718 2719 2720 2721 2722 2723 2724 2725 2726 2727 2728 2729 2730 2731 2732 2733 2734 2735 2736 2737 2738 2739 2740 2741 2742 2743 2744 2745 2746 2747 2748 2749 2750 2751 2752 2753 2754 0 0 0 0 1 3496 77
/**
 * This is the base class for all three-component vectors and points.
 */

3496 0 0 794624 12 LVecBase4d:: 0 3495 0 0 0 0 0 0 0 0 0 2 14 num_components 26 LVecBase4d::num_components 0
4 6 is_int 18 LVecBase4d::is_int 0
0 0 0

3497 19 UnalignedLVecBase4d 0 141313 19 UnalignedLVecBase4d 19 UnalignedLVecBase4d 0 0 0 1 2756 2763 0 6 2757 2758 2759 2760 2761 2762 0 0 0 0 1 3498 391
/**
 * This is an "unaligned" LVecBase4.  It has no functionality other than to
 * store numbers, and it will pack them in as tightly as possible, avoiding
 * any SSE2 alignment requirements shared by the primary LVecBase4 class.
 *
 * Use it only when you need to pack numbers tightly without respect to
 * alignment, and then copy it to a proper LVecBase4 to get actual use from
 * it.
 */

3498 0 0 794624 21 UnalignedLVecBase4d:: 0 3497 0 0 0 0 0 0 0 0 0 2 14 num_components 35 UnalignedLVecBase4d::num_components 0
4 6 is_int 27 UnalignedLVecBase4d::is_int 0
0 0 0

3499 10 LVecBase4i 0 141313 10 LVecBase4i 10 LVecBase4i 0 0 0 1 2764 2833 5 3843 3844 3845 3846 3847 68 2765 2766 2767 2768 2769 2770 2771 2772 2773 2774 2775 2776 2777 2778 2779 2780 2781 2782 2783 2784 2785 2786 2787 2788 2789 2790 2791 2792 2793 2794 2795 2796 2797 2798 2799 2800 2801 2802 2803 2804 2805 2806 2807 2808 2809 2810 2811 2812 2813 2814 2815 2816 2817 2818 2819 2820 2821 2822 2823 2824 2825 2826 2827 2828 2829 2830 2831 2832 0 0 0 0 1 3500 77
/**
 * This is the base class for all three-component vectors and points.
 */

3500 0 0 794624 12 LVecBase4i:: 0 3499 0 0 0 0 0 0 0 0 0 2 14 num_components 26 LVecBase4i::num_components 0
4 6 is_int 18 LVecBase4i::is_int 0
1 0 0

3501 19 UnalignedLVecBase4i 0 141313 19 UnalignedLVecBase4i 19 UnalignedLVecBase4i 0 0 0 1 2834 2841 0 6 2835 2836 2837 2838 2839 2840 0 0 0 0 1 3502 391
/**
 * This is an "unaligned" LVecBase4.  It has no functionality other than to
 * store numbers, and it will pack them in as tightly as possible, avoiding
 * any SSE2 alignment requirements shared by the primary LVecBase4 class.
 *
 * Use it only when you need to pack numbers tightly without respect to
 * alignment, and then copy it to a proper LVecBase4 to get actual use from
 * it.
 */

3502 0 0 794624 21 UnalignedLVecBase4i:: 0 3501 0 0 0 0 0 0 0 0 0 2 14 num_components 35 UnalignedLVecBase4i::num_components 0
4 6 is_int 27 UnalignedLVecBase4i::is_int 0
1 0 0

3503 9 LVector4f 0 141313 9 LVector4f 9 LVector4f 0 0 0 1 2842 2861 2 3848 3849 18 2843 2844 2845 2846 2847 2848 2849 2850 2851 2852 2853 2854 2855 2856 2857 2858 2859 2860 0 0 1 0 3491 0 0 0 0 52
/**
 * This is a four-component vector distance.
 */

3504 9 LVector4d 0 141313 9 LVector4d 9 LVector4d 0 0 0 1 2862 2881 2 3850 3851 18 2863 2864 2865 2866 2867 2868 2869 2870 2871 2872 2873 2874 2875 2876 2877 2878 2879 2880 0 0 1 0 3495 0 0 0 0 52
/**
 * This is a four-component vector distance.
 */

3505 9 LVector4i 0 141313 9 LVector4i 9 LVector4i 0 0 0 1 2882 2899 2 3852 3853 16 2883 2884 2885 2886 2887 2888 2889 2890 2891 2892 2893 2894 2895 2896 2897 2898 0 0 1 0 3499 0 0 0 0 52
/**
 * This is a four-component vector distance.
 */

3506 8 LPoint4f 0 141313 8 LPoint4f 8 LPoint4f 0 0 0 1 2900 2919 2 3854 3855 18 2901 2902 2903 2904 2905 2906 2907 2908 2909 2910 2911 2912 2913 2914 2915 2916 2917 2918 0 0 1 0 3491 0 0 0 0 51
/**
 * This is a four-component point in space.
 */

3507 8 LPoint4d 0 141313 8 LPoint4d 8 LPoint4d 0 0 0 1 2920 2939 2 3856 3857 18 2921 2922 2923 2924 2925 2926 2927 2928 2929 2930 2931 2932 2933 2934 2935 2936 2937 2938 0 0 1 0 3495 0 0 0 0 51
/**
 * This is a four-component point in space.
 */

3508 8 LPoint4i 0 141313 8 LPoint4i 8 LPoint4i 0 0 0 1 2940 2957 2 3858 3859 16 2941 2942 2943 2944 2945 2946 2947 2948 2949 2950 2951 2952 2953 2954 2955 2956 0 0 1 0 3499 0 0 0 0 51
/**
 * This is a four-component point in space.
 */

3509 9 LMatrix3f 0 141313 9 LMatrix3f 9 LMatrix3f 0 0 0 1 2966 3041 2 3860 3861 74 2967 2968 2969 2970 2971 2972 2973 2974 2975 2976 2977 2978 2979 2980 2981 2982 2983 2984 2985 2986 2987 2988 2989 2990 2991 2992 2993 2994 2995 2996 2997 2998 2999 3000 3001 3002 3003 3004 3005 3006 3007 3008 3009 3010 3011 3012 3013 3014 3015 3016 3017 3018 3019 3020 3021 3022 3023 3024 3025 3026 3027 3028 3029 3030 3031 3032 3033 3034 3035 3036 3037 3038 3039 3040 4 3868 3869 3870 3871 0 0 0 3 3510 3511 3512 231
/**
 * This is a 3-by-3 transform matrix.  It typically will represent either a
 * rotation-and-scale (no translation) matrix in 3-d, or a full affine matrix
 * (rotation, scale, translation) in 2-d, e.g.  for a texture matrix.
 */

3510 0 0 794624 11 LMatrix3f:: 0 3509 0 0 0 0 0 0 0 0 0 2 14 num_components 25 LMatrix3f::num_components 0
9 6 is_int 17 LMatrix3f::is_int 0
0 0 0

3511 3 Row 0 403457 14 LMatrix3f::Row 14 LMatrix3f::Row 3509 0 0 1 2960 2961 0 2 2958 2959 0 0 0 0 0 66
// These helper classes are used to support two-level operator [].

3512 4 CRow 0 403457 15 LMatrix3f::CRow 15 LMatrix3f::CRow 3509 0 0 1 2964 2965 0 2 2962 2963 0 0 0 0 0 0

3513 9 LMatrix4f 0 141313 9 LMatrix4f 9 LMatrix4f 0 0 0 1 3052 3137 2 3862 3863 84 3053 3054 3055 3056 3057 3058 3059 3060 3061 3062 3063 3064 3065 3066 3067 3068 3069 3070 3071 3072 3073 3074 3075 3076 3077 3078 3079 3080 3081 3082 3083 3084 3085 3086 3087 3088 3089 3090 3091 3092 3093 3094 3095 3096 3097 3098 3099 3100 3101 3102 3103 3104 3105 3106 3107 3108 3109 3110 3111 3112 3113 3114 3115 3116 3117 3118 3119 3120 3121 3122 3123 3124 3125 3126 3127 3128 3129 3130 3131 3132 3133 3134 3135 3136 3 3872 3873 3874 0 0 0 3 3514 3515 3516 45
/**
 * This is a 4-by-4 transform matrix.
 */

3514 0 0 794624 11 LMatrix4f:: 0 3513 0 0 0 0 0 0 0 0 0 2 14 num_components 25 LMatrix4f::num_components 0
16 6 is_int 17 LMatrix4f::is_int 0
0 0 0

3515 3 Row 0 403457 14 LMatrix4f::Row 14 LMatrix4f::Row 3513 0 0 1 3046 3047 0 2 3044 3045 0 0 0 0 0 66
// These helper classes are used to support two-level operator [].

3516 4 CRow 0 403457 15 LMatrix4f::CRow 15 LMatrix4f::CRow 3513 0 0 1 3050 3051 0 2 3048 3049 0 0 0 0 0 0

3517 18 UnalignedLMatrix4f 0 141313 18 UnalignedLMatrix4f 18 UnalignedLMatrix4f 0 0 0 1 3138 3145 0 6 3139 3140 3141 3142 3143 3144 0 0 0 0 1 3518 385
/**
 * This is an "unaligned" LMatrix4.  It has no functionality other than to
 * store numbers, and it will pack them in as tightly as possible, avoiding
 * any SSE2 alignment requirements shared by the primary LMatrix4 class.
 *
 * Use it only when you need to pack numbers tightly without respect to
 * alignment, and then copy it to a proper LMatrix4 to get actual use from it.
 */

3518 0 0 794624 20 UnalignedLMatrix4f:: 0 3517 0 0 0 0 0 0 0 0 0 1 14 num_components 34 UnalignedLMatrix4f::num_components 0
16 0 0

3519 9 LMatrix3d 0 141313 9 LMatrix3d 9 LMatrix3d 0 0 0 1 3154 3229 2 3864 3865 74 3155 3156 3157 3158 3159 3160 3161 3162 3163 3164 3165 3166 3167 3168 3169 3170 3171 3172 3173 3174 3175 3176 3177 3178 3179 3180 3181 3182 3183 3184 3185 3186 3187 3188 3189 3190 3191 3192 3193 3194 3195 3196 3197 3198 3199 3200 3201 3202 3203 3204 3205 3206 3207 3208 3209 3210 3211 3212 3213 3214 3215 3216 3217 3218 3219 3220 3221 3222 3223 3224 3225 3226 3227 3228 4 3875 3876 3877 3878 0 0 0 3 3520 3521 3522 231
/**
 * This is a 3-by-3 transform matrix.  It typically will represent either a
 * rotation-and-scale (no translation) matrix in 3-d, or a full affine matrix
 * (rotation, scale, translation) in 2-d, e.g.  for a texture matrix.
 */

3520 0 0 794624 11 LMatrix3d:: 0 3519 0 0 0 0 0 0 0 0 0 2 14 num_components 25 LMatrix3d::num_components 0
9 6 is_int 17 LMatrix3d::is_int 0
0 0 0

3521 3 Row 0 403457 14 LMatrix3d::Row 14 LMatrix3d::Row 3519 0 0 1 3148 3149 0 2 3146 3147 0 0 0 0 0 66
// These helper classes are used to support two-level operator [].

3522 4 CRow 0 403457 15 LMatrix3d::CRow 15 LMatrix3d::CRow 3519 0 0 1 3152 3153 0 2 3150 3151 0 0 0 0 0 0

3523 9 LMatrix4d 0 141313 9 LMatrix4d 9 LMatrix4d 0 0 0 1 3238 3323 2 3866 3867 84 3239 3240 3241 3242 3243 3244 3245 3246 3247 3248 3249 3250 3251 3252 3253 3254 3255 3256 3257 3258 3259 3260 3261 3262 3263 3264 3265 3266 3267 3268 3269 3270 3271 3272 3273 3274 3275 3276 3277 3278 3279 3280 3281 3282 3283 3284 3285 3286 3287 3288 3289 3290 3291 3292 3293 3294 3295 3296 3297 3298 3299 3300 3301 3302 3303 3304 3305 3306 3307 3308 3309 3310 3311 3312 3313 3314 3315 3316 3317 3318 3319 3320 3321 3322 3 3879 3880 3881 0 0 0 3 3524 3525 3526 45
/**
 * This is a 4-by-4 transform matrix.
 */

3524 0 0 794624 11 LMatrix4d:: 0 3523 0 0 0 0 0 0 0 0 0 2 14 num_components 25 LMatrix4d::num_components 0
16 6 is_int 17 LMatrix4d::is_int 0
0 0 0

3525 3 Row 0 403457 14 LMatrix4d::Row 14 LMatrix4d::Row 3523 0 0 1 3232 3233 0 2 3230 3231 0 0 0 0 0 66
// These helper classes are used to support two-level operator [].

3526 4 CRow 0 403457 15 LMatrix4d::CRow 15 LMatrix4d::CRow 3523 0 0 1 3236 3237 0 2 3234 3235 0 0 0 0 0 0

3527 18 UnalignedLMatrix4d 0 141313 18 UnalignedLMatrix4d 18 UnalignedLMatrix4d 0 0 0 1 3324 3331 0 6 3325 3326 3327 3328 3329 3330 0 0 0 0 1 3528 385
/**
 * This is an "unaligned" LMatrix4.  It has no functionality other than to
 * store numbers, and it will pack them in as tightly as possible, avoiding
 * any SSE2 alignment requirements shared by the primary LMatrix4 class.
 *
 * Use it only when you need to pack numbers tightly without respect to
 * alignment, and then copy it to a proper LMatrix4 to get actual use from it.
 */

3528 0 0 794624 20 UnalignedLMatrix4d:: 0 3527 0 0 0 0 0 0 0 0 0 1 14 num_components 34 UnalignedLMatrix4d::num_components 0
16 0 0

3529 12 LQuaternionf 0 141313 12 LQuaternionf 12 LQuaternionf 0 0 0 1 3340 3387 0 46 3341 3342 3343 3344 3345 3346 3347 3348 3349 3350 3351 3352 3353 3354 3355 3356 3357 3358 3359 3360 3361 3362 3363 3364 3365 3366 3367 3368 3369 3370 3371 3372 3373 3374 3375 3376 3377 3378 3379 3380 3381 3382 3383 3384 3385 3386 0 0 1 0 3491 0 0 0 0 44
/**
 * This is the base quaternion class
 */

3530 12 LQuaterniond 0 141313 12 LQuaterniond 12 LQuaterniond 0 0 0 1 3388 3435 0 46 3389 3390 3391 3392 3393 3394 3395 3396 3397 3398 3399 3400 3401 3402 3403 3404 3405 3406 3407 3408 3409 3410 3411 3412 3413 3414 3415 3416 3417 3418 3419 3420 3421 3422 3423 3424 3425 3426 3427 3428 3429 3430 3431 3432 3433 3434 0 0 1 0 3495 0 0 0 0 44
/**
 * This is the base quaternion class
 */

3531 10 LRotationf 0 141313 10 LRotationf 10 LRotationf 0 0 0 1 3436 3440 0 3 3437 3438 3439 0 0 1 0 3529 0 0 0 0 61
/**
 * This is a unit quaternion representing a rotation.
 */

3532 10 LRotationd 0 141313 10 LRotationd 10 LRotationd 0 0 0 1 3441 3445 0 3 3442 3443 3444 0 0 1 0 3530 0 0 0 0 61
/**
 * This is a unit quaternion representing a rotation.
 */

3533 13 LOrientationf 0 141313 13 LOrientationf 13 LOrientationf 0 0 0 1 3446 3449 0 2 3447 3448 0 0 1 0 3529 0 0 0 0 65
/**
 * This is a unit quaternion representing an orientation.
 */

3534 13 LOrientationd 0 141313 13 LOrientationd 13 LOrientationd 0 0 0 1 3450 3453 0 2 3451 3452 0 0 1 0 3530 0 0 0 0 65
/**
 * This is a unit quaternion representing an orientation.
 */

3535 8 LVertexf 0 2105345 8 LVertexf 8 LVertexf 0 0 3488 0 0 0 0 0 0 0 0 0 0

3536 8 LNormalf 0 2105345 8 LNormalf 8 LNormalf 0 0 3485 0 0 0 0 0 0 0 0 0 0

3537 10 LTexCoordf 0 2105345 10 LTexCoordf 10 LTexCoordf 0 0 3475 0 0 0 0 0 0 0 0 0 0

3538 11 LTexCoord3f 0 2105345 11 LTexCoord3f 11 LTexCoord3f 0 0 3488 0 0 0 0 0 0 0 0 0 0

3539 7 LColorf 0 2105345 7 LColorf 7 LColorf 0 0 3491 0 0 0 0 0 0 0 0 0 0

3540 10 LRGBColorf 0 2105345 10 LRGBColorf 10 LRGBColorf 0 0 3478 0 0 0 0 0 0 0 0 0 0

3541 8 LVertexd 0 2105345 8 LVertexd 8 LVertexd 0 0 3489 0 0 0 0 0 0 0 0 0 0

3542 8 LNormald 0 2105345 8 LNormald 8 LNormald 0 0 3486 0 0 0 0 0 0 0 0 0 0

3543 10 LTexCoordd 0 2105345 10 LTexCoordd 10 LTexCoordd 0 0 3476 0 0 0 0 0 0 0 0 0 0

3544 11 LTexCoord3d 0 2105345 11 LTexCoord3d 11 LTexCoord3d 0 0 3489 0 0 0 0 0 0 0 0 0 0

3545 7 LColord 0 2105345 7 LColord 7 LColord 0 0 3495 0 0 0 0 0 0 0 0 0 0

3546 10 LRGBColord 0 2105345 10 LRGBColord 10 LRGBColord 0 0 3480 0 0 0 0 0 0 0 0 0 0

3547 5 Mat4F 0 2105345 5 Mat4F 5 Mat4F 0 0 3513 0 0 0 0 0 0 0 0 0 0

3548 5 Mat3F 0 2105345 5 Mat3F 5 Mat3F 0 0 3509 0 0 0 0 0 0 0 0 0 0

3549 7 VBase4F 0 2105345 7 VBase4F 7 VBase4F 0 0 3491 0 0 0 0 0 0 0 0 0 0

3550 5 Vec4F 0 2105345 5 Vec4F 5 Vec4F 0 0 3503 0 0 0 0 0 0 0 0 0 0

3551 7 Point4F 0 2105345 7 Point4F 7 Point4F 0 0 3506 0 0 0 0 0 0 0 0 0 0

3552 7 VBase3F 0 2105345 7 VBase3F 7 VBase3F 0 0 3478 0 0 0 0 0 0 0 0 0 0

3553 5 Vec3F 0 2105345 5 Vec3F 5 Vec3F 0 0 3485 0 0 0 0 0 0 0 0 0 0

3554 7 Point3F 0 2105345 7 Point3F 7 Point3F 0 0 3488 0 0 0 0 0 0 0 0 0 0

3555 7 VBase2F 0 2105345 7 VBase2F 7 VBase2F 0 0 3463 0 0 0 0 0 0 0 0 0 0

3556 5 Vec2F 0 2105345 5 Vec2F 5 Vec2F 0 0 3472 0 0 0 0 0 0 0 0 0 0

3557 7 Point2F 0 2105345 7 Point2F 7 Point2F 0 0 3475 0 0 0 0 0 0 0 0 0 0

3558 5 QuatF 0 2105345 5 QuatF 5 QuatF 0 0 3529 0 0 0 0 0 0 0 0 0 0

3559 5 Mat4D 0 2105345 5 Mat4D 5 Mat4D 0 0 3523 0 0 0 0 0 0 0 0 0 0

3560 5 Mat3D 0 2105345 5 Mat3D 5 Mat3D 0 0 3519 0 0 0 0 0 0 0 0 0 0

3561 7 VBase4D 0 2105345 7 VBase4D 7 VBase4D 0 0 3495 0 0 0 0 0 0 0 0 0 0

3562 5 Vec4D 0 2105345 5 Vec4D 5 Vec4D 0 0 3504 0 0 0 0 0 0 0 0 0 0

3563 7 Point4D 0 2105345 7 Point4D 7 Point4D 0 0 3507 0 0 0 0 0 0 0 0 0 0

3564 7 VBase3D 0 2105345 7 VBase3D 7 VBase3D 0 0 3480 0 0 0 0 0 0 0 0 0 0

3565 5 Vec3D 0 2105345 5 Vec3D 5 Vec3D 0 0 3486 0 0 0 0 0 0 0 0 0 0

3566 7 Point3D 0 2105345 7 Point3D 7 Point3D 0 0 3489 0 0 0 0 0 0 0 0 0 0

3567 7 VBase2D 0 2105345 7 VBase2D 7 VBase2D 0 0 3466 0 0 0 0 0 0 0 0 0 0

3568 5 Vec2D 0 2105345 5 Vec2D 5 Vec2D 0 0 3473 0 0 0 0 0 0 0 0 0 0

3569 7 Point2D 0 2105345 7 Point2D 7 Point2D 0 0 3476 0 0 0 0 0 0 0 0 0 0

3570 5 QuatD 0 2105345 5 QuatD 5 QuatD 0 0 3530 0 0 0 0 0 0 0 0 0 0

3571 9 LVecBase2 0 2105345 9 LVecBase2 9 LVecBase2 0 0 3463 0 0 0 0 0 0 0 0 0 0

3572 7 LPoint2 0 2105345 7 LPoint2 7 LPoint2 0 0 3475 0 0 0 0 0 0 0 0 0 0

3573 8 LVector2 0 2105345 8 LVector2 8 LVector2 0 0 3472 0 0 0 0 0 0 0 0 0 0

3574 9 LVecBase3 0 2105345 9 LVecBase3 9 LVecBase3 0 0 3478 0 0 0 0 0 0 0 0 0 0

3575 7 LPoint3 0 2105345 7 LPoint3 7 LPoint3 0 0 3488 0 0 0 0 0 0 0 0 0 0

3576 8 LVector3 0 2105345 8 LVector3 8 LVector3 0 0 3485 0 0 0 0 0 0 0 0 0 0

3577 9 LVecBase4 0 2105345 9 LVecBase4 9 LVecBase4 0 0 3491 0 0 0 0 0 0 0 0 0 0

3578 7 LPoint4 0 2105345 7 LPoint4 7 LPoint4 0 0 3506 0 0 0 0 0 0 0 0 0 0

3579 8 LVector4 0 2105345 8 LVector4 8 LVector4 0 0 3503 0 0 0 0 0 0 0 0 0 0

3580 11 LQuaternion 0 2105345 11 LQuaternion 11 LQuaternion 0 0 3529 0 0 0 0 0 0 0 0 0 0

3581 9 LRotation 0 2105345 9 LRotation 9 LRotation 0 0 3531 0 0 0 0 0 0 0 0 0 0

3582 12 LOrientation 0 2105345 12 LOrientation 12 LOrientation 0 0 3533 0 0 0 0 0 0 0 0 0 0

3583 8 LMatrix3 0 2105345 8 LMatrix3 8 LMatrix3 0 0 3509 0 0 0 0 0 0 0 0 0 0

3584 8 LMatrix4 0 2105345 8 LMatrix4 8 LMatrix4 0 0 3513 0 0 0 0 0 0 0 0 0 0

3585 7 LVertex 0 2105345 7 LVertex 7 LVertex 0 0 3535 0 0 0 0 0 0 0 0 0 0

3586 7 LNormal 0 2105345 7 LNormal 7 LNormal 0 0 3536 0 0 0 0 0 0 0 0 0 0

3587 9 LTexCoord 0 2105345 9 LTexCoord 9 LTexCoord 0 0 3537 0 0 0 0 0 0 0 0 0 0

3588 10 LTexCoord3 0 2105345 10 LTexCoord3 10 LTexCoord3 0 0 3538 0 0 0 0 0 0 0 0 0 0

3589 6 LColor 0 2105345 6 LColor 6 LColor 0 0 3539 0 0 0 0 0 0 0 0 0 0

3590 9 LRGBColor 0 2105345 9 LRGBColor 9 LRGBColor 0 0 3540 0 0 0 0 0 0 0 0 0 0

3591 18 UnalignedLVecBase4 0 2105345 18 UnalignedLVecBase4 18 UnalignedLVecBase4 0 0 3493 0 0 0 0 0 0 0 0 0 0

3592 17 UnalignedLMatrix4 0 2105345 17 UnalignedLMatrix4 17 UnalignedLMatrix4 0 0 3517 0 0 0 0 0 0 0 0 0 0

3593 4 Mat4 0 2105345 4 Mat4 4 Mat4 0 0 3513 0 0 0 0 0 0 0 0 0 0

3594 4 Mat3 0 2105345 4 Mat3 4 Mat3 0 0 3509 0 0 0 0 0 0 0 0 0 0

3595 6 VBase4 0 2105345 6 VBase4 6 VBase4 0 0 3491 0 0 0 0 0 0 0 0 0 0

3596 4 Vec4 0 2105345 4 Vec4 4 Vec4 0 0 3503 0 0 0 0 0 0 0 0 0 0

3597 6 Point4 0 2105345 6 Point4 6 Point4 0 0 3506 0 0 0 0 0 0 0 0 0 0

3598 6 VBase3 0 2105345 6 VBase3 6 VBase3 0 0 3478 0 0 0 0 0 0 0 0 0 0

3599 4 Vec3 0 2105345 4 Vec3 4 Vec3 0 0 3485 0 0 0 0 0 0 0 0 0 0

3600 6 Point3 0 2105345 6 Point3 6 Point3 0 0 3488 0 0 0 0 0 0 0 0 0 0

3601 6 VBase2 0 2105345 6 VBase2 6 VBase2 0 0 3463 0 0 0 0 0 0 0 0 0 0

3602 4 Vec2 0 2105345 4 Vec2 4 Vec2 0 0 3472 0 0 0 0 0 0 0 0 0 0

3603 6 Point2 0 2105345 6 Point2 6 Point2 0 0 3475 0 0 0 0 0 0 0 0 0 0

3604 4 Quat 0 2105345 4 Quat 4 Quat 0 0 3529 0 0 0 0 0 0 0 0 0 0

3605 19 ConfigVariableColor 0 141313 19 ConfigVariableColor 19 ConfigVariableColor 0 0 0 1 3454 3461 0 5 3455 3457 3458 3459 3460 0 1 3456 1 0 3606 0 0 0 0 538
/**
 * This is a convenience class to specialize ConfigVariable as a set of
 * floating-point types representing a color value.
 *
 * It interprets the color differently depending on how many words were
 * specified: if only one, it is interpreted as a shade of gray with alpha 1.
 * If two values were specified, a grayscale and alpha pair.  If three, a set
 * of R, G, B values with alpha 1, and if four, a complete RGBA color.
 *
 * This isn't defined in dtool because it relies on the LColor class, which is
 * defined in linmath.
 */

3606 14 ConfigVariable 0 2049 14 ConfigVariable 14 ConfigVariable 0 0 0 0 0 0 0 0 0 0 0 0 415
/**
 * This is a generic, untyped ConfigVariable.  It is also the base class for
 * the typed ConfigVariables, and contains all of the code common to
 * ConfigVariables of all types (except ConfigVariableList, which is a bit of
 * a special case).
 *
 * Mostly, this class serves as a thin wrapper around ConfigVariableCore
 * and/or ConfigDeclaration, more or less duplicating the interface presented
 * there.
 */

3607 13 MathNumbers * 0 8576 13 MathNumbers * 13 MathNumbers * 0 0 3462 0 0 0 0 0 0 0 0 0 0

3608 19 MathNumbers const * 0 8576 19 MathNumbers const * 19 MathNumbers const * 0 0 3609 0 0 0 0 0 0 0 0 0 0

3609 17 MathNumbers const 0 8832 17 MathNumbers const 17 MathNumbers const 0 0 3462 0 0 0 0 0 0 0 0 0 0

3610 12 LVecBase2f * 0 8576 12 LVecBase2f * 12 LVecBase2f * 0 0 3463 0 0 0 0 0 0 0 0 0 0

3611 18 LVecBase2f const * 0 8576 18 LVecBase2f const * 18 LVecBase2f const * 0 0 3612 0 0 0 0 0 0 0 0 0 0

3612 16 LVecBase2f const 0 8832 16 LVecBase2f const 16 LVecBase2f const 0 0 3463 0 0 0 0 0 0 0 0 0 0

3613 6 size_t 0 2105344 11 std::size_t 11 std::size_t 0 0 3614 0 0 0 0 0 0 0 0 0 0

3614 17 unsigned long int 0 8214 17 unsigned long int 17 unsigned long int 0 1 0 0 0 0 0 0 0 0 0 0 0

3615 4 void 0 8194 4 void 4 void 0 6 0 0 0 0 0 0 0 0 0 0 0

3616 10 PyObject * 0 8576 10 PyObject * 10 PyObject * 0 0 3617 0 0 0 0 0 0 0 0 0 0

3617 8 PyObject 0 2105344 8 PyObject 8 PyObject 0 0 3618 0 0 0 0 0 0 0 0 0 0

3618 7 _object 0 1024 7 _object 7 _object 0 0 0 0 0 0 0 0 0 0 0 0 0

3619 13 atomic string 0 2 13 atomic string 13 atomic string 0 7 0 0 0 0 0 0 0 0 0 0 0

3620 4 bool 0 8194 4 bool 4 bool 0 4 0 0 0 0 0 0 0 0 0 0 0

3621 23 ChecksumHashGenerator * 0 8576 23 ChecksumHashGenerator * 23 ChecksumHashGenerator * 0 0 3622 0 0 0 0 0 0 0 0 0 0

3622 21 ChecksumHashGenerator 0 2048 21 ChecksumHashGenerator 21 ChecksumHashGenerator 0 0 0 0 0 0 0 0 0 0 0 0 125
/**
 * This is a specific kind of HashGenerator that simply adds up all of the
 * ints.  Nothing fancy, and pretty quick.
 */

3623 9 ostream * 0 8576 9 ostream * 9 ostream * 0 0 3624 0 0 0 0 0 0 0 0 0 0

3624 7 ostream 0 2048 7 ostream 7 ostream 0 0 0 0 0 0 0 0 0 0 0 0 0

3625 10 Datagram * 0 8576 10 Datagram * 10 Datagram * 0 0 3626 0 0 0 0 0 0 0 0 0 0

3626 8 Datagram 0 2048 8 Datagram 8 Datagram 0 0 0 0 0 0 0 0 0 0 0 0 565
/**
 * An ordered list of data elements, formatted in memory for transmission over
 * a socket or writing to a data file.
 *
 * Data elements should be added one at a time, in order, to the Datagram.
 * The nature and contents of the data elements are totally up to the user.
 * When a Datagram has been transmitted and received, its data elements may be
 * extracted using a DatagramIterator; it is up to the caller to know the
 * correct type of each data element in order.
 *
 * A Datagram is itself headerless; it is simply a collection of data
 * elements.
 */

3627 18 DatagramIterator * 0 8576 18 DatagramIterator * 18 DatagramIterator * 0 0 3628 0 0 0 0 0 0 0 0 0 0

3628 16 DatagramIterator 0 2048 16 DatagramIterator 16 DatagramIterator 0 0 0 0 0 0 0 0 0 0 0 0 215
/**
 * A class to retrieve the individual data elements previously stored in a
 * Datagram.  Elements may be retrieved one at a time; it is up to the caller
 * to know the correct type and order of each element.
 */

3629 10 TypeHandle 0 2048 10 TypeHandle 10 TypeHandle 0 0 0 0 0 0 0 0 0 0 0 0 732
/**
 * TypeHandle is the identifier used to differentiate C++ class types.  Any
 * C++ classes that inherit from some base class, and must be differentiated
 * at run time, should store a static TypeHandle object that can be queried
 * through a static member function named get_class_type().  Most of the time,
 * it is also desirable to inherit from TypedObject, which provides some
 * virtual functions to return the TypeHandle for a particular instance.
 *
 * At its essence, a TypeHandle is simply a unique identifier that is assigned
 * by the TypeRegistry.  The TypeRegistry stores a tree of TypeHandles, so
 * that ancestry of a particular type may be queried, and the type name may be
 * retrieved for run-time display.
 */

3630 12 TypeHandle * 0 8576 12 TypeHandle * 12 TypeHandle * 0 0 3629 0 0 0 0 0 0 0 0 0 0

3631 12 LVecBase2d * 0 8576 12 LVecBase2d * 12 LVecBase2d * 0 0 3466 0 0 0 0 0 0 0 0 0 0

3632 18 LVecBase2d const * 0 8576 18 LVecBase2d const * 18 LVecBase2d const * 0 0 3633 0 0 0 0 0 0 0 0 0 0

3633 16 LVecBase2d const 0 8832 16 LVecBase2d const 16 LVecBase2d const 0 0 3466 0 0 0 0 0 0 0 0 0 0

3634 12 LVecBase2i * 0 8576 12 LVecBase2i * 12 LVecBase2i * 0 0 3469 0 0 0 0 0 0 0 0 0 0

3635 18 LVecBase2i const * 0 8576 18 LVecBase2i const * 18 LVecBase2i const * 0 0 3636 0 0 0 0 0 0 0 0 0 0

3636 16 LVecBase2i const 0 8832 16 LVecBase2i const 16 LVecBase2i const 0 0 3469 0 0 0 0 0 0 0 0 0 0

3637 11 LVector2f * 0 8576 11 LVector2f * 11 LVector2f * 0 0 3472 0 0 0 0 0 0 0 0 0 0

3638 17 LVector2f const * 0 8576 17 LVector2f const * 17 LVector2f const * 0 0 3639 0 0 0 0 0 0 0 0 0 0

3639 15 LVector2f const 0 8832 15 LVector2f const 15 LVector2f const 0 0 3472 0 0 0 0 0 0 0 0 0 0

3640 11 LVector2d * 0 8576 11 LVector2d * 11 LVector2d * 0 0 3473 0 0 0 0 0 0 0 0 0 0

3641 17 LVector2d const * 0 8576 17 LVector2d const * 17 LVector2d const * 0 0 3642 0 0 0 0 0 0 0 0 0 0

3642 15 LVector2d const 0 8832 15 LVector2d const 15 LVector2d const 0 0 3473 0 0 0 0 0 0 0 0 0 0

3643 11 LVector2i * 0 8576 11 LVector2i * 11 LVector2i * 0 0 3474 0 0 0 0 0 0 0 0 0 0

3644 17 LVector2i const * 0 8576 17 LVector2i const * 17 LVector2i const * 0 0 3645 0 0 0 0 0 0 0 0 0 0

3645 15 LVector2i const 0 8832 15 LVector2i const 15 LVector2i const 0 0 3474 0 0 0 0 0 0 0 0 0 0

3646 10 LPoint2f * 0 8576 10 LPoint2f * 10 LPoint2f * 0 0 3475 0 0 0 0 0 0 0 0 0 0

3647 16 LPoint2f const * 0 8576 16 LPoint2f const * 16 LPoint2f const * 0 0 3648 0 0 0 0 0 0 0 0 0 0

3648 14 LPoint2f const 0 8832 14 LPoint2f const 14 LPoint2f const 0 0 3475 0 0 0 0 0 0 0 0 0 0

3649 10 LPoint2d * 0 8576 10 LPoint2d * 10 LPoint2d * 0 0 3476 0 0 0 0 0 0 0 0 0 0

3650 16 LPoint2d const * 0 8576 16 LPoint2d const * 16 LPoint2d const * 0 0 3651 0 0 0 0 0 0 0 0 0 0

3651 14 LPoint2d const 0 8832 14 LPoint2d const 14 LPoint2d const 0 0 3476 0 0 0 0 0 0 0 0 0 0

3652 10 LPoint2i * 0 8576 10 LPoint2i * 10 LPoint2i * 0 0 3477 0 0 0 0 0 0 0 0 0 0

3653 16 LPoint2i const * 0 8576 16 LPoint2i const * 16 LPoint2i const * 0 0 3654 0 0 0 0 0 0 0 0 0 0

3654 14 LPoint2i const 0 8832 14 LPoint2i const 14 LPoint2i const 0 0 3477 0 0 0 0 0 0 0 0 0 0

3655 12 LVecBase3f * 0 8576 12 LVecBase3f * 12 LVecBase3f * 0 0 3478 0 0 0 0 0 0 0 0 0 0

3656 18 LVecBase3f const * 0 8576 18 LVecBase3f const * 18 LVecBase3f const * 0 0 3657 0 0 0 0 0 0 0 0 0 0

3657 16 LVecBase3f const 0 8832 16 LVecBase3f const 16 LVecBase3f const 0 0 3478 0 0 0 0 0 0 0 0 0 0

3658 12 LVecBase3d * 0 8576 12 LVecBase3d * 12 LVecBase3d * 0 0 3480 0 0 0 0 0 0 0 0 0 0

3659 18 LVecBase3d const * 0 8576 18 LVecBase3d const * 18 LVecBase3d const * 0 0 3660 0 0 0 0 0 0 0 0 0 0

3660 16 LVecBase3d const 0 8832 16 LVecBase3d const 16 LVecBase3d const 0 0 3480 0 0 0 0 0 0 0 0 0 0

3661 12 LVecBase3i * 0 8576 12 LVecBase3i * 12 LVecBase3i * 0 0 3482 0 0 0 0 0 0 0 0 0 0

3662 18 LVecBase3i const * 0 8576 18 LVecBase3i const * 18 LVecBase3i const * 0 0 3663 0 0 0 0 0 0 0 0 0 0

3663 16 LVecBase3i const 0 8832 16 LVecBase3i const 16 LVecBase3i const 0 0 3482 0 0 0 0 0 0 0 0 0 0

3664 11 LVector3f * 0 8576 11 LVector3f * 11 LVector3f * 0 0 3485 0 0 0 0 0 0 0 0 0 0

3665 17 LVector3f const * 0 8576 17 LVector3f const * 17 LVector3f const * 0 0 3666 0 0 0 0 0 0 0 0 0 0

3666 15 LVector3f const 0 8832 15 LVector3f const 15 LVector3f const 0 0 3485 0 0 0 0 0 0 0 0 0 0

3667 11 LVector3d * 0 8576 11 LVector3d * 11 LVector3d * 0 0 3486 0 0 0 0 0 0 0 0 0 0

3668 17 LVector3d const * 0 8576 17 LVector3d const * 17 LVector3d const * 0 0 3669 0 0 0 0 0 0 0 0 0 0

3669 15 LVector3d const 0 8832 15 LVector3d const 15 LVector3d const 0 0 3486 0 0 0 0 0 0 0 0 0 0

3670 11 LVector3i * 0 8576 11 LVector3i * 11 LVector3i * 0 0 3487 0 0 0 0 0 0 0 0 0 0

3671 17 LVector3i const * 0 8576 17 LVector3i const * 17 LVector3i const * 0 0 3672 0 0 0 0 0 0 0 0 0 0

3672 15 LVector3i const 0 8832 15 LVector3i const 15 LVector3i const 0 0 3487 0 0 0 0 0 0 0 0 0 0

3673 10 LPoint3f * 0 8576 10 LPoint3f * 10 LPoint3f * 0 0 3488 0 0 0 0 0 0 0 0 0 0

3674 16 LPoint3f const * 0 8576 16 LPoint3f const * 16 LPoint3f const * 0 0 3675 0 0 0 0 0 0 0 0 0 0

3675 14 LPoint3f const 0 8832 14 LPoint3f const 14 LPoint3f const 0 0 3488 0 0 0 0 0 0 0 0 0 0

3676 10 LPoint3d * 0 8576 10 LPoint3d * 10 LPoint3d * 0 0 3489 0 0 0 0 0 0 0 0 0 0

3677 16 LPoint3d const * 0 8576 16 LPoint3d const * 16 LPoint3d const * 0 0 3678 0 0 0 0 0 0 0 0 0 0

3678 14 LPoint3d const 0 8832 14 LPoint3d const 14 LPoint3d const 0 0 3489 0 0 0 0 0 0 0 0 0 0

3679 10 LPoint3i * 0 8576 10 LPoint3i * 10 LPoint3i * 0 0 3490 0 0 0 0 0 0 0 0 0 0

3680 16 LPoint3i const * 0 8576 16 LPoint3i const * 16 LPoint3i const * 0 0 3681 0 0 0 0 0 0 0 0 0 0

3681 14 LPoint3i const 0 8832 14 LPoint3i const 14 LPoint3i const 0 0 3490 0 0 0 0 0 0 0 0 0 0

3682 12 LVecBase4f * 0 8576 12 LVecBase4f * 12 LVecBase4f * 0 0 3491 0 0 0 0 0 0 0 0 0 0

3683 18 LVecBase4f const * 0 8576 18 LVecBase4f const * 18 LVecBase4f const * 0 0 3684 0 0 0 0 0 0 0 0 0 0

3684 16 LVecBase4f const 0 8832 16 LVecBase4f const 16 LVecBase4f const 0 0 3491 0 0 0 0 0 0 0 0 0 0

3685 27 UnalignedLVecBase4f const * 0 8576 27 UnalignedLVecBase4f const * 27 UnalignedLVecBase4f const * 0 0 3686 0 0 0 0 0 0 0 0 0 0

3686 25 UnalignedLVecBase4f const 0 8832 25 UnalignedLVecBase4f const 25 UnalignedLVecBase4f const 0 0 3493 0 0 0 0 0 0 0 0 0 0

3687 21 UnalignedLVecBase4f * 0 8576 21 UnalignedLVecBase4f * 21 UnalignedLVecBase4f * 0 0 3493 0 0 0 0 0 0 0 0 0 0

3688 12 LVecBase4d * 0 8576 12 LVecBase4d * 12 LVecBase4d * 0 0 3495 0 0 0 0 0 0 0 0 0 0

3689 18 LVecBase4d const * 0 8576 18 LVecBase4d const * 18 LVecBase4d const * 0 0 3690 0 0 0 0 0 0 0 0 0 0

3690 16 LVecBase4d const 0 8832 16 LVecBase4d const 16 LVecBase4d const 0 0 3495 0 0 0 0 0 0 0 0 0 0

3691 27 UnalignedLVecBase4d const * 0 8576 27 UnalignedLVecBase4d const * 27 UnalignedLVecBase4d const * 0 0 3692 0 0 0 0 0 0 0 0 0 0

3692 25 UnalignedLVecBase4d const 0 8832 25 UnalignedLVecBase4d const 25 UnalignedLVecBase4d const 0 0 3497 0 0 0 0 0 0 0 0 0 0

3693 21 UnalignedLVecBase4d * 0 8576 21 UnalignedLVecBase4d * 21 UnalignedLVecBase4d * 0 0 3497 0 0 0 0 0 0 0 0 0 0

3694 12 LVecBase4i * 0 8576 12 LVecBase4i * 12 LVecBase4i * 0 0 3499 0 0 0 0 0 0 0 0 0 0

3695 18 LVecBase4i const * 0 8576 18 LVecBase4i const * 18 LVecBase4i const * 0 0 3696 0 0 0 0 0 0 0 0 0 0

3696 16 LVecBase4i const 0 8832 16 LVecBase4i const 16 LVecBase4i const 0 0 3499 0 0 0 0 0 0 0 0 0 0

3697 27 UnalignedLVecBase4i const * 0 8576 27 UnalignedLVecBase4i const * 27 UnalignedLVecBase4i const * 0 0 3698 0 0 0 0 0 0 0 0 0 0

3698 25 UnalignedLVecBase4i const 0 8832 25 UnalignedLVecBase4i const 25 UnalignedLVecBase4i const 0 0 3501 0 0 0 0 0 0 0 0 0 0

3699 21 UnalignedLVecBase4i * 0 8576 21 UnalignedLVecBase4i * 21 UnalignedLVecBase4i * 0 0 3501 0 0 0 0 0 0 0 0 0 0

3700 11 LVector4f * 0 8576 11 LVector4f * 11 LVector4f * 0 0 3503 0 0 0 0 0 0 0 0 0 0

3701 17 LVector4f const * 0 8576 17 LVector4f const * 17 LVector4f const * 0 0 3702 0 0 0 0 0 0 0 0 0 0

3702 15 LVector4f const 0 8832 15 LVector4f const 15 LVector4f const 0 0 3503 0 0 0 0 0 0 0 0 0 0

3703 11 LVector4d * 0 8576 11 LVector4d * 11 LVector4d * 0 0 3504 0 0 0 0 0 0 0 0 0 0

3704 17 LVector4d const * 0 8576 17 LVector4d const * 17 LVector4d const * 0 0 3705 0 0 0 0 0 0 0 0 0 0

3705 15 LVector4d const 0 8832 15 LVector4d const 15 LVector4d const 0 0 3504 0 0 0 0 0 0 0 0 0 0

3706 11 LVector4i * 0 8576 11 LVector4i * 11 LVector4i * 0 0 3505 0 0 0 0 0 0 0 0 0 0

3707 17 LVector4i const * 0 8576 17 LVector4i const * 17 LVector4i const * 0 0 3708 0 0 0 0 0 0 0 0 0 0

3708 15 LVector4i const 0 8832 15 LVector4i const 15 LVector4i const 0 0 3505 0 0 0 0 0 0 0 0 0 0

3709 10 LPoint4f * 0 8576 10 LPoint4f * 10 LPoint4f * 0 0 3506 0 0 0 0 0 0 0 0 0 0

3710 16 LPoint4f const * 0 8576 16 LPoint4f const * 16 LPoint4f const * 0 0 3711 0 0 0 0 0 0 0 0 0 0

3711 14 LPoint4f const 0 8832 14 LPoint4f const 14 LPoint4f const 0 0 3506 0 0 0 0 0 0 0 0 0 0

3712 10 LPoint4d * 0 8576 10 LPoint4d * 10 LPoint4d * 0 0 3507 0 0 0 0 0 0 0 0 0 0

3713 16 LPoint4d const * 0 8576 16 LPoint4d const * 16 LPoint4d const * 0 0 3714 0 0 0 0 0 0 0 0 0 0

3714 14 LPoint4d const 0 8832 14 LPoint4d const 14 LPoint4d const 0 0 3507 0 0 0 0 0 0 0 0 0 0

3715 10 LPoint4i * 0 8576 10 LPoint4i * 10 LPoint4i * 0 0 3508 0 0 0 0 0 0 0 0 0 0

3716 16 LPoint4i const * 0 8576 16 LPoint4i const * 16 LPoint4i const * 0 0 3717 0 0 0 0 0 0 0 0 0 0

3717 14 LPoint4i const 0 8832 14 LPoint4i const 14 LPoint4i const 0 0 3508 0 0 0 0 0 0 0 0 0 0

3718 11 LMatrix3f * 0 8576 11 LMatrix3f * 11 LMatrix3f * 0 0 3509 0 0 0 0 0 0 0 0 0 0

3719 17 LMatrix3f const * 0 8576 17 LMatrix3f const * 17 LMatrix3f const * 0 0 3720 0 0 0 0 0 0 0 0 0 0

3720 15 LMatrix3f const 0 8832 15 LMatrix3f const 15 LMatrix3f const 0 0 3509 0 0 0 0 0 0 0 0 0 0

3721 5 Row * 0 8576 16 LMatrix3f::Row * 16 LMatrix3f::Row * 0 0 3511 0 0 0 0 0 0 0 0 0 0

3722 6 CRow * 0 8576 17 LMatrix3f::CRow * 17 LMatrix3f::CRow * 0 0 3512 0 0 0 0 0 0 0 0 0 0

3723 17 LMatrix4f const * 0 8576 17 LMatrix4f const * 17 LMatrix4f const * 0 0 3724 0 0 0 0 0 0 0 0 0 0

3724 15 LMatrix4f const 0 8832 15 LMatrix4f const 15 LMatrix4f const 0 0 3513 0 0 0 0 0 0 0 0 0 0

3725 11 Row const * 0 8576 22 LMatrix3f::Row const * 22 LMatrix3f::Row const * 0 0 3726 0 0 0 0 0 0 0 0 0 0

3726 9 Row const 0 8832 20 LMatrix3f::Row const 20 LMatrix3f::Row const 0 0 3511 0 0 0 0 0 0 0 0 0 0

3727 12 CRow const * 0 8576 23 LMatrix3f::CRow const * 23 LMatrix3f::CRow const * 0 0 3728 0 0 0 0 0 0 0 0 0 0

3728 10 CRow const 0 8832 21 LMatrix3f::CRow const 21 LMatrix3f::CRow const 0 0 3512 0 0 0 0 0 0 0 0 0 0

3729 11 LMatrix4f * 0 8576 11 LMatrix4f * 11 LMatrix4f * 0 0 3513 0 0 0 0 0 0 0 0 0 0

3730 26 UnalignedLMatrix4f const * 0 8576 26 UnalignedLMatrix4f const * 26 UnalignedLMatrix4f const * 0 0 3731 0 0 0 0 0 0 0 0 0 0

3731 24 UnalignedLMatrix4f const 0 8832 24 UnalignedLMatrix4f const 24 UnalignedLMatrix4f const 0 0 3517 0 0 0 0 0 0 0 0 0 0

3732 5 Row * 0 8576 16 LMatrix4f::Row * 16 LMatrix4f::Row * 0 0 3515 0 0 0 0 0 0 0 0 0 0

3733 6 CRow * 0 8576 17 LMatrix4f::CRow * 17 LMatrix4f::CRow * 0 0 3516 0 0 0 0 0 0 0 0 0 0

3734 11 Row const * 0 8576 22 LMatrix4f::Row const * 22 LMatrix4f::Row const * 0 0 3735 0 0 0 0 0 0 0 0 0 0

3735 9 Row const 0 8832 20 LMatrix4f::Row const 20 LMatrix4f::Row const 0 0 3515 0 0 0 0 0 0 0 0 0 0

3736 12 CRow const * 0 8576 23 LMatrix4f::CRow const * 23 LMatrix4f::CRow const * 0 0 3737 0 0 0 0 0 0 0 0 0 0

3737 10 CRow const 0 8832 21 LMatrix4f::CRow const 21 LMatrix4f::CRow const 0 0 3516 0 0 0 0 0 0 0 0 0 0

3738 20 UnalignedLMatrix4f * 0 8576 20 UnalignedLMatrix4f * 20 UnalignedLMatrix4f * 0 0 3517 0 0 0 0 0 0 0 0 0 0

3739 11 LMatrix3d * 0 8576 11 LMatrix3d * 11 LMatrix3d * 0 0 3519 0 0 0 0 0 0 0 0 0 0

3740 17 LMatrix3d const * 0 8576 17 LMatrix3d const * 17 LMatrix3d const * 0 0 3741 0 0 0 0 0 0 0 0 0 0

3741 15 LMatrix3d const 0 8832 15 LMatrix3d const 15 LMatrix3d const 0 0 3519 0 0 0 0 0 0 0 0 0 0

3742 5 Row * 0 8576 16 LMatrix3d::Row * 16 LMatrix3d::Row * 0 0 3521 0 0 0 0 0 0 0 0 0 0

3743 6 CRow * 0 8576 17 LMatrix3d::CRow * 17 LMatrix3d::CRow * 0 0 3522 0 0 0 0 0 0 0 0 0 0

3744 17 LMatrix4d const * 0 8576 17 LMatrix4d const * 17 LMatrix4d const * 0 0 3745 0 0 0 0 0 0 0 0 0 0

3745 15 LMatrix4d const 0 8832 15 LMatrix4d const 15 LMatrix4d const 0 0 3523 0 0 0 0 0 0 0 0 0 0

3746 11 Row const * 0 8576 22 LMatrix3d::Row const * 22 LMatrix3d::Row const * 0 0 3747 0 0 0 0 0 0 0 0 0 0

3747 9 Row const 0 8832 20 LMatrix3d::Row const 20 LMatrix3d::Row const 0 0 3521 0 0 0 0 0 0 0 0 0 0

3748 12 CRow const * 0 8576 23 LMatrix3d::CRow const * 23 LMatrix3d::CRow const * 0 0 3749 0 0 0 0 0 0 0 0 0 0

3749 10 CRow const 0 8832 21 LMatrix3d::CRow const 21 LMatrix3d::CRow const 0 0 3522 0 0 0 0 0 0 0 0 0 0

3750 11 LMatrix4d * 0 8576 11 LMatrix4d * 11 LMatrix4d * 0 0 3523 0 0 0 0 0 0 0 0 0 0

3751 26 UnalignedLMatrix4d const * 0 8576 26 UnalignedLMatrix4d const * 26 UnalignedLMatrix4d const * 0 0 3752 0 0 0 0 0 0 0 0 0 0

3752 24 UnalignedLMatrix4d const 0 8832 24 UnalignedLMatrix4d const 24 UnalignedLMatrix4d const 0 0 3527 0 0 0 0 0 0 0 0 0 0

3753 5 Row * 0 8576 16 LMatrix4d::Row * 16 LMatrix4d::Row * 0 0 3525 0 0 0 0 0 0 0 0 0 0

3754 6 CRow * 0 8576 17 LMatrix4d::CRow * 17 LMatrix4d::CRow * 0 0 3526 0 0 0 0 0 0 0 0 0 0

3755 11 Row const * 0 8576 22 LMatrix4d::Row const * 22 LMatrix4d::Row const * 0 0 3756 0 0 0 0 0 0 0 0 0 0

3756 9 Row const 0 8832 20 LMatrix4d::Row const 20 LMatrix4d::Row const 0 0 3525 0 0 0 0 0 0 0 0 0 0

3757 12 CRow const * 0 8576 23 LMatrix4d::CRow const * 23 LMatrix4d::CRow const * 0 0 3758 0 0 0 0 0 0 0 0 0 0

3758 10 CRow const 0 8832 21 LMatrix4d::CRow const 21 LMatrix4d::CRow const 0 0 3526 0 0 0 0 0 0 0 0 0 0

3759 20 UnalignedLMatrix4d * 0 8576 20 UnalignedLMatrix4d * 20 UnalignedLMatrix4d * 0 0 3527 0 0 0 0 0 0 0 0 0 0

3760 14 LQuaternionf * 0 8576 14 LQuaternionf * 14 LQuaternionf * 0 0 3529 0 0 0 0 0 0 0 0 0 0

3761 20 LQuaternionf const * 0 8576 20 LQuaternionf const * 20 LQuaternionf const * 0 0 3762 0 0 0 0 0 0 0 0 0 0

3762 18 LQuaternionf const 0 8832 18 LQuaternionf const 18 LQuaternionf const 0 0 3529 0 0 0 0 0 0 0 0 0 0

3763 14 LQuaterniond * 0 8576 14 LQuaterniond * 14 LQuaterniond * 0 0 3530 0 0 0 0 0 0 0 0 0 0

3764 20 LQuaterniond const * 0 8576 20 LQuaterniond const * 20 LQuaterniond const * 0 0 3765 0 0 0 0 0 0 0 0 0 0

3765 18 LQuaterniond const 0 8832 18 LQuaterniond const 18 LQuaterniond const 0 0 3530 0 0 0 0 0 0 0 0 0 0

3766 12 LRotationf * 0 8576 12 LRotationf * 12 LRotationf * 0 0 3531 0 0 0 0 0 0 0 0 0 0

3767 18 LRotationf const * 0 8576 18 LRotationf const * 18 LRotationf const * 0 0 3768 0 0 0 0 0 0 0 0 0 0

3768 16 LRotationf const 0 8832 16 LRotationf const 16 LRotationf const 0 0 3531 0 0 0 0 0 0 0 0 0 0

3769 12 LRotationd * 0 8576 12 LRotationd * 12 LRotationd * 0 0 3532 0 0 0 0 0 0 0 0 0 0

3770 18 LRotationd const * 0 8576 18 LRotationd const * 18 LRotationd const * 0 0 3771 0 0 0 0 0 0 0 0 0 0

3771 16 LRotationd const 0 8832 16 LRotationd const 16 LRotationd const 0 0 3532 0 0 0 0 0 0 0 0 0 0

3772 15 LOrientationf * 0 8576 15 LOrientationf * 15 LOrientationf * 0 0 3533 0 0 0 0 0 0 0 0 0 0

3773 21 LOrientationf const * 0 8576 21 LOrientationf const * 21 LOrientationf const * 0 0 3774 0 0 0 0 0 0 0 0 0 0

3774 19 LOrientationf const 0 8832 19 LOrientationf const 19 LOrientationf const 0 0 3533 0 0 0 0 0 0 0 0 0 0

3775 15 LOrientationd * 0 8576 15 LOrientationd * 15 LOrientationd * 0 0 3534 0 0 0 0 0 0 0 0 0 0

3776 21 LOrientationd const * 0 8576 21 LOrientationd const * 21 LOrientationd const * 0 0 3777 0 0 0 0 0 0 0 0 0 0

3777 19 LOrientationd const 0 8832 19 LOrientationd const 19 LOrientationd const 0 0 3534 0 0 0 0 0 0 0 0 0 0

3778 27 ConfigVariableColor const * 0 8576 27 ConfigVariableColor const * 27 ConfigVariableColor const * 0 0 3779 0 0 0 0 0 0 0 0 0 0

3779 25 ConfigVariableColor const 0 8832 25 ConfigVariableColor const 25 ConfigVariableColor const 0 0 3605 0 0 0 0 0 0 0 0 0 0

3780 21 ConfigVariableColor * 0 8576 21 ConfigVariableColor * 21 ConfigVariableColor * 0 0 3605 0 0 0 0 0 0 0 0 0 0

3781 14 LColor const * 0 8576 14 LColor const * 14 LColor const * 0 0 3782 0 0 0 0 0 0 0 0 0 0

3782 12 LColor const 0 8832 12 LColor const 12 LColor const 0 0 3589 0 0 0 0 0 0 0 0 0 0

3783 11 PN_stdfloat 0 2105344 11 PN_stdfloat 11 PN_stdfloat 0 0 3465 0 0 0 0 0 0 0 0 0 0

3784 8 LColor * 0 8576 8 LColor * 8 LColor * 0 0 3589 0 0 0 0 0 0 0 0 0 0

3785 38 double const [::num_matrix_components] 0 4202496 38 double const [::num_matrix_components] 38 double const [::num_matrix_components] 0 0 3786 12 0 0 0 0 0 0 0 0 0 0

3786 12 double const 0 8832 12 double const 12 double const 0 0 3468 0 0 0 0 0 0 0 0 0 0

3787 37 float const [::num_matrix_components] 0 4202496 37 float const [::num_matrix_components] 37 float const [::num_matrix_components] 0 0 3788 12 0 0 0 0 0 0 0 0 0 0

3788 11 float const 0 8832 11 float const 11 float const 0 0 3465 0 0 0 0 0 0 0 0 0 0

3789 32 double [::num_matrix_components] 0 4202496 32 double [::num_matrix_components] 32 double [::num_matrix_components] 0 0 3468 12 0 0 0 0 0 0 0 0 0 0

3790 31 float [::num_matrix_components] 0 4202496 31 float [::num_matrix_components] 31 float [::num_matrix_components] 0 0 3465 12 0 0 0 0 0 0 0 0 0 0

0
77
3791 1 x 0 6 3465 1956 1958 0 0 0 0 13 LVecBase2f::x 0

3792 1 y 0 6 3465 1957 1959 0 0 0 0 13 LVecBase2f::y 0

3793 1 x 0 6 3468 2019 2021 0 0 0 0 13 LVecBase2d::x 0

3794 1 y 0 6 3468 2020 2022 0 0 0 0 13 LVecBase2d::y 0

3795 1 x 0 6 3471 2082 2084 0 0 0 0 13 LVecBase2i::x 0

3796 1 y 0 6 3471 2083 2085 0 0 0 0 13 LVecBase2i::y 0

3797 1 x 0 6 3465 2237 2241 0 0 0 0 13 LVecBase3f::x 0

3798 1 y 0 6 3465 2238 2242 0 0 0 0 13 LVecBase3f::y 0

3799 1 z 0 6 3465 2239 2243 0 0 0 0 13 LVecBase3f::z 0

3800 2 xy 0 2 3463 2244 0 0 0 0 0 14 LVecBase3f::xy 0

3801 2 xz 0 2 3463 2245 0 0 0 0 0 14 LVecBase3f::xz 0

3802 2 yz 0 2 3463 2246 0 0 0 0 0 14 LVecBase3f::yz 0

3803 1 x 0 6 3468 2310 2314 0 0 0 0 13 LVecBase3d::x 0

3804 1 y 0 6 3468 2311 2315 0 0 0 0 13 LVecBase3d::y 0

3805 1 z 0 6 3468 2312 2316 0 0 0 0 13 LVecBase3d::z 0

3806 2 xy 0 2 3466 2317 0 0 0 0 0 14 LVecBase3d::xy 0

3807 2 xz 0 2 3466 2318 0 0 0 0 0 14 LVecBase3d::xz 0

3808 2 yz 0 2 3466 2319 0 0 0 0 0 14 LVecBase3d::yz 0

3809 1 x 0 6 3471 2383 2387 0 0 0 0 13 LVecBase3i::x 0

3810 1 y 0 6 3471 2384 2388 0 0 0 0 13 LVecBase3i::y 0

3811 1 z 0 6 3471 2385 2389 0 0 0 0 13 LVecBase3i::z 0

3812 2 xy 0 2 3469 2390 0 0 0 0 0 14 LVecBase3i::xy 0

3813 2 xz 0 2 3469 2391 0 0 0 0 0 14 LVecBase3i::xz 0

3814 2 yz 0 2 3469 2392 0 0 0 0 0 14 LVecBase3i::yz 0

3815 2 xy 0 2 3472 2446 0 0 0 0 0 13 LVector3f::xy 0

3816 2 xz 0 2 3472 2447 0 0 0 0 0 13 LVector3f::xz 0

3817 2 yz 0 2 3472 2448 0 0 0 0 0 13 LVector3f::yz 0

3818 2 xy 0 2 3473 2480 0 0 0 0 0 13 LVector3d::xy 0

3819 2 xz 0 2 3473 2481 0 0 0 0 0 13 LVector3d::xz 0

3820 2 yz 0 2 3473 2482 0 0 0 0 0 13 LVector3d::yz 0

3821 2 xy 0 2 3474 2514 0 0 0 0 0 13 LVector3i::xy 0

3822 2 xz 0 2 3474 2515 0 0 0 0 0 13 LVector3i::xz 0

3823 2 yz 0 2 3474 2516 0 0 0 0 0 13 LVector3i::yz 0

3824 2 xy 0 2 3475 2540 0 0 0 0 0 12 LPoint3f::xy 0

3825 2 xz 0 2 3475 2541 0 0 0 0 0 12 LPoint3f::xz 0

3826 2 yz 0 2 3475 2542 0 0 0 0 0 12 LPoint3f::yz 0

3827 2 xy 0 2 3476 2563 0 0 0 0 0 12 LPoint3d::xy 0

3828 2 xz 0 2 3476 2564 0 0 0 0 0 12 LPoint3d::xz 0

3829 2 yz 0 2 3476 2565 0 0 0 0 0 12 LPoint3d::yz 0

3830 2 xy 0 2 3477 2586 0 0 0 0 0 12 LPoint3i::xy 0

3831 2 xz 0 2 3477 2587 0 0 0 0 0 12 LPoint3i::xz 0

3832 2 yz 0 2 3477 2588 0 0 0 0 0 12 LPoint3i::yz 0

3833 1 x 0 6 3465 2618 2624 0 0 0 0 13 LVecBase4f::x 0

3834 1 y 0 6 3465 2619 2625 0 0 0 0 13 LVecBase4f::y 0

3835 1 z 0 6 3465 2620 2626 0 0 0 0 13 LVecBase4f::z 0

3836 3 xyz 0 2 3478 2622 0 0 0 0 0 15 LVecBase4f::xyz 0

3837 2 xy 0 2 3463 2623 0 0 0 0 0 14 LVecBase4f::xy 0

3838 1 x 0 6 3468 2700 2706 0 0 0 0 13 LVecBase4d::x 0

3839 1 y 0 6 3468 2701 2707 0 0 0 0 13 LVecBase4d::y 0

3840 1 z 0 6 3468 2702 2708 0 0 0 0 13 LVecBase4d::z 0

3841 3 xyz 0 2 3480 2704 0 0 0 0 0 15 LVecBase4d::xyz 0

3842 2 xy 0 2 3466 2705 0 0 0 0 0 14 LVecBase4d::xy 0

3843 1 x 0 6 3471 2782 2788 0 0 0 0 13 LVecBase4i::x 0

3844 1 y 0 6 3471 2783 2789 0 0 0 0 13 LVecBase4i::y 0

3845 1 z 0 6 3471 2784 2790 0 0 0 0 13 LVecBase4i::z 0

3846 3 xyz 0 2 3482 2786 0 0 0 0 0 15 LVecBase4i::xyz 0

3847 2 xy 0 2 3469 2787 0 0 0 0 0 14 LVecBase4i::xy 0

3848 3 xyz 0 2 3485 2850 0 0 0 0 0 14 LVector4f::xyz 0

3849 2 xy 0 2 3472 2851 0 0 0 0 0 13 LVector4f::xy 0

3850 3 xyz 0 2 3486 2870 0 0 0 0 0 14 LVector4d::xyz 0

3851 2 xy 0 2 3473 2871 0 0 0 0 0 13 LVector4d::xy 0

3852 3 xyz 0 2 3487 2890 0 0 0 0 0 14 LVector4i::xyz 0

3853 2 xy 0 2 3474 2891 0 0 0 0 0 13 LVector4i::xy 0

3854 3 xyz 0 2 3488 2908 0 0 0 0 0 13 LPoint4f::xyz 0

3855 2 xy 0 2 3475 2909 0 0 0 0 0 12 LPoint4f::xy 0

3856 3 xyz 0 2 3489 2928 0 0 0 0 0 13 LPoint4d::xyz 0

3857 2 xy 0 2 3476 2929 0 0 0 0 0 12 LPoint4d::xy 0

3858 3 xyz 0 2 3490 2948 0 0 0 0 0 13 LPoint4i::xyz 0

3859 2 xy 0 2 3477 2949 0 0 0 0 0 12 LPoint4i::xy 0

3860 4 rows 0 66 3478 2978 0 0 0 0 2975 15 LMatrix3f::rows 0

3861 4 cols 0 66 3478 2979 0 0 0 0 2975 15 LMatrix3f::cols 0

3862 4 rows 0 66 3491 3066 0 0 0 0 3063 15 LMatrix4f::rows 0

3863 4 cols 0 66 3491 3067 0 0 0 0 3063 15 LMatrix4f::cols 0

3864 4 rows 0 66 3480 3166 0 0 0 0 3163 15 LMatrix3d::rows 0

3865 4 cols 0 66 3480 3167 0 0 0 0 3163 15 LMatrix3d::cols 0

3866 4 rows 0 66 3495 3252 0 0 0 0 3249 15 LMatrix4d::rows 0

3867 4 cols 0 66 3495 3253 0 0 0 0 3249 15 LMatrix4d::cols 0

14
3868 8 get_rows 0 2975 2978 19 LMatrix3f::get_rows 0

3869 8 get_cols 0 2975 2979 19 LMatrix3f::get_cols 0

3870 9 get_col2s 0 2975 2981 20 LMatrix3f::get_col2s 0

3871 9 get_row2s 0 2975 2980 20 LMatrix3f::get_row2s 0

3872 8 get_rows 0 3063 3066 19 LMatrix4f::get_rows 0

3873 8 get_cols 0 3063 3067 19 LMatrix4f::get_cols 0

3874 9 get_row3s 0 3063 3068 20 LMatrix4f::get_row3s 0

3875 8 get_rows 0 3163 3166 19 LMatrix3d::get_rows 0

3876 8 get_cols 0 3163 3167 19 LMatrix3d::get_cols 0

3877 9 get_col2s 0 3163 3169 20 LMatrix3d::get_col2s 0

3878 9 get_row2s 0 3163 3168 20 LMatrix3d::get_row2s 0

3879 8 get_rows 0 3249 3252 19 LMatrix4d::get_rows 0

3880 8 get_cols 0 3249 3253 19 LMatrix4d::get_cols 0

3881 9 get_row3s 0 3249 3254 20 LMatrix4d::get_row3s 0

