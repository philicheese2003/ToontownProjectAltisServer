1494874509
3 2
11 libp3movies 4 Aas2 12 panda3d.core 
87
101 37 upcast_to_TypedWritableReferenceCount 0 12 188 49 MovieAudio::upcast_to_TypedWritableReferenceCount 0 1 7 53
upcast from MovieAudio to TypedWritableReferenceCount
85
TypedWritableReferenceCount *MovieAudio::upcast_to_TypedWritableReferenceCount(void);

102 22 downcast_to_MovieAudio 0 12 189 51 TypedWritableReferenceCount::downcast_to_MovieAudio 0 1 8 55
downcast from TypedWritableReferenceCount to MovieAudio
70
MovieAudio *TypedWritableReferenceCount::downcast_to_MovieAudio(void);

103 17 upcast_to_Namable 0 12 188 29 MovieAudio::upcast_to_Namable 0 1 9 33
upcast from MovieAudio to Namable
45
Namable *MovieAudio::upcast_to_Namable(void);

104 22 downcast_to_MovieAudio 0 12 190 31 Namable::downcast_to_MovieAudio 0 1 10 35
downcast from Namable to MovieAudio
50
MovieAudio *Namable::downcast_to_MovieAudio(void);

105 10 MovieAudio 0 4 188 22 MovieAudio::MovieAudio 0 2 1 2 200
/**
 * This constructor returns a null audio stream --- a stream of total silence,
 * at 8000 samples per second.  To get more interesting audio, you need to
 * construct a subclass of this class.
 */
125
MovieAudio::MovieAudio(std::string const &name = "Blank Audio");
inline MovieAudio::MovieAudio(MovieAudio const &) = default;

106 11 ~MovieAudio 0 6 188 23 MovieAudio::~MovieAudio 0 0 10
/**
 *
 */
38
virtual MovieAudio::~MovieAudio(void);

107 4 open 0 6 188 16 MovieAudio::open 0 1 3 56
/**
 * Open this audio, returning a MovieAudioCursor
 */
61
virtual PointerTo< MovieAudioCursor > MovieAudio::open(void);

108 3 get 0 4 188 15 MovieAudio::get 0 1 4 103
/**
 * Obtains a MovieAudio that references a file.  Just calls
 * MovieTypeRegistry::make_audio().
 */
69
static PointerTo< MovieAudio > MovieAudio::get(Filename const &name);

109 12 get_filename 0 4 188 24 MovieAudio::get_filename 0 1 5 142
/**
 * Returns the movie's filename.  A movie is not guaranteed to have a
 * filename, if not, then this function returns a null filename.
 */
60
inline Filename const &MovieAudio::get_filename(void) const;

110 14 get_class_type 0 4 188 26 MovieAudio::get_class_type 0 1 6 0
51
static TypeHandle MovieAudio::get_class_type(void);

111 9 FlacAudio 0 4 193 20 FlacAudio::FlacAudio 0 2 11 12 14
/**
 * xxx
 */
101
FlacAudio::FlacAudio(Filename const &name);
inline FlacAudio::FlacAudio(FlacAudio const &) = default;

112 4 make 0 4 193 15 FlacAudio::make 0 1 13 55
/**
 * Obtains a MovieAudio that references a file.
 */
69
static PointerTo< MovieAudio > FlacAudio::make(Filename const &name);

113 14 get_class_type 0 4 193 25 FlacAudio::get_class_type 0 1 14 0
50
static TypeHandle FlacAudio::get_class_type(void);

114 16 MovieAudioCursor 0 4 194 34 MovieAudioCursor::MovieAudioCursor 0 2 15 16 200
/**
 * This constructor returns a null audio stream --- a stream of total silence,
 * at 8000 samples per second.  To get more interesting audio, you need to
 * construct a subclass of this class.
 */
131
MovieAudioCursor::MovieAudioCursor(MovieAudio *src);
inline MovieAudioCursor::MovieAudioCursor(MovieAudioCursor const &) = default;

115 10 get_source 0 4 194 28 MovieAudioCursor::get_source 0 1 17 63
/**
 * Returns the MovieAudio which this cursor references.
 */
72
inline PointerTo< MovieAudio > MovieAudioCursor::get_source(void) const;

116 10 audio_rate 0 4 194 28 MovieAudioCursor::audio_rate 0 1 18 41
/**
 * Returns the audio sample rate.
 */
52
inline int MovieAudioCursor::audio_rate(void) const;

117 14 audio_channels 0 4 194 32 MovieAudioCursor::audio_channels 0 1 19 83
/**
 * Returns the number of audio channels (ie, two for stereo, one for mono).
 */
56
inline int MovieAudioCursor::audio_channels(void) const;

118 6 length 0 4 194 24 MovieAudioCursor::length 0 1 20 742
/**
 * Returns the length of the movie.  Attempting to read audio samples beyond
 * the specified length will produce silent samples.
 *
 * Some kinds of Movie, such as internet TV station, might not have a
 * predictable length.  In that case, the length will be set to a very large
 * number: 1.0E10.
 *
 * Some AVI files have incorrect length values encoded into them - they may be
 * a second or two long or short.  When playing such an AVI using the Movie
 * class, you may see a slightly truncated video, or a slightly elongated
 * video (padded with black frames).  There are utilities out there to fix the
 * length values in AVI files.
 *
 * An audio consumer needs to check the length, the ready status, and the
 * aborted flag.
 */
51
inline double MovieAudioCursor::length(void) const;

119 8 can_seek 0 4 194 26 MovieAudioCursor::can_seek 0 1 21 429
/**
 * Returns true if the movie can seek.  If this is true, seeking is still not
 * guaranteed to be fast: for some movies, seeking is implemented by rewinding
 * to the beginning and then fast-forwarding to the desired location.  Even if
 * the movie cannot seek, the seek method can still advance to an arbitrary
 * location by reading samples and discarding them.  However, to move
 * backward, can_seek must return true.
 */
51
inline bool MovieAudioCursor::can_seek(void) const;

120 13 can_seek_fast 0 4 194 31 MovieAudioCursor::can_seek_fast 0 1 22 61
/**
 * Returns true if seek operations are constant time.
 */
56
inline bool MovieAudioCursor::can_seek_fast(void) const;

121 4 tell 0 4 194 22 MovieAudioCursor::tell 0 1 23 54
/**
 * Returns the current offset within the file.
 */
49
inline double MovieAudioCursor::tell(void) const;

122 12 skip_samples 0 4 194 30 MovieAudioCursor::skip_samples 0 1 24 86
/**
 * Skip audio samples from the stream.  This is mostly for debugging purposes.
 */
50
inline void MovieAudioCursor::skip_samples(int n);

123 7 aborted 0 4 194 25 MovieAudioCursor::aborted 0 1 25 138
/**
 * If aborted is true, it means that the "ready" samples are not being
 * replenished.  See the method "ready" for an explanation.
 */
50
inline bool MovieAudioCursor::aborted(void) const;

124 5 ready 0 6 194 23 MovieAudioCursor::ready 0 1 26 1120
/**
 * Returns the number of audio samples that are ready to read.  This is
 * primarily relevant for sources like microphones which produce samples at a
 * fixed rate.  If you try to read more samples than are ready, the result
 * will be silent samples.
 *
 * Some audio streams do not have a limit on how fast they can produce
 * samples.  Such streams will always return 0x40000000 as the ready-count.
 * This may well exceed the length of the audio stream.  You therefore need to
 * check length separately.
 *
 * If the aborted flag is set, that means the ready count is no longer being
 * replenished.  For example, a MovieAudioCursor might be reading from an
 * internet radio station, and it might buffer data to avoid underruns.  If it
 * loses connection to the radio station, it will set the aborted flag to
 * indicate that the buffer is no longer being replenished.  But it is still
 * ok to read the samples that are in the buffer, at least until they run out.
 * Once those are gone, there will be no more.
 *
 * An audio consumer needs to check the length, the ready status, and the
 * aborted flag.
 */
48
virtual int MovieAudioCursor::ready(void) const;

125 4 seek 0 6 194 22 MovieAudioCursor::seek 0 1 27 746
/**
 * Skips to the specified offset within the file.
 *
 * If the movie reports that it cannot seek, then this method can still
 * advance by reading samples and discarding them.  However, to move backward,
 * can_seek must be true.
 *
 * If the movie reports that it can_seek, it doesn't mean that it can do so
 * quickly.  It may have to rewind the movie and then fast forward to the
 * desired location.  Only if can_seek_fast returns true can seek operations
 * be done in constant time.
 *
 * Seeking may not be precise, because AVI files often have inaccurate
 * indices.  After seeking, tell will indicate that the cursor is at the
 * target location.  However, in truth, the data you read may come from a
 * slightly offset location.
 */
51
virtual void MovieAudioCursor::seek(double offset);

126 12 read_samples 0 4 194 30 MovieAudioCursor::read_samples 0 2 28 29 798
/**
 * Read audio samples from the stream.  N is the number of samples you wish to
 * read.  Your buffer must be equal in size to N * channels.  Multiple-channel
 * audio will be interleaved.
 */

/**
 * Read audio samples from the stream into a Datagram.  N is the number of
 * samples you wish to read.  Multiple-channel audio will be interleaved.
 *
 * This is not particularly efficient, but it may be a convenient way to
 * manipulate samples in python.
 */

/**
 * Read audio samples from the stream and returns them as a string.  The
 * samples are stored little-endian in the string.  N is the number of samples
 * you wish to read.  Multiple-channel audio will be interleaved.
 *
 * This is not particularly efficient, but it may be a convenient way to
 * manipulate samples in python.
 */
108
void MovieAudioCursor::read_samples(int n, Datagram *dg);
std::string MovieAudioCursor::read_samples(int n);

127 14 get_class_type 0 4 194 32 MovieAudioCursor::get_class_type 0 1 30 0
57
static TypeHandle MovieAudioCursor::get_class_type(void);

128 15 FlacAudioCursor 0 4 195 32 FlacAudioCursor::FlacAudioCursor 0 2 31 32 129
/**
 * Reads the .wav header from the indicated stream.  This leaves the read
 * pointer positioned at the start of the data.
 */
142
FlacAudioCursor::FlacAudioCursor(FlacAudio *src, istream *stream);
inline FlacAudioCursor::FlacAudioCursor(FlacAudioCursor const &) = default;

129 14 get_class_type 0 4 195 31 FlacAudioCursor::get_class_type 0 1 33 0
56
static TypeHandle FlacAudioCursor::get_class_type(void);

130 37 upcast_to_TypedWritableReferenceCount 0 12 196 49 MovieVideo::upcast_to_TypedWritableReferenceCount 0 1 41 53
upcast from MovieVideo to TypedWritableReferenceCount
85
TypedWritableReferenceCount *MovieVideo::upcast_to_TypedWritableReferenceCount(void);

131 22 downcast_to_MovieVideo 0 12 189 51 TypedWritableReferenceCount::downcast_to_MovieVideo 0 1 42 55
downcast from TypedWritableReferenceCount to MovieVideo
70
MovieVideo *TypedWritableReferenceCount::downcast_to_MovieVideo(void);

132 17 upcast_to_Namable 0 12 196 29 MovieVideo::upcast_to_Namable 0 1 43 33
upcast from MovieVideo to Namable
45
Namable *MovieVideo::upcast_to_Namable(void);

133 22 downcast_to_MovieVideo 0 12 190 31 Namable::downcast_to_MovieVideo 0 1 44 35
downcast from Namable to MovieVideo
50
MovieVideo *Namable::downcast_to_MovieVideo(void);

134 10 MovieVideo 0 4 196 22 MovieVideo::MovieVideo 0 2 34 35 212
/**
 * This constructor returns a null video stream --- a stream of plain blue and
 * white frames that last one second each.  To get more interesting video, you
 * need to construct a subclass of this class.
 */
125
MovieVideo::MovieVideo(std::string const &name = "Blank Video");
inline MovieVideo::MovieVideo(MovieVideo const &) = default;

135 11 ~MovieVideo 0 6 196 23 MovieVideo::~MovieVideo 0 0 10
/**
 *
 */
38
virtual MovieVideo::~MovieVideo(void);

136 4 open 0 6 196 16 MovieVideo::open 0 1 36 107
/**
 * Open this video, returning a MovieVideoCursor of the appropriate type.
 * Returns NULL on error.
 */
61
virtual PointerTo< MovieVideoCursor > MovieVideo::open(void);

137 3 get 0 4 196 15 MovieVideo::get 0 1 37 103
/**
 * Obtains a MovieVideo that references a file.  Just calls
 * MovieTypeRegistry::make_video().
 */
69
static PointerTo< MovieVideo > MovieVideo::get(Filename const &name);

138 12 get_filename 0 4 196 24 MovieVideo::get_filename 0 1 38 144
/**
 * Returns the movie's filename.  A movie is not guaranteed to have a
 * filename, if not, then this function returns an empty filename.
 */
60
inline Filename const &MovieVideo::get_filename(void) const;

139 16 get_subfile_info 0 4 196 28 MovieVideo::get_subfile_info 0 1 39 150
/**
 * If the movie is to be loaded from a subfile on disk, this returns the
 * subfile info.  Check info.is_empty() to see if this is valid data.
 */
67
inline SubfileInfo const &MovieVideo::get_subfile_info(void) const;

140 14 get_class_type 0 4 196 26 MovieVideo::get_class_type 0 1 40 0
51
static TypeHandle MovieVideo::get_class_type(void);

141 12 InkblotVideo 0 4 199 26 InkblotVideo::InkblotVideo 0 2 45 46 14
/**
 * xxx
 */
117
InkblotVideo::InkblotVideo(int x, int y, int fps);
inline InkblotVideo::InkblotVideo(InkblotVideo const &) = default;

142 14 get_class_type 0 4 199 28 InkblotVideo::get_class_type 0 1 47 0
53
static TypeHandle InkblotVideo::get_class_type(void);

143 10 get_source 0 4 200 28 MovieVideoCursor::get_source 0 1 49 59
/**
 * Get the MovieVideo which this cursor references.
 */
65
PointerTo< MovieVideo > MovieVideoCursor::get_source(void) const;

144 6 size_x 0 4 200 24 MovieVideoCursor::size_x 0 1 50 48
/**
 * Get the horizontal size of the movie.
 */
48
inline int MovieVideoCursor::size_x(void) const;

145 6 size_y 0 4 200 24 MovieVideoCursor::size_y 0 1 51 46
/**
 * Get the vertical size of the movie.
 */
48
inline int MovieVideoCursor::size_y(void) const;

146 18 get_num_components 0 4 200 36 MovieVideoCursor::get_num_components 0 1 52 68
/**
 * Returns 4 if the movie has an alpha channel, 3 otherwise.
 */
60
inline int MovieVideoCursor::get_num_components(void) const;

147 6 length 0 4 200 24 MovieVideoCursor::length 0 1 53 1170
/**
 * Returns the length of the movie.
 *
 * Some kinds of Movie, such as internet TV station, might not have a
 * predictable length.  In that case, the length will be set to a very large
 * number: 1.0E10. If the internet TV station goes offline, the video or audio
 * stream will set its abort flag.  Reaching the end of the movie (ie, the
 * specified length) normally does not cause the abort flag to be set.
 *
 * The video and audio streams produced by get_video and get_audio are always
 * of unlimited duration - you can always read another video frame or another
 * audio sample.  This is true even if the specified length is reached, or an
 * abort is flagged.  If either stream runs out of data, it will synthesize
 * blank video frames and silent audio samples as necessary to satisfy read
 * requests.
 *
 * Some AVI files have incorrect length values encoded into them - usually,
 * they're a second or two long or short.  When playing such an AVI using the
 * Movie class, you may see a slightly truncated video, or a slightly
 * elongated video (padded with black frames).  There are utilities out there
 * to fix the length values in AVI files.
 *
 */
51
inline double MovieVideoCursor::length(void) const;

148 8 can_seek 0 4 200 26 MovieVideoCursor::can_seek 0 1 54 430
/**
 * Returns true if the movie can seek.  If this is true, seeking is still not
 * guaranteed to be fast: for some movies, seeking is implemented by rewinding
 * to the beginning and then fast-forwarding to the desired location.  Even if
 * the movie cannot seek, the fetch methods can still advance to an arbitrary
 * location by reading frames and discarding them.  However, to move backward,
 * can_seek must return true.
 */
51
inline bool MovieVideoCursor::can_seek(void) const;

149 13 can_seek_fast 0 4 200 31 MovieVideoCursor::can_seek_fast 0 1 55 61
/**
 * Returns true if seek operations are constant time.
 */
56
inline bool MovieVideoCursor::can_seek_fast(void) const;

150 7 aborted 0 4 200 25 MovieVideoCursor::aborted 0 1 56 260
/**
 * Returns true if the video has aborted prematurely.  For example, this could
 * occur if the Movie was actually an internet TV station, and the connection
 * was lost.  Reaching the normal end of the video does not constitute an
 * 'abort' condition.
 */
50
inline bool MovieVideoCursor::aborted(void) const;

151 5 ready 0 4 200 23 MovieVideoCursor::ready 0 1 57 156
/**
 * Returns true if the cursor is a streaming source, and if a video frame is
 * ready to be read.  For non- streaming sources, this is always false.
 */
48
inline bool MovieVideoCursor::ready(void) const;

152 9 streaming 0 4 200 27 MovieVideoCursor::streaming 0 1 58 528
/**
 * Returns true if the video frames are being "pushed" at us by something that
 * operates at its own speed - for example, a webcam.  In this case, the
 * frames come when they're ready to come.  Attempting to read too soon will
 * produce nothing, reading too late will cause frames to be dropped.  In this
 * case, the ready flag can be used to determine whether or not a frame is
 * ready for reading.
 *
 * When streaming, you should still pay attention to last_start, but the value
 * of next_start is only a guess.
 */
52
inline bool MovieVideoCursor::streaming(void) const;

153 13 setup_texture 0 4 200 31 MovieVideoCursor::setup_texture 0 1 59 130
/**
 * Set up the specified Texture object to contain content from this movie.
 * This should be called once, not every frame.
 */
57
void MovieVideoCursor::setup_texture(Texture *tex) const;

154 8 set_time 0 6 200 26 MovieVideoCursor::set_time 0 1 60 850
/**
 * Updates the cursor to the indicated time.  If loop_count >= 1, the time is
 * clamped to the movie's length * loop_count.  If loop_count <= 0, the time
 * is understood to be modulo the movie's length.
 *
 * Returns true if a new frame is now available, false otherwise.  If this
 * returns true, you should immediately follow this with exactly *one* call to
 * fetch_buffer().
 *
 * If the movie reports that it can_seek, you may also specify a time value
 * less than the previous value you passed to set_time().  Otherwise, you may
 * only specify a time value greater than or equal to the previous value.
 *
 * If the movie reports that it can_seek, it doesn't mean that it can do so
 * quickly.  It may have to rewind the movie and then fast forward to the
 * desired location.  Only if can_seek_fast returns true can it seek rapidly.
 */
74
virtual bool MovieVideoCursor::set_time(double timestamp, int loop_count);

155 17 compare_timestamp 0 6 201 43 MovieVideoCursor::Buffer::compare_timestamp 0 1 67 335
/**
 * Used to sort different buffers to ensure they correspond to the same source
 * frame, particularly important when synchronizing the different pages of a
 * multi-page texture.
 *
 * Returns 0 if the two buffers are of the same frame, <0 if this one comes
 * earlier than the other one, and >0 if the other one comes earlier.
 */
101
virtual int MovieVideoCursor::Buffer::compare_timestamp(MovieVideoCursor::Buffer const *other) const;

156 13 get_timestamp 0 6 201 39 MovieVideoCursor::Buffer::get_timestamp 0 1 68 236
/**
 * Returns the nearest timestamp value of this particular buffer.  Ideally,
 * MovieVideoCursor::set_time() for this timestamp would return this buffer
 * again.  This need be defined only if compare_timestamp() is also defined.
 */
67
virtual double MovieVideoCursor::Buffer::get_timestamp(void) const;

157 14 get_class_type 0 4 201 40 MovieVideoCursor::Buffer::get_class_type 0 1 69 0
65
static TypeHandle MovieVideoCursor::Buffer::get_class_type(void);

158 6 Buffer 0 4 201 32 MovieVideoCursor::Buffer::Buffer 0 1 66 10
/**
 *
 */
84
inline MovieVideoCursor::Buffer::Buffer(MovieVideoCursor::Buffer const &) = default;

159 12 fetch_buffer 0 6 200 30 MovieVideoCursor::fetch_buffer 0 1 61 331
/**
 * Gets the current video frame (as specified by set_time()) from the movie
 * and returns it in a pre-allocated buffer.  You may simply let the buffer
 * dereference and delete itself when you are done with it.
 *
 * This may return NULL (even if set_time() returned true) if the frame is not
 * available for some reason.
 */
83
virtual PointerTo< MovieVideoCursor::Buffer > MovieVideoCursor::fetch_buffer(void);

160 16 apply_to_texture 0 6 200 34 MovieVideoCursor::apply_to_texture 0 1 62 66
/**
 * Stores this buffer's contents in the indicated texture.
 */
110
virtual void MovieVideoCursor::apply_to_texture(MovieVideoCursor::Buffer const *buffer, Texture *t, int page);

161 20 apply_to_texture_rgb 0 6 200 38 MovieVideoCursor::apply_to_texture_rgb 0 1 63 140
/**
 * Copies this buffer's contents into the RGB channels of the supplied
 * texture.  The alpha channel of the texture is not touched.
 */
114
virtual void MovieVideoCursor::apply_to_texture_rgb(MovieVideoCursor::Buffer const *buffer, Texture *t, int page);

162 22 apply_to_texture_alpha 0 6 200 40 MovieVideoCursor::apply_to_texture_alpha 0 1 64 141
/**
 * Copies this buffer's contents into the alpha channel of the supplied
 * texture.  The RGB channels of the texture are not touched.
 */
131
virtual void MovieVideoCursor::apply_to_texture_alpha(MovieVideoCursor::Buffer const *buffer, Texture *t, int page, int alpha_src);

163 14 get_class_type 0 4 200 32 MovieVideoCursor::get_class_type 0 1 65 0
57
static TypeHandle MovieVideoCursor::get_class_type(void);

164 16 MovieVideoCursor 0 4 200 34 MovieVideoCursor::MovieVideoCursor 0 1 48 121
/**
 * This is a virtual base class and should not be created directly.  Instead,
 * create a more specialized class.
 */
78
inline MovieVideoCursor::MovieVideoCursor(MovieVideoCursor const &) = default;

165 18 InkblotVideoCursor 0 4 203 38 InkblotVideoCursor::InkblotVideoCursor 0 2 70 71 14
/**
 * xxx
 */
143
InkblotVideoCursor::InkblotVideoCursor(InkblotVideo *src);
inline InkblotVideoCursor::InkblotVideoCursor(InkblotVideoCursor const &) = default;

166 14 get_class_type 0 4 203 34 InkblotVideoCursor::get_class_type 0 1 72 0
59
static TypeHandle InkblotVideoCursor::get_class_type(void);

167 15 get_num_options 0 4 204 32 MicrophoneAudio::get_num_options 0 1 73 218
/**
 * Returns the number of microphone options.  An "option" consists of a device
 * plus a set of configuration parameters.  For example, "Soundblaster Audigy
 * Line in at 44,100 samples/sec" would be an option.
 */
50
static int MicrophoneAudio::get_num_options(void);

168 10 get_option 0 4 204 27 MicrophoneAudio::get_option 0 1 74 45
/**
 * Returns the nth microphone option.
 */
71
static PointerTo< MicrophoneAudio > MicrophoneAudio::get_option(int n);

169 12 get_channels 0 4 204 29 MicrophoneAudio::get_channels 0 1 75 42
/**
 * Returns the number of channels.
 */
53
inline int MicrophoneAudio::get_channels(void) const;

170 8 get_rate 0 4 204 25 MicrophoneAudio::get_rate 0 1 76 35
/**
 * Returns the sample rate.
 */
49
inline int MicrophoneAudio::get_rate(void) const;

171 14 get_class_type 0 4 204 31 MicrophoneAudio::get_class_type 0 1 77 0
56
static TypeHandle MicrophoneAudio::get_class_type(void);

172 13 UserDataAudio 0 4 207 28 UserDataAudio::UserDataAudio 0 2 78 79 104
/**
 * This constructor returns a UserDataAudio --- a means to supply raw audio
 * samples manually.
 */
154
UserDataAudio::UserDataAudio(int rate, int channels, bool remove_after_read = true);
inline UserDataAudio::UserDataAudio(UserDataAudio const &) = default;

173 6 append 0 4 207 21 UserDataAudio::append 0 2 80 81 413
/**
 * Appends audio samples to the buffer.
 */

/**
 * Appends audio samples to the buffer from a datagram.  This is intended to
 * make it easy to send streaming raw audio over a network.
 */

/**
 * Appends audio samples to the buffer from a string.  The samples must be
 * stored little-endian in the string.  This is not particularly efficient,
 * but it may be convenient to deal with samples in python.
 */
174
void UserDataAudio::append(int16_t *data, int n);
void UserDataAudio::append(DatagramIterator *src, int len = 1073741824);
void UserDataAudio::append(std::string const &str);

174 4 done 0 4 207 19 UserDataAudio::done 0 1 82 143
// A promise not to write any more samples.

/**
 * Promises not to append any more samples, ie, this marks the end of the
 * audio stream.
 */
31
void UserDataAudio::done(void);

175 14 get_class_type 0 4 207 29 UserDataAudio::get_class_type 0 1 83 0
54
static TypeHandle UserDataAudio::get_class_type(void);

176 19 UserDataAudioCursor 0 4 208 40 UserDataAudioCursor::UserDataAudioCursor 0 2 84 85 10
/**
 *
 */
149
UserDataAudioCursor::UserDataAudioCursor(UserDataAudio *src);
inline UserDataAudioCursor::UserDataAudioCursor(UserDataAudioCursor const &) = default;

177 14 get_class_type 0 4 208 35 UserDataAudioCursor::get_class_type 0 1 86 0
60
static TypeHandle UserDataAudioCursor::get_class_type(void);

178 11 VorbisAudio 0 4 209 24 VorbisAudio::VorbisAudio 0 2 87 88 14
/**
 * xxx
 */
111
VorbisAudio::VorbisAudio(Filename const &name);
inline VorbisAudio::VorbisAudio(VorbisAudio const &) = default;

179 4 make 0 4 209 17 VorbisAudio::make 0 1 89 55
/**
 * Obtains a MovieAudio that references a file.
 */
71
static PointerTo< MovieAudio > VorbisAudio::make(Filename const &name);

180 14 get_class_type 0 4 209 27 VorbisAudio::get_class_type 0 1 90 0
52
static TypeHandle VorbisAudio::get_class_type(void);

181 17 VorbisAudioCursor 0 4 210 36 VorbisAudioCursor::VorbisAudioCursor 0 2 91 92 129
/**
 * Reads the .wav header from the indicated stream.  This leaves the read
 * pointer positioned at the start of the data.
 */
154
VorbisAudioCursor::VorbisAudioCursor(VorbisAudio *src, istream *stream);
inline VorbisAudioCursor::VorbisAudioCursor(VorbisAudioCursor const &) = default;

182 14 get_class_type 0 4 210 33 VorbisAudioCursor::get_class_type 0 1 93 0
58
static TypeHandle VorbisAudioCursor::get_class_type(void);

183 8 WavAudio 0 4 211 18 WavAudio::WavAudio 0 2 94 95 14
/**
 * xxx
 */
96
WavAudio::WavAudio(Filename const &name);
inline WavAudio::WavAudio(WavAudio const &) = default;

184 4 make 0 4 211 14 WavAudio::make 0 1 96 55
/**
 * Obtains a MovieAudio that references a file.
 */
68
static PointerTo< MovieAudio > WavAudio::make(Filename const &name);

185 14 get_class_type 0 4 211 24 WavAudio::get_class_type 0 1 97 0
49
static TypeHandle WavAudio::get_class_type(void);

186 14 WavAudioCursor 0 4 212 30 WavAudioCursor::WavAudioCursor 0 2 98 99 129
/**
 * Reads the .wav header from the indicated stream.  This leaves the read
 * pointer positioned at the start of the data.
 */
136
WavAudioCursor::WavAudioCursor(WavAudio *src, istream *stream);
inline WavAudioCursor::WavAudioCursor(WavAudioCursor const &) = default;

187 14 get_class_type 0 4 212 30 WavAudioCursor::get_class_type 0 1 100 0
55
static TypeHandle WavAudioCursor::get_class_type(void);

100
1 0 0 7 8 215 106 0 0 1 6 param0 0 213  
2 0 0 7 8 215 106 0 200 /**
 * This constructor returns a null audio stream --- a stream of total silence,
 * at 8000 samples per second.  To get more interesting audio, you need to
 * construct a subclass of this class.
 */ 1 4 name 1 216  
3 0 0 7 10 217 0 0 56 /**
 * Open this audio, returning a MovieAudioCursor
 */ 1 4 this 3 215  
4 0 0 7 11 215 106 0 103 /**
 * Obtains a MovieAudio that references a file.  Just calls
 * MovieTypeRegistry::make_audio().
 */ 1 4 name 1 218  
5 0 0 6 12 218 0 0 142 /**
 * Returns the movie's filename.  A movie is not guaranteed to have a
 * filename, if not, then this function returns a null filename.
 */ 1 4 this 3 213  
6 0 0 7 16 220 0 0 0 0 
7 0 0 7 3 221 0 0 0 1 4 this 3 215  
8 0 0 7 4 215 106 0 0 1 4 this 3 221  
9 0 0 6 6 222 0 0 0 1 4 this 3 215  
10 0 0 7 7 215 106 0 0 1 4 this 3 222  
11 0 0 7 18 223 106 0 14 /**
 * xxx
 */ 1 4 name 1 218  
12 0 0 7 18 223 106 0 0 1 6 param0 0 224  
13 0 0 7 19 215 106 0 55 /**
 * Obtains a MovieAudio that references a file.
 */ 1 4 name 1 218  
14 0 0 7 20 220 0 0 0 0 
15 0 0 7 22 217 0 0 200 /**
 * This constructor returns a null audio stream --- a stream of total silence,
 * at 8000 samples per second.  To get more interesting audio, you need to
 * construct a subclass of this class.
 */ 1 3 src 1 215  
16 0 0 7 22 217 0 0 0 1 6 param0 0 226  
17 0 0 7 23 215 106 0 63 /**
 * Returns the MovieAudio which this cursor references.
 */ 1 4 this 3 226  
18 0 0 6 24 206 0 0 41 /**
 * Returns the audio sample rate.
 */ 1 4 this 3 226  
19 0 0 6 25 206 0 0 83 /**
 * Returns the number of audio channels (ie, two for stereo, one for mono).
 */ 1 4 this 3 226  
20 0 0 6 26 228 0 0 742 /**
 * Returns the length of the movie.  Attempting to read audio samples beyond
 * the specified length will produce silent samples.
 *
 * Some kinds of Movie, such as internet TV station, might not have a
 * predictable length.  In that case, the length will be set to a very large
 * number: 1.0E10.
 *
 * Some AVI files have incorrect length values encoded into them - they may be
 * a second or two long or short.  When playing such an AVI using the Movie
 * class, you may see a slightly truncated video, or a slightly elongated
 * video (padded with black frames).  There are utilities out there to fix the
 * length values in AVI files.
 *
 * An audio consumer needs to check the length, the ready status, and the
 * aborted flag.
 */ 1 4 this 3 226  
21 0 0 6 27 229 0 0 429 /**
 * Returns true if the movie can seek.  If this is true, seeking is still not
 * guaranteed to be fast: for some movies, seeking is implemented by rewinding
 * to the beginning and then fast-forwarding to the desired location.  Even if
 * the movie cannot seek, the seek method can still advance to an arbitrary
 * location by reading samples and discarding them.  However, to move
 * backward, can_seek must return true.
 */ 1 4 this 3 226  
22 0 0 6 28 229 0 0 61 /**
 * Returns true if seek operations are constant time.
 */ 1 4 this 3 226  
23 0 0 6 29 228 0 0 54 /**
 * Returns the current offset within the file.
 */ 1 4 this 3 226  
24 0 0 4 30 230 0 0 86 /**
 * Skip audio samples from the stream.  This is mostly for debugging purposes.
 */ 2 4 this 3 217  1 n 1 206  
25 0 0 6 31 229 0 0 138 /**
 * If aborted is true, it means that the "ready" samples are not being
 * replenished.  See the method "ready" for an explanation.
 */ 1 4 this 3 226  
26 0 0 6 32 206 0 0 1120 /**
 * Returns the number of audio samples that are ready to read.  This is
 * primarily relevant for sources like microphones which produce samples at a
 * fixed rate.  If you try to read more samples than are ready, the result
 * will be silent samples.
 *
 * Some audio streams do not have a limit on how fast they can produce
 * samples.  Such streams will always return 0x40000000 as the ready-count.
 * This may well exceed the length of the audio stream.  You therefore need to
 * check length separately.
 *
 * If the aborted flag is set, that means the ready count is no longer being
 * replenished.  For example, a MovieAudioCursor might be reading from an
 * internet radio station, and it might buffer data to avoid underruns.  If it
 * loses connection to the radio station, it will set the aborted flag to
 * indicate that the buffer is no longer being replenished.  But it is still
 * ok to read the samples that are in the buffer, at least until they run out.
 * Once those are gone, there will be no more.
 *
 * An audio consumer needs to check the length, the ready status, and the
 * aborted flag.
 */ 1 4 this 3 226  
27 0 0 4 33 230 0 0 746 /**
 * Skips to the specified offset within the file.
 *
 * If the movie reports that it cannot seek, then this method can still
 * advance by reading samples and discarding them.  However, to move backward,
 * can_seek must be true.
 *
 * If the movie reports that it can_seek, it doesn't mean that it can do so
 * quickly.  It may have to rewind the movie and then fast forward to the
 * desired location.  Only if can_seek_fast returns true can seek operations
 * be done in constant time.
 *
 * Seeking may not be precise, because AVI files often have inaccurate
 * indices.  After seeking, tell will indicate that the cursor is at the
 * target location.  However, in truth, the data you read may come from a
 * slightly offset location.
 */ 2 4 this 3 217  6 offset 1 228  
28 0 0 6 34 216 0 0 334 /**
 * Read audio samples from the stream and returns them as a string.  The
 * samples are stored little-endian in the string.  N is the number of samples
 * you wish to read.  Multiple-channel audio will be interleaved.
 *
 * This is not particularly efficient, but it may be a convenient way to
 * manipulate samples in python.
 */ 2 4 this 3 217  1 n 1 206  
29 0 0 4 34 230 0 0 265 /**
 * Read audio samples from the stream into a Datagram.  N is the number of
 * samples you wish to read.  Multiple-channel audio will be interleaved.
 *
 * This is not particularly efficient, but it may be a convenient way to
 * manipulate samples in python.
 */ 3 4 this 3 217  1 n 1 206  2 dg 1 231  
30 0 0 7 35 220 0 0 0 0 
31 0 0 7 37 235 0 0 129 /**
 * Reads the .wav header from the indicated stream.  This leaves the read
 * pointer positioned at the start of the data.
 */ 2 3 src 1 223  6 stream 1 233  
32 0 0 7 37 235 0 0 0 1 6 param0 0 236  
33 0 0 7 38 220 0 0 0 0 
34 0 0 7 44 240 135 0 0 1 6 param0 0 238  
35 0 0 7 44 240 135 0 212 /**
 * This constructor returns a null video stream --- a stream of plain blue and
 * white frames that last one second each.  To get more interesting video, you
 * need to construct a subclass of this class.
 */ 1 4 name 1 216  
36 0 0 7 46 241 0 0 107 /**
 * Open this video, returning a MovieVideoCursor of the appropriate type.
 * Returns NULL on error.
 */ 1 4 this 3 240  
37 0 0 7 47 240 135 0 103 /**
 * Obtains a MovieVideo that references a file.  Just calls
 * MovieTypeRegistry::make_video().
 */ 1 4 name 1 218  
38 0 0 6 48 218 0 0 144 /**
 * Returns the movie's filename.  A movie is not guaranteed to have a
 * filename, if not, then this function returns an empty filename.
 */ 1 4 this 3 238  
39 0 0 6 49 242 0 0 150 /**
 * If the movie is to be loaded from a subfile on disk, this returns the
 * subfile info.  Check info.is_empty() to see if this is valid data.
 */ 1 4 this 3 238  
40 0 0 7 54 220 0 0 0 0 
41 0 0 7 40 221 0 0 0 1 4 this 3 240  
42 0 0 7 41 240 135 0 0 1 4 this 3 221  
43 0 0 6 42 222 0 0 0 1 4 this 3 240  
44 0 0 7 43 240 135 0 0 1 4 this 3 222  
45 0 0 7 56 245 135 0 0 1 6 param0 0 243  
46 0 0 7 56 245 135 0 14 /**
 * xxx
 */ 3 1 x 1 206  1 y 1 206  3 fps 1 206  
47 0 0 7 57 220 0 0 0 0 
48 0 0 7 82 241 0 0 0 1 6 param0 0 246  
49 0 0 7 59 240 135 0 59 /**
 * Get the MovieVideo which this cursor references.
 */ 1 4 this 3 246  
50 0 0 6 60 206 0 0 48 /**
 * Get the horizontal size of the movie.
 */ 1 4 this 3 246  
51 0 0 6 61 206 0 0 46 /**
 * Get the vertical size of the movie.
 */ 1 4 this 3 246  
52 0 0 6 62 206 0 0 68 /**
 * Returns 4 if the movie has an alpha channel, 3 otherwise.
 */ 1 4 this 3 246  
53 0 0 6 63 228 0 0 1170 /**
 * Returns the length of the movie.
 *
 * Some kinds of Movie, such as internet TV station, might not have a
 * predictable length.  In that case, the length will be set to a very large
 * number: 1.0E10. If the internet TV station goes offline, the video or audio
 * stream will set its abort flag.  Reaching the end of the movie (ie, the
 * specified length) normally does not cause the abort flag to be set.
 *
 * The video and audio streams produced by get_video and get_audio are always
 * of unlimited duration - you can always read another video frame or another
 * audio sample.  This is true even if the specified length is reached, or an
 * abort is flagged.  If either stream runs out of data, it will synthesize
 * blank video frames and silent audio samples as necessary to satisfy read
 * requests.
 *
 * Some AVI files have incorrect length values encoded into them - usually,
 * they're a second or two long or short.  When playing such an AVI using the
 * Movie class, you may see a slightly truncated video, or a slightly
 * elongated video (padded with black frames).  There are utilities out there
 * to fix the length values in AVI files.
 *
 */ 1 4 this 3 246  
54 0 0 6 64 229 0 0 430 /**
 * Returns true if the movie can seek.  If this is true, seeking is still not
 * guaranteed to be fast: for some movies, seeking is implemented by rewinding
 * to the beginning and then fast-forwarding to the desired location.  Even if
 * the movie cannot seek, the fetch methods can still advance to an arbitrary
 * location by reading frames and discarding them.  However, to move backward,
 * can_seek must return true.
 */ 1 4 this 3 246  
55 0 0 6 65 229 0 0 61 /**
 * Returns true if seek operations are constant time.
 */ 1 4 this 3 246  
56 0 0 6 66 229 0 0 260 /**
 * Returns true if the video has aborted prematurely.  For example, this could
 * occur if the Movie was actually an internet TV station, and the connection
 * was lost.  Reaching the normal end of the video does not constitute an
 * 'abort' condition.
 */ 1 4 this 3 246  
57 0 0 6 67 229 0 0 156 /**
 * Returns true if the cursor is a streaming source, and if a video frame is
 * ready to be read.  For non- streaming sources, this is always false.
 */ 1 4 this 3 246  
58 0 0 6 68 229 0 0 528 /**
 * Returns true if the video frames are being "pushed" at us by something that
 * operates at its own speed - for example, a webcam.  In this case, the
 * frames come when they're ready to come.  Attempting to read too soon will
 * produce nothing, reading too late will cause frames to be dropped.  In this
 * case, the ready flag can be used to determine whether or not a frame is
 * ready for reading.
 *
 * When streaming, you should still pay attention to last_start, but the value
 * of next_start is only a guess.
 */ 1 4 this 3 246  
59 0 0 4 69 230 0 0 130 /**
 * Set up the specified Texture object to contain content from this movie.
 * This should be called once, not every frame.
 */ 2 4 this 3 246  3 tex 1 248  
60 0 0 6 70 229 0 0 850 /**
 * Updates the cursor to the indicated time.  If loop_count >= 1, the time is
 * clamped to the movie's length * loop_count.  If loop_count <= 0, the time
 * is understood to be modulo the movie's length.
 *
 * Returns true if a new frame is now available, false otherwise.  If this
 * returns true, you should immediately follow this with exactly *one* call to
 * fetch_buffer().
 *
 * If the movie reports that it can_seek, you may also specify a time value
 * less than the previous value you passed to set_time().  Otherwise, you may
 * only specify a time value greater than or equal to the previous value.
 *
 * If the movie reports that it can_seek, it doesn't mean that it can do so
 * quickly.  It may have to rewind the movie and then fast forward to the
 * desired location.  Only if can_seek_fast returns true can it seek rapidly.
 */ 3 4 this 3 241  9 timestamp 1 228  10 loop_count 1 206  
61 0 0 7 77 250 0 0 331 /**
 * Gets the current video frame (as specified by set_time()) from the movie
 * and returns it in a pre-allocated buffer.  You may simply let the buffer
 * dereference and delete itself when you are done with it.
 *
 * This may return NULL (even if set_time() returned true) if the frame is not
 * available for some reason.
 */ 1 4 this 3 241  
62 0 0 4 78 230 0 0 66 /**
 * Stores this buffer's contents in the indicated texture.
 */ 4 4 this 3 241  6 buffer 1 251  1 t 1 248  4 page 1 206  
63 0 0 4 79 230 0 0 140 /**
 * Copies this buffer's contents into the RGB channels of the supplied
 * texture.  The alpha channel of the texture is not touched.
 */ 4 4 this 3 241  6 buffer 1 251  1 t 1 248  4 page 1 206  
64 0 0 4 80 230 0 0 141 /**
 * Copies this buffer's contents into the alpha channel of the supplied
 * texture.  The RGB channels of the texture are not touched.
 */ 5 4 this 3 241  6 buffer 1 251  1 t 1 248  4 page 1 206  9 alpha_src 1 206  
65 0 0 7 81 220 0 0 0 0 
66 0 0 7 76 250 0 0 0 1 6 param0 0 251  
67 0 0 6 73 206 0 0 335 /**
 * Used to sort different buffers to ensure they correspond to the same source
 * frame, particularly important when synchronizing the different pages of a
 * multi-page texture.
 *
 * Returns 0 if the two buffers are of the same frame, <0 if this one comes
 * earlier than the other one, and >0 if the other one comes earlier.
 */ 2 4 this 3 251  5 other 1 251  
68 0 0 6 74 228 0 0 236 /**
 * Returns the nearest timestamp value of this particular buffer.  Ideally,
 * MovieVideoCursor::set_time() for this timestamp would return this buffer
 * again.  This need be defined only if compare_timestamp() is also defined.
 */ 1 4 this 3 251  
69 0 0 7 75 220 0 0 0 0 
70 0 0 7 84 253 0 0 14 /**
 * xxx
 */ 1 3 src 1 245  
71 0 0 7 84 253 0 0 0 1 6 param0 0 254  
72 0 0 7 85 220 0 0 0 0 
73 0 0 6 87 206 0 0 218 /**
 * Returns the number of microphone options.  An "option" consists of a device
 * plus a set of configuration parameters.  For example, "Soundblaster Audigy
 * Line in at 44,100 samples/sec" would be an option.
 */ 0 
74 0 0 7 88 256 106 0 45 /**
 * Returns the nth microphone option.
 */ 1 1 n 1 206  
75 0 0 6 90 206 0 0 42 /**
 * Returns the number of channels.
 */ 1 4 this 3 257  
76 0 0 6 91 206 0 0 35 /**
 * Returns the sample rate.
 */ 1 4 this 3 257  
77 0 0 7 97 220 0 0 0 0 
78 0 0 7 99 261 106 0 0 1 6 param0 0 259  
79 0 0 7 99 261 106 0 104 /**
 * This constructor returns a UserDataAudio --- a means to supply raw audio
 * samples manually.
 */ 3 4 rate 1 206  8 channels 1 206  17 remove_after_read 1 229  
80 0 0 4 100 230 0 0 144 /**
 * Appends audio samples to the buffer from a datagram.  This is intended to
 * make it easy to send streaming raw audio over a network.
 */ 3 4 this 3 261  3 src 1 262  3 len 1 206  
81 0 0 4 100 230 0 0 218 /**
 * Appends audio samples to the buffer from a string.  The samples must be
 * stored little-endian in the string.  This is not particularly efficient,
 * but it may be convenient to deal with samples in python.
 */ 2 4 this 3 261  3 str 1 216  
82 0 0 4 101 230 0 0 98 /**
 * Promises not to append any more samples, ie, this marks the end of the
 * audio stream.
 */ 1 4 this 3 261  
83 0 0 7 102 220 0 0 0 0 
84 0 0 7 104 264 0 0 10 /**
 *
 */ 1 3 src 1 261  
85 0 0 7 104 264 0 0 0 1 6 param0 0 265  
86 0 0 7 105 220 0 0 0 0 
87 0 0 7 107 267 106 0 14 /**
 * xxx
 */ 1 4 name 1 218  
88 0 0 7 107 267 106 0 0 1 6 param0 0 268  
89 0 0 7 108 215 106 0 55 /**
 * Obtains a MovieAudio that references a file.
 */ 1 4 name 1 218  
90 0 0 7 109 220 0 0 0 0 
91 0 0 7 111 270 0 0 129 /**
 * Reads the .wav header from the indicated stream.  This leaves the read
 * pointer positioned at the start of the data.
 */ 2 3 src 1 267  6 stream 1 233  
92 0 0 7 111 270 0 0 0 1 6 param0 0 271  
93 0 0 7 112 220 0 0 0 0 
94 0 0 7 114 273 106 0 14 /**
 * xxx
 */ 1 4 name 1 218  
95 0 0 7 114 273 106 0 0 1 6 param0 0 274  
96 0 0 7 115 215 106 0 55 /**
 * Obtains a MovieAudio that references a file.
 */ 1 4 name 1 218  
97 0 0 7 116 220 0 0 0 0 
98 0 0 7 118 276 0 0 129 /**
 * Reads the .wav header from the indicated stream.  This leaves the read
 * pointer positioned at the start of the data.
 */ 2 3 src 1 273  6 stream 1 233  
99 0 0 7 118 276 0 0 0 1 6 param0 0 277  
100 0 0 7 119 220 0 0 0 0 
91
188 10 MovieAudio 0 26625 10 MovieAudio 10 MovieAudio 0 0 0 1 105 106 1 279 4 107 108 109 110 0 0 2 3 189 101 102 3 190 103 104 0 0 397
/**
 * A MovieAudio is actually any source that provides a sequence of audio
 * samples.  That could include an AVI file, a microphone, or an internet TV
 * station.
 *
 * The difference between a MovieAudio and a MovieAudioCursor is like the
 * difference between a filename and a file handle.  The MovieAudio just
 * indicates a particular movie.  The MovieAudioCursor is what allows access.
 */

189 27 TypedWritableReferenceCount 0 2049 27 TypedWritableReferenceCount 27 TypedWritableReferenceCount 0 0 0 0 0 0 0 0 0 0 0 0 414
/**
 * A base class for things which need to inherit from both TypedWritable and
 * from ReferenceCount.  It's convenient to define this intermediate base
 * class instead of multiply inheriting from the two classes each time they
 * are needed, so that we can sensibly pass around pointers to things which
 * are both TypedWritables and ReferenceCounters.
 *
 * See also TypedObject for detailed instructions.
 */

190 7 Namable 0 2049 7 Namable 7 Namable 0 0 0 0 0 0 0 0 0 0 0 0 125
/**
 * A base class for all things which can have a name.  The name is either
 * empty or nonempty, but it is never NULL.
 */

191 14 Filename const 0 8832 14 Filename const 14 Filename const 0 0 192 0 0 0 0 0 0 0 0 0 0

192 8 Filename 0 2048 8 Filename 8 Filename 0 0 0 0 0 0 0 0 0 0 0 0 550
/**
 * The name of a file, such as a texture file or an Egg file.  Stores the full
 * pathname, and includes functions for extracting out the directory prefix
 * part and the file extension and stuff.
 *
 * A Filename is also aware of the mapping between the Unix-like filename
 * convention we use internally, and the local OS's specific filename
 * convention, and it knows how to perform basic OS-specific I/O, like testing
 * for file existence and searching a searchpath, as well as the best way to
 * open an fstream for reading or writing.
 */

193 9 FlacAudio 0 75777 9 FlacAudio 9 FlacAudio 0 0 0 1 111 106 0 2 112 113 0 0 1 0 188 0 0 0 0 82
/**
 * Reads FLAC audio files.  Ogg-encapsulated FLAC files are not supported.
 */

194 16 MovieAudioCursor 0 75777 16 MovieAudioCursor 16 MovieAudioCursor 0 0 0 1 114 0 0 13 115 116 117 118 119 120 121 122 123 124 125 126 127 0 0 1 0 189 0 0 0 0 501
/**
 * A MovieAudio is actually any source that provides a sequence of audio
 * samples.  That could include an AVI file, a microphone, or an internet TV
 * station.  A MovieAudioCursor is a handle that lets you read data
 * sequentially from a MovieAudio.
 *
 * Thread safety: each individual MovieAudioCursor must be owned and accessed
 * by a single thread.  It is OK for two different threads to open the same
 * file at the same time, as long as they use separate MovieAudioCursor
 * objects.
 */

195 15 FlacAudioCursor 0 75777 15 FlacAudioCursor 15 FlacAudioCursor 0 0 0 1 128 0 0 1 129 0 0 1 0 194 0 0 0 0 104
/**
 * Interfaces with the libvorbisfile library to implement decoding of Ogg
 * Vorbis audio files.
 */

196 10 MovieVideo 0 26625 10 MovieVideo 10 MovieVideo 0 0 0 1 134 135 2 280 281 5 136 137 138 139 140 0 0 2 3 189 130 131 3 190 132 133 0 0 400
/**
 * A MovieVideo is actually any source that provides a sequence of video
 * frames.  That could include an AVI file, a digital camera, or an internet
 * TV station.
 *
 * The difference between a MovieVideo and a MovieVideoCursor is like the
 * difference between a filename and a file handle.  The MovieVideo just
 * indicates a particular movie.  The MovieVideoCursor is what allows access.
 */

197 17 SubfileInfo const 0 8832 17 SubfileInfo const 17 SubfileInfo const 0 0 198 0 0 0 0 0 0 0 0 0 0

198 11 SubfileInfo 0 2048 11 SubfileInfo 11 SubfileInfo 0 0 0 0 0 0 0 0 0 0 0 0 200
/**
 * This class records a particular byte sub-range within an existing file on
 * disk.  Generally, the filename is understood as a physical file on disk,
 * and not to be looked up via the vfs.
 */

199 12 InkblotVideo 0 75777 12 InkblotVideo 12 InkblotVideo 0 0 0 1 141 135 0 1 142 0 0 1 0 196 0 0 0 0 85
/**
 * A cellular automaton that generates an amusing pattern of swirling colors.
 */

200 16 MovieVideoCursor 0 75777 16 MovieVideoCursor 16 MovieVideoCursor 0 0 0 1 164 0 0 17 143 144 145 146 147 148 149 150 151 152 153 154 159 160 161 162 163 0 0 1 0 189 0 0 0 1 201 504
/**
 * A MovieVideo is actually any source that provides a sequence of video
 * frames.  That could include an AVI file, a digital camera, or an internet
 * TV station.  A MovieVideoCursor is a handle that lets you read data
 * sequentially from a MovieVideo.
 *
 * Thread safety: each individual MovieVideoCursor must be owned and accessed
 * by a single thread.  It is OK for two different threads to open the same
 * file at the same time, as long as they use separate MovieVideoCursor
 * objects.
 */

201 6 Buffer 0 337921 24 MovieVideoCursor::Buffer 24 MovieVideoCursor::Buffer 200 0 0 1 158 0 0 3 155 156 157 0 0 1 0 202 0 0 0 0 0

202 19 TypedReferenceCount 0 2049 19 TypedReferenceCount 19 TypedReferenceCount 0 0 0 0 0 0 0 0 0 0 0 0 410
/**
 * A base class for things which need to inherit from both TypedObject and
 * from ReferenceCount.  It's convenient to define this intermediate base
 * class instead of multiply inheriting from the two classes each time they
 * are needed, so that we can sensibly pass around pointers to things which
 * are both TypedObjects and ReferenceCounters.
 *
 * See also TypedObject for detailed instructions.
 */

203 18 InkblotVideoCursor 0 75777 18 InkblotVideoCursor 18 InkblotVideoCursor 0 0 0 1 165 0 0 1 166 0 0 1 0 200 0 0 0 0 85
/**
 * A cellular automaton that generates an amusing pattern of swirling colors.
 */

204 15 MicrophoneAudio 0 75777 15 MicrophoneAudio 15 MicrophoneAudio 0 0 0 0 106 3 282 283 284 5 167 168 169 170 171 1 285 0 1 0 188 0 0 0 0 99
/**
 * Class MicrophoneAudio provides the means to read raw audio samples from a
 * microphone.
 */

205 28 PointerTo< MicrophoneAudio > 0 2048 28 PointerTo< MicrophoneAudio > 28 PointerTo< MicrophoneAudio > 0 0 0 0 0 0 0 0 0 0 0 0 0

206 3 int 0 8194 3 int 3 int 0 1 0 0 0 0 0 0 0 0 0 0 0

207 13 UserDataAudio 0 75777 13 UserDataAudio 13 UserDataAudio 0 0 0 1 172 106 0 3 173 174 175 0 0 1 0 188 0 0 0 0 358
/**
 * A UserDataAudio is a way for the user to manually supply raw audio samples.
 * remove_after_read means the data will be removed if read once.  Else data
 * will be stored (enable looping and seeking). Expects data as 16 bit signed
 * (word); Example for stereo: 1.word = 1.channel,2.word = 2.channel, 3.word =
 * 1.channel,4.word = 2.channel, etc.
 */

208 19 UserDataAudioCursor 0 75777 19 UserDataAudioCursor 19 UserDataAudioCursor 0 0 0 1 176 0 0 1 177 0 0 1 0 194 0 0 0 0 98
/**
 * A UserDataAudioCursor is a means to manually supply a sequence of raw audio
 * samples.
 */

209 11 VorbisAudio 0 75777 11 VorbisAudio 11 VorbisAudio 0 0 0 1 178 106 0 2 179 180 0 0 1 0 188 0 0 0 0 104
/**
 * Interfaces with the libvorbisfile library to implement decoding of Ogg
 * Vorbis audio files.
 */

210 17 VorbisAudioCursor 0 75777 17 VorbisAudioCursor 17 VorbisAudioCursor 0 0 0 1 181 0 0 1 182 0 0 1 0 194 0 0 0 0 104
/**
 * Interfaces with the libvorbisfile library to implement decoding of Ogg
 * Vorbis audio files.
 */

211 8 WavAudio 0 75777 8 WavAudio 8 WavAudio 0 0 0 1 183 106 0 2 184 185 0 0 1 0 188 0 0 0 0 104
/**
 * A native PCM .wav loader.  Supported formats are linear PCM, IEEE float,
 * A-law and mu-law.
 */

212 14 WavAudioCursor 0 75777 14 WavAudioCursor 14 WavAudioCursor 0 0 0 1 186 0 0 1 187 0 0 1 0 194 0 0 0 0 111
/**
 * Used for reading PCM .wav files.  Supported formats are linear PCM, IEEE
 * float, A-law and mu-law.
 */

213 18 MovieAudio const * 0 8576 18 MovieAudio const * 18 MovieAudio const * 0 0 214 0 0 0 0 0 0 0 0 0 0

214 16 MovieAudio const 0 8832 16 MovieAudio const 16 MovieAudio const 0 0 188 0 0 0 0 0 0 0 0 0 0

215 12 MovieAudio * 0 8576 12 MovieAudio * 12 MovieAudio * 0 0 188 0 0 0 0 0 0 0 0 0 0

216 13 atomic string 0 2 13 atomic string 13 atomic string 0 7 0 0 0 0 0 0 0 0 0 0 0

217 18 MovieAudioCursor * 0 8576 18 MovieAudioCursor * 18 MovieAudioCursor * 0 0 194 0 0 0 0 0 0 0 0 0 0

218 16 Filename const * 0 8576 16 Filename const * 16 Filename const * 0 0 191 0 0 0 0 0 0 0 0 0 0

219 10 TypeHandle 0 2048 10 TypeHandle 10 TypeHandle 0 0 0 0 0 0 0 0 0 0 0 0 732
/**
 * TypeHandle is the identifier used to differentiate C++ class types.  Any
 * C++ classes that inherit from some base class, and must be differentiated
 * at run time, should store a static TypeHandle object that can be queried
 * through a static member function named get_class_type().  Most of the time,
 * it is also desirable to inherit from TypedObject, which provides some
 * virtual functions to return the TypeHandle for a particular instance.
 *
 * At its essence, a TypeHandle is simply a unique identifier that is assigned
 * by the TypeRegistry.  The TypeRegistry stores a tree of TypeHandles, so
 * that ancestry of a particular type may be queried, and the type name may be
 * retrieved for run-time display.
 */

220 12 TypeHandle * 0 8576 12 TypeHandle * 12 TypeHandle * 0 0 219 0 0 0 0 0 0 0 0 0 0

221 29 TypedWritableReferenceCount * 0 8576 29 TypedWritableReferenceCount * 29 TypedWritableReferenceCount * 0 0 189 0 0 0 0 0 0 0 0 0 0

222 9 Namable * 0 8576 9 Namable * 9 Namable * 0 0 190 0 0 0 0 0 0 0 0 0 0

223 11 FlacAudio * 0 8576 11 FlacAudio * 11 FlacAudio * 0 0 193 0 0 0 0 0 0 0 0 0 0

224 17 FlacAudio const * 0 8576 17 FlacAudio const * 17 FlacAudio const * 0 0 225 0 0 0 0 0 0 0 0 0 0

225 15 FlacAudio const 0 8832 15 FlacAudio const 15 FlacAudio const 0 0 193 0 0 0 0 0 0 0 0 0 0

226 24 MovieAudioCursor const * 0 8576 24 MovieAudioCursor const * 24 MovieAudioCursor const * 0 0 227 0 0 0 0 0 0 0 0 0 0

227 22 MovieAudioCursor const 0 8832 22 MovieAudioCursor const 22 MovieAudioCursor const 0 0 194 0 0 0 0 0 0 0 0 0 0

228 6 double 0 8194 6 double 6 double 0 3 0 0 0 0 0 0 0 0 0 0 0

229 4 bool 0 8194 4 bool 4 bool 0 4 0 0 0 0 0 0 0 0 0 0 0

230 4 void 0 8194 4 void 4 void 0 6 0 0 0 0 0 0 0 0 0 0 0

231 10 Datagram * 0 8576 10 Datagram * 10 Datagram * 0 0 232 0 0 0 0 0 0 0 0 0 0

232 8 Datagram 0 2048 8 Datagram 8 Datagram 0 0 0 0 0 0 0 0 0 0 0 0 565
/**
 * An ordered list of data elements, formatted in memory for transmission over
 * a socket or writing to a data file.
 *
 * Data elements should be added one at a time, in order, to the Datagram.
 * The nature and contents of the data elements are totally up to the user.
 * When a Datagram has been transmitted and received, its data elements may be
 * extracted using a DatagramIterator; it is up to the caller to know the
 * correct type of each data element in order.
 *
 * A Datagram is itself headerless; it is simply a collection of data
 * elements.
 */

233 9 istream * 0 8576 9 istream * 9 istream * 0 0 234 0 0 0 0 0 0 0 0 0 0

234 7 istream 0 2048 7 istream 7 istream 0 0 0 0 0 0 0 0 0 0 0 0 0

235 17 FlacAudioCursor * 0 8576 17 FlacAudioCursor * 17 FlacAudioCursor * 0 0 195 0 0 0 0 0 0 0 0 0 0

236 23 FlacAudioCursor const * 0 8576 23 FlacAudioCursor const * 23 FlacAudioCursor const * 0 0 237 0 0 0 0 0 0 0 0 0 0

237 21 FlacAudioCursor const 0 8832 21 FlacAudioCursor const 21 FlacAudioCursor const 0 0 195 0 0 0 0 0 0 0 0 0 0

238 18 MovieVideo const * 0 8576 18 MovieVideo const * 18 MovieVideo const * 0 0 239 0 0 0 0 0 0 0 0 0 0

239 16 MovieVideo const 0 8832 16 MovieVideo const 16 MovieVideo const 0 0 196 0 0 0 0 0 0 0 0 0 0

240 12 MovieVideo * 0 8576 12 MovieVideo * 12 MovieVideo * 0 0 196 0 0 0 0 0 0 0 0 0 0

241 18 MovieVideoCursor * 0 8576 18 MovieVideoCursor * 18 MovieVideoCursor * 0 0 200 0 0 0 0 0 0 0 0 0 0

242 19 SubfileInfo const * 0 8576 19 SubfileInfo const * 19 SubfileInfo const * 0 0 197 0 0 0 0 0 0 0 0 0 0

243 20 InkblotVideo const * 0 8576 20 InkblotVideo const * 20 InkblotVideo const * 0 0 244 0 0 0 0 0 0 0 0 0 0

244 18 InkblotVideo const 0 8832 18 InkblotVideo const 18 InkblotVideo const 0 0 199 0 0 0 0 0 0 0 0 0 0

245 14 InkblotVideo * 0 8576 14 InkblotVideo * 14 InkblotVideo * 0 0 199 0 0 0 0 0 0 0 0 0 0

246 24 MovieVideoCursor const * 0 8576 24 MovieVideoCursor const * 24 MovieVideoCursor const * 0 0 247 0 0 0 0 0 0 0 0 0 0

247 22 MovieVideoCursor const 0 8832 22 MovieVideoCursor const 22 MovieVideoCursor const 0 0 200 0 0 0 0 0 0 0 0 0 0

248 9 Texture * 0 8576 9 Texture * 9 Texture * 0 0 249 0 0 0 0 0 0 0 0 0 0

249 7 Texture 0 2048 7 Texture 7 Texture 0 0 0 0 0 0 0 0 0 0 0 0 688
/**
 * Represents a texture object, which is typically a single 2-d image but may
 * also represent a 1-d or 3-d texture image, or the six 2-d faces of a cube
 * map texture.
 *
 * A texture's image data might be stored in system RAM (see get_ram_image())
 * or its image may be represented in texture memory on one or more
 * GraphicsStateGuardians (see prepare()), or both.  The typical usage pattern
 * is that a texture is loaded from an image file on disk, which copies its
 * image data into system RAM; then the first time the texture is rendered its
 * image data is copied to texture memory (actually, to the graphics API), and
 * the system RAM image is automatically freed.
 */

250 8 Buffer * 0 8576 26 MovieVideoCursor::Buffer * 26 MovieVideoCursor::Buffer * 0 0 201 0 0 0 0 0 0 0 0 0 0

251 14 Buffer const * 0 8576 32 MovieVideoCursor::Buffer const * 32 MovieVideoCursor::Buffer const * 0 0 252 0 0 0 0 0 0 0 0 0 0

252 12 Buffer const 0 8832 30 MovieVideoCursor::Buffer const 30 MovieVideoCursor::Buffer const 0 0 201 0 0 0 0 0 0 0 0 0 0

253 20 InkblotVideoCursor * 0 8576 20 InkblotVideoCursor * 20 InkblotVideoCursor * 0 0 203 0 0 0 0 0 0 0 0 0 0

254 26 InkblotVideoCursor const * 0 8576 26 InkblotVideoCursor const * 26 InkblotVideoCursor const * 0 0 255 0 0 0 0 0 0 0 0 0 0

255 24 InkblotVideoCursor const 0 8832 24 InkblotVideoCursor const 24 InkblotVideoCursor const 0 0 203 0 0 0 0 0 0 0 0 0 0

256 17 MicrophoneAudio * 0 8576 17 MicrophoneAudio * 17 MicrophoneAudio * 0 0 204 0 0 0 0 0 0 0 0 0 0

257 23 MicrophoneAudio const * 0 8576 23 MicrophoneAudio const * 23 MicrophoneAudio const * 0 0 258 0 0 0 0 0 0 0 0 0 0

258 21 MicrophoneAudio const 0 8832 21 MicrophoneAudio const 21 MicrophoneAudio const 0 0 204 0 0 0 0 0 0 0 0 0 0

259 21 UserDataAudio const * 0 8576 21 UserDataAudio const * 21 UserDataAudio const * 0 0 260 0 0 0 0 0 0 0 0 0 0

260 19 UserDataAudio const 0 8832 19 UserDataAudio const 19 UserDataAudio const 0 0 207 0 0 0 0 0 0 0 0 0 0

261 15 UserDataAudio * 0 8576 15 UserDataAudio * 15 UserDataAudio * 0 0 207 0 0 0 0 0 0 0 0 0 0

262 18 DatagramIterator * 0 8576 18 DatagramIterator * 18 DatagramIterator * 0 0 263 0 0 0 0 0 0 0 0 0 0

263 16 DatagramIterator 0 2048 16 DatagramIterator 16 DatagramIterator 0 0 0 0 0 0 0 0 0 0 0 0 215
/**
 * A class to retrieve the individual data elements previously stored in a
 * Datagram.  Elements may be retrieved one at a time; it is up to the caller
 * to know the correct type and order of each element.
 */

264 21 UserDataAudioCursor * 0 8576 21 UserDataAudioCursor * 21 UserDataAudioCursor * 0 0 208 0 0 0 0 0 0 0 0 0 0

265 27 UserDataAudioCursor const * 0 8576 27 UserDataAudioCursor const * 27 UserDataAudioCursor const * 0 0 266 0 0 0 0 0 0 0 0 0 0

266 25 UserDataAudioCursor const 0 8832 25 UserDataAudioCursor const 25 UserDataAudioCursor const 0 0 208 0 0 0 0 0 0 0 0 0 0

267 13 VorbisAudio * 0 8576 13 VorbisAudio * 13 VorbisAudio * 0 0 209 0 0 0 0 0 0 0 0 0 0

268 19 VorbisAudio const * 0 8576 19 VorbisAudio const * 19 VorbisAudio const * 0 0 269 0 0 0 0 0 0 0 0 0 0

269 17 VorbisAudio const 0 8832 17 VorbisAudio const 17 VorbisAudio const 0 0 209 0 0 0 0 0 0 0 0 0 0

270 19 VorbisAudioCursor * 0 8576 19 VorbisAudioCursor * 19 VorbisAudioCursor * 0 0 210 0 0 0 0 0 0 0 0 0 0

271 25 VorbisAudioCursor const * 0 8576 25 VorbisAudioCursor const * 25 VorbisAudioCursor const * 0 0 272 0 0 0 0 0 0 0 0 0 0

272 23 VorbisAudioCursor const 0 8832 23 VorbisAudioCursor const 23 VorbisAudioCursor const 0 0 210 0 0 0 0 0 0 0 0 0 0

273 10 WavAudio * 0 8576 10 WavAudio * 10 WavAudio * 0 0 211 0 0 0 0 0 0 0 0 0 0

274 16 WavAudio const * 0 8576 16 WavAudio const * 16 WavAudio const * 0 0 275 0 0 0 0 0 0 0 0 0 0

275 14 WavAudio const 0 8832 14 WavAudio const 14 WavAudio const 0 0 211 0 0 0 0 0 0 0 0 0 0

276 16 WavAudioCursor * 0 8576 16 WavAudioCursor * 16 WavAudioCursor * 0 0 212 0 0 0 0 0 0 0 0 0 0

277 22 WavAudioCursor const * 0 8576 22 WavAudioCursor const * 22 WavAudioCursor const * 0 0 278 0 0 0 0 0 0 0 0 0 0

278 20 WavAudioCursor const 0 8832 20 WavAudioCursor const 20 WavAudioCursor const 0 0 212 0 0 0 0 0 0 0 0 0 0

0
6
279 8 filename 0 2 191 109 0 0 0 0 0 20 MovieAudio::filename 0

280 8 filename 0 2 191 138 0 0 0 0 0 20 MovieVideo::filename 0

281 12 subfile_info 0 2 197 139 0 0 0 0 0 24 MovieVideo::subfile_info 0

282 7 options 0 66 205 168 0 0 0 0 167 24 MicrophoneAudio::options 0

283 8 channels 0 2 206 169 0 0 0 0 0 25 MicrophoneAudio::channels 0

284 4 rate 0 2 206 170 0 0 0 0 0 21 MicrophoneAudio::rate 0

1
285 11 get_options 0 167 168 28 MicrophoneAudio::get_options 0

